/*
This code is Copyright © 2023 screengarden, LLC, all rights reserved. Unauthorized copying of any files herein, via any medium and for any purpose, is prohibited, with the exception of any copying that occurs during the installation of these files as an Obsidian plugin.

"Obsidian" and the Obsidian logo are © 2023 Obsidian.
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all4) => {
  for (var name in all4)
    __defProp(target, name, { get: all4[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports2, module2) {
    init_process_shim();
    var process3 = module2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    __name(defaultSetTimout, "defaultSetTimout");
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    __name(defaultClearTimeout, "defaultClearTimeout");
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    __name(runTimeout, "runTimeout");
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    __name(runClearTimeout, "runClearTimeout");
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    __name(cleanUpNextTick, "cleanUpNextTick");
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    __name(drainQueue, "drainQueue");
    process3.nextTick = function(fun) {
      var args2 = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args2[i - 1] = arguments[i];
        }
      }
      queue.push(new Item2(fun, args2));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item2(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    __name(Item2, "Item");
    Item2.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop4() {
    }
    __name(noop4, "noop");
    process3.on = noop4;
    process3.addListener = noop4;
    process3.once = noop4;
    process3.off = noop4;
    process3.removeListener = noop4;
    process3.removeAllListeners = noop4;
    process3.emit = noop4;
    process3.prependListener = noop4;
    process3.prependOnceListener = noop4;
    process3.listeners = function(name) {
      return [];
    };
    process3.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
  }
});

// process-shim.js
var import_browser;
var init_process_shim = __esm({
  "process-shim.js"() {
    import_browser = __toESM(require_browser());
    if (typeof window !== "undefined") {
      window.global = window.global || window;
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    init_process_shim();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d2 = h * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse, "parse");
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural2(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h) {
        return plural2(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural2(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural2(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural2(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural2, "plural");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    init_process_shim();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug21(...args2) {
          if (!debug21.enabled) {
            return;
          }
          const self2 = debug21;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args2[0] = createDebug.coerce(args2[0]);
          if (typeof args2[0] !== "string") {
            args2.unshift("%O");
          }
          let index = 0;
          args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args2[index];
              match = formatter.call(self2, val);
              args2.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args2);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args2);
        }
        __name(debug21, "debug");
        debug21.namespace = namespace;
        debug21.useColors = createDebug.useColors();
        debug21.color = createDebug.selectColor(namespace);
        debug21.extend = extend2;
        debug21.destroy = createDebug.destroy;
        Object.defineProperty(debug21, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug21);
        }
        return debug21;
      }
      __name(createDebug, "createDebug");
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend2, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      __name(enable, "enable");
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      __name(toNamespace, "toNamespace");
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    init_process_shim();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof import_browser.default !== "undefined" && "env" in import_browser.default) {
        r = import_browser.default.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    __name(localstorage, "localstorage");
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/dexie/dist/dexie.js
var require_dexie = __commonJS({
  "node_modules/dexie/dist/dexie.js"(exports2, module2) {
    init_process_shim();
    (function(global3, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global3 = typeof globalThis !== "undefined" ? globalThis : global3 || self, global3.Dexie = factory());
    })(exports2, function() {
      "use strict";
      var extendStatics2 = /* @__PURE__ */ __name(function(d2, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
          d3.__proto__ = b2;
        } || function(d3, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d3[p] = b2[p];
        };
        return extendStatics2(d2, b);
      }, "extendStatics");
      function __extends2(d2, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d2, b);
        function __() {
          this.constructor = d2;
        }
        __name(__, "__");
        d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      __name(__extends2, "__extends");
      var __assign = /* @__PURE__ */ __name(function() {
        __assign = Object.assign || /* @__PURE__ */ __name(function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        }, "__assign");
        return __assign.apply(this, arguments);
      }, "__assign");
      function __spreadArray2(to, from3, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from3.length, ar; i < l; i++) {
          if (ar || !(i in from3)) {
            if (!ar) ar = Array.prototype.slice.call(from3, 0, i);
            ar[i] = from3[i];
          }
        }
        return to.concat(ar || Array.prototype.slice.call(from3));
      }
      __name(__spreadArray2, "__spreadArray");
      var _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      var keys3 = Object.keys;
      var isArray6 = Array.isArray;
      if (typeof Promise !== "undefined" && !_global2.Promise) {
        _global2.Promise = Promise;
      }
      function extend2(obj, extension) {
        if (typeof extension !== "object")
          return obj;
        keys3(extension).forEach(function(key) {
          obj[key] = extension[key];
        });
        return obj;
      }
      __name(extend2, "extend");
      var getProto = Object.getPrototypeOf;
      var _hasOwn = {}.hasOwnProperty;
      function hasOwn(obj, prop) {
        return _hasOwn.call(obj, prop);
      }
      __name(hasOwn, "hasOwn");
      function props(proto, extension) {
        if (typeof extension === "function")
          extension = extension(getProto(proto));
        (typeof Reflect === "undefined" ? keys3 : Reflect.ownKeys)(extension).forEach(function(key) {
          setProp(proto, key, extension[key]);
        });
      }
      __name(props, "props");
      var defineProperty2 = Object.defineProperty;
      function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty2(obj, prop, extend2(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
      }
      __name(setProp, "setProp");
      function derive(Child) {
        return {
          from: /* @__PURE__ */ __name(function(Parent) {
            Child.prototype = Object.create(Parent.prototype);
            setProp(Child.prototype, "constructor", Child);
            return {
              extend: props.bind(null, Child.prototype)
            };
          }, "from")
        };
      }
      __name(derive, "derive");
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      function getPropertyDescriptor(obj, prop) {
        var pd = getOwnPropertyDescriptor(obj, prop);
        var proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
      }
      __name(getPropertyDescriptor, "getPropertyDescriptor");
      var _slice = [].slice;
      function slice(args2, start, end) {
        return _slice.call(args2, start, end);
      }
      __name(slice, "slice");
      function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
      }
      __name(override, "override");
      function assert(b) {
        if (!b)
          throw new Error("Assertion Failed");
      }
      __name(assert, "assert");
      function asap$1(fn) {
        if (_global2.setImmediate)
          setImmediate(fn);
        else
          setTimeout(fn, 0);
      }
      __name(asap$1, "asap$1");
      function arrayToObject2(array, extractor) {
        return array.reduce(function(result, item, i) {
          var nameAndValue = extractor(item, i);
          if (nameAndValue)
            result[nameAndValue[0]] = nameAndValue[1];
          return result;
        }, {});
      }
      __name(arrayToObject2, "arrayToObject");
      function getByKeyPath(obj, keyPath) {
        if (typeof keyPath === "string" && hasOwn(obj, keyPath))
          return obj[keyPath];
        if (!keyPath)
          return obj;
        if (typeof keyPath !== "string") {
          var rv = [];
          for (var i = 0, l = keyPath.length; i < l; ++i) {
            var val = getByKeyPath(obj, keyPath[i]);
            rv.push(val);
          }
          return rv;
        }
        var period = keyPath.indexOf(".");
        if (period !== -1) {
          var innerObj = obj[keyPath.substr(0, period)];
          return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return void 0;
      }
      __name(getByKeyPath, "getByKeyPath");
      function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === void 0)
          return;
        if ("isFrozen" in Object && Object.isFrozen(obj))
          return;
        if (typeof keyPath !== "string" && "length" in keyPath) {
          assert(typeof value !== "string" && "length" in value);
          for (var i = 0, l = keyPath.length; i < l; ++i) {
            setByKeyPath(obj, keyPath[i], value[i]);
          }
        } else {
          var period = keyPath.indexOf(".");
          if (period !== -1) {
            var currentKeyPath = keyPath.substr(0, period);
            var remainingKeyPath = keyPath.substr(period + 1);
            if (remainingKeyPath === "")
              if (value === void 0) {
                if (isArray6(obj) && !isNaN(parseInt(currentKeyPath)))
                  obj.splice(currentKeyPath, 1);
                else
                  delete obj[currentKeyPath];
              } else
                obj[currentKeyPath] = value;
            else {
              var innerObj = obj[currentKeyPath];
              if (!innerObj || !hasOwn(obj, currentKeyPath))
                innerObj = obj[currentKeyPath] = {};
              setByKeyPath(innerObj, remainingKeyPath, value);
            }
          } else {
            if (value === void 0) {
              if (isArray6(obj) && !isNaN(parseInt(keyPath)))
                obj.splice(keyPath, 1);
              else
                delete obj[keyPath];
            } else
              obj[keyPath] = value;
          }
        }
      }
      __name(setByKeyPath, "setByKeyPath");
      function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === "string")
          setByKeyPath(obj, keyPath, void 0);
        else if ("length" in keyPath)
          [].map.call(keyPath, function(kp) {
            setByKeyPath(obj, kp, void 0);
          });
      }
      __name(delByKeyPath, "delByKeyPath");
      function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
          if (hasOwn(obj, m))
            rv[m] = obj[m];
        }
        return rv;
      }
      __name(shallowClone, "shallowClone");
      var concat = [].concat;
      function flatten(a) {
        return concat.apply([], a);
      }
      __name(flatten, "flatten");
      var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map(function(num) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + num + "Array";
        });
      }))).filter(function(t) {
        return _global2[t];
      });
      var intrinsicTypes = new Set(intrinsicTypeNames.map(function(t) {
        return _global2[t];
      }));
      function cloneSimpleObjectTree(o) {
        var rv = {};
        for (var k in o)
          if (hasOwn(o, k)) {
            var v = o[k];
            rv[k] = !v || typeof v !== "object" || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
          }
        return rv;
      }
      __name(cloneSimpleObjectTree, "cloneSimpleObjectTree");
      function objectIsEmpty(o) {
        for (var k in o)
          if (hasOwn(o, k))
            return false;
        return true;
      }
      __name(objectIsEmpty, "objectIsEmpty");
      var circularRefs = null;
      function deepClone(any2) {
        circularRefs = /* @__PURE__ */ new WeakMap();
        var rv = innerDeepClone(any2);
        circularRefs = null;
        return rv;
      }
      __name(deepClone, "deepClone");
      function innerDeepClone(x) {
        if (!x || typeof x !== "object")
          return x;
        var rv = circularRefs.get(x);
        if (rv)
          return rv;
        if (isArray6(x)) {
          rv = [];
          circularRefs.set(x, rv);
          for (var i = 0, l = x.length; i < l; ++i) {
            rv.push(innerDeepClone(x[i]));
          }
        } else if (intrinsicTypes.has(x.constructor)) {
          rv = x;
        } else {
          var proto = getProto(x);
          rv = proto === Object.prototype ? {} : Object.create(proto);
          circularRefs.set(x, rv);
          for (var prop in x) {
            if (hasOwn(x, prop)) {
              rv[prop] = innerDeepClone(x[prop]);
            }
          }
        }
        return rv;
      }
      __name(innerDeepClone, "innerDeepClone");
      var toString4 = {}.toString;
      function toStringTag(o) {
        return toString4.call(o).slice(8, -1);
      }
      __name(toStringTag, "toStringTag");
      var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
      var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
      } : function() {
        return null;
      };
      function delArrayItem(a, x) {
        var i = a.indexOf(x);
        if (i >= 0)
          a.splice(i, 1);
        return i >= 0;
      }
      __name(delArrayItem, "delArrayItem");
      var NO_CHAR_ARRAY = {};
      function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
          if (isArray6(arrayLike))
            return arrayLike.slice();
          if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
            return [arrayLike];
          if (it = getIteratorOf(arrayLike)) {
            a = [];
            while (x = it.next(), !x.done)
              a.push(x.value);
            return a;
          }
          if (arrayLike == null)
            return [arrayLike];
          i = arrayLike.length;
          if (typeof i === "number") {
            a = new Array(i);
            while (i--)
              a[i] = arrayLike[i];
            return a;
          }
          return [arrayLike];
        }
        i = arguments.length;
        a = new Array(i);
        while (i--)
          a[i] = arguments[i];
        return a;
      }
      __name(getArrayOf, "getArrayOf");
      var isAsyncFunction = typeof Symbol !== "undefined" ? function(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return false;
      };
      var dexieErrorNames = [
        "Modify",
        "Bulk",
        "OpenFailed",
        "VersionChange",
        "Schema",
        "Upgrade",
        "InvalidTable",
        "MissingAPI",
        "NoSuchDatabase",
        "InvalidArgument",
        "SubTransaction",
        "Unsupported",
        "Internal",
        "DatabaseClosed",
        "PrematureCommit",
        "ForeignAwait"
      ];
      var idbDomErrorNames = [
        "Unknown",
        "Constraint",
        "Data",
        "TransactionInactive",
        "ReadOnly",
        "Version",
        "NotFound",
        "InvalidState",
        "InvalidAccess",
        "Abort",
        "Timeout",
        "QuotaExceeded",
        "Syntax",
        "DataClone"
      ];
      var errorList = dexieErrorNames.concat(idbDomErrorNames);
      var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed",
        MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
      };
      function DexieError(name, msg) {
        this.name = name;
        this.message = msg;
      }
      __name(DexieError, "DexieError");
      derive(DexieError).from(Error).extend({
        toString: /* @__PURE__ */ __name(function() {
          return this.name + ": " + this.message;
        }, "toString")
      });
      function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures).map(function(key) {
          return failures[key].toString();
        }).filter(function(v, i, s) {
          return s.indexOf(v) === i;
        }).join("\n");
      }
      __name(getMultiErrorMessage, "getMultiErrorMessage");
      function ModifyError(msg, failures, successCount, failedKeys) {
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
      }
      __name(ModifyError, "ModifyError");
      derive(ModifyError).from(DexieError);
      function BulkError(msg, failures) {
        this.name = "BulkError";
        this.failures = Object.keys(failures).map(function(pos) {
          return failures[pos];
        });
        this.failuresByPos = failures;
        this.message = getMultiErrorMessage(msg, this.failures);
      }
      __name(BulkError, "BulkError");
      derive(BulkError).from(DexieError);
      var errnames = errorList.reduce(function(obj, name) {
        return obj[name] = name + "Error", obj;
      }, {});
      var BaseException = DexieError;
      var exceptions = errorList.reduce(function(obj, name) {
        var fullName = name + "Error";
        function DexieError2(msgOrInner, inner) {
          this.name = fullName;
          if (!msgOrInner) {
            this.message = defaultTexts[name] || fullName;
            this.inner = null;
          } else if (typeof msgOrInner === "string") {
            this.message = "".concat(msgOrInner).concat(!inner ? "" : "\n " + inner);
            this.inner = inner || null;
          } else if (typeof msgOrInner === "object") {
            this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
            this.inner = msgOrInner;
          }
        }
        __name(DexieError2, "DexieError");
        derive(DexieError2).from(BaseException);
        obj[name] = DexieError2;
        return obj;
      }, {});
      exceptions.Syntax = SyntaxError;
      exceptions.Type = TypeError;
      exceptions.Range = RangeError;
      var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
      }, {});
      function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
          return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
          setProp(rv, "stack", { get: /* @__PURE__ */ __name(function() {
            return this.inner.stack;
          }, "get") });
        }
        return rv;
      }
      __name(mapError, "mapError");
      var fullNameExceptions = errorList.reduce(function(obj, name) {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1)
          obj[name + "Error"] = exceptions[name];
        return obj;
      }, {});
      fullNameExceptions.ModifyError = ModifyError;
      fullNameExceptions.DexieError = DexieError;
      fullNameExceptions.BulkError = BulkError;
      function nop() {
      }
      __name(nop, "nop");
      function mirror(val) {
        return val;
      }
      __name(mirror, "mirror");
      function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror)
          return f2;
        return function(val) {
          return f2(f1(val));
        };
      }
      __name(pureFunctionChain, "pureFunctionChain");
      function callBoth(on1, on2) {
        return function() {
          on1.apply(this, arguments);
          on2.apply(this, arguments);
        };
      }
      __name(callBoth, "callBoth");
      function hookCreatingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          var res = f1.apply(this, arguments);
          if (res !== void 0)
            arguments[0] = res;
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = null;
          this.onerror = null;
          var res2 = f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          return res2 !== void 0 ? res2 : res;
        };
      }
      __name(hookCreatingChain, "hookCreatingChain");
      function hookDeletingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          f1.apply(this, arguments);
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = this.onerror = null;
          f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
      }
      __name(hookDeletingChain, "hookDeletingChain");
      function hookUpdatingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function(modifications) {
          var res = f1.apply(this, arguments);
          extend2(modifications, res);
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = null;
          this.onerror = null;
          var res2 = f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend2(res, res2);
        };
      }
      __name(hookUpdatingChain, "hookUpdatingChain");
      function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          if (f2.apply(this, arguments) === false)
            return false;
          return f1.apply(this, arguments);
        };
      }
      __name(reverseStoppableEventChain, "reverseStoppableEventChain");
      function promisableChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          var res = f1.apply(this, arguments);
          if (res && typeof res.then === "function") {
            var thiz = this, i = arguments.length, args2 = new Array(i);
            while (i--)
              args2[i] = arguments[i];
            return res.then(function() {
              return f2.apply(thiz, args2);
            });
          }
          return f2.apply(this, arguments);
        };
      }
      __name(promisableChain, "promisableChain");
      var debug21 = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function setDebug(value, filter2) {
        debug21 = value;
      }
      __name(setDebug, "setDebug");
      var INTERNAL = {};
      var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === "undefined" ? [] : function() {
        var globalP = Promise.resolve();
        if (typeof crypto === "undefined" || !crypto.subtle)
          return [globalP, getProto(globalP), globalP];
        var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [
          nativeP,
          getProto(nativeP),
          globalP
        ];
      }(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
      var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
      var patchGlobalPromise = !!resolvedGlobalPromise;
      function schedulePhysicalTick() {
        queueMicrotask(physicalTick);
      }
      __name(schedulePhysicalTick, "schedulePhysicalTick");
      var asap2 = /* @__PURE__ */ __name(function(callback, args2) {
        microtickQueue.push([callback, args2]);
        if (needsNewPhysicalTick) {
          schedulePhysicalTick();
          needsNewPhysicalTick = false;
        }
      }, "asap");
      var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], rejectionMapper = mirror;
      var globalPSD = {
        id: "global",
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: nop,
        pgp: false,
        env: {},
        finalize: nop
      };
      var PSD = globalPSD;
      var microtickQueue = [];
      var numScheduledCalls = 0;
      var tickFinalizers = [];
      function DexiePromise(fn) {
        if (typeof this !== "object")
          throw new TypeError("Promises must be constructed via new");
        this._listeners = [];
        this._lib = false;
        var psd = this._PSD = PSD;
        if (typeof fn !== "function") {
          if (fn !== INTERNAL)
            throw new TypeError("Not a function");
          this._state = arguments[1];
          this._value = arguments[2];
          if (this._state === false)
            handleRejection(this, this._value);
          return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
      }
      __name(DexiePromise, "DexiePromise");
      var thenProp = {
        get: /* @__PURE__ */ __name(function() {
          var psd = PSD, microTaskId = totalEchoes;
          function then(onFulfilled, onRejected) {
            var _this = this;
            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
            var cleanup = possibleAwait && !decrementExpectedAwaits();
            var rv = new DexiePromise(function(resolve, reject) {
              propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
            });
            if (this._consoleTask)
              rv._consoleTask = this._consoleTask;
            return rv;
          }
          __name(then, "then");
          then.prototype = INTERNAL;
          return then;
        }, "get"),
        set: /* @__PURE__ */ __name(function(value) {
          setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
            get: /* @__PURE__ */ __name(function() {
              return value;
            }, "get"),
            set: thenProp.set
          });
        }, "set")
      };
      props(DexiePromise.prototype, {
        then: thenProp,
        _then: /* @__PURE__ */ __name(function(onFulfilled, onRejected) {
          propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        }, "_then"),
        catch: /* @__PURE__ */ __name(function(onRejected) {
          if (arguments.length === 1)
            return this.then(null, onRejected);
          var type2 = arguments[0], handler = arguments[1];
          return typeof type2 === "function" ? this.then(null, function(err) {
            return err instanceof type2 ? handler(err) : PromiseReject(err);
          }) : this.then(null, function(err) {
            return err && err.name === type2 ? handler(err) : PromiseReject(err);
          });
        }, "catch"),
        finally: /* @__PURE__ */ __name(function(onFinally) {
          return this.then(function(value) {
            return DexiePromise.resolve(onFinally()).then(function() {
              return value;
            });
          }, function(err) {
            return DexiePromise.resolve(onFinally()).then(function() {
              return PromiseReject(err);
            });
          });
        }, "finally"),
        timeout: /* @__PURE__ */ __name(function(ms2, msg) {
          var _this = this;
          return ms2 < Infinity ? new DexiePromise(function(resolve, reject) {
            var handle = setTimeout(function() {
              return reject(new exceptions.Timeout(msg));
            }, ms2);
            _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
          }) : this;
        }, "timeout")
      });
      if (typeof Symbol !== "undefined" && Symbol.toStringTag)
        setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
      globalPSD.env = snapShot();
      function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
        this.onRejected = typeof onRejected === "function" ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
      }
      __name(Listener, "Listener");
      props(DexiePromise, {
        all: /* @__PURE__ */ __name(function() {
          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve, reject) {
            if (values.length === 0)
              resolve([]);
            var remaining = values.length;
            values.forEach(function(a, i) {
              return DexiePromise.resolve(a).then(function(x) {
                values[i] = x;
                if (!--remaining)
                  resolve(values);
              }, reject);
            });
          });
        }, "all"),
        resolve: /* @__PURE__ */ __name(function(value) {
          if (value instanceof DexiePromise)
            return value;
          if (value && typeof value.then === "function")
            return new DexiePromise(function(resolve, reject) {
              value.then(resolve, reject);
            });
          var rv = new DexiePromise(INTERNAL, true, value);
          return rv;
        }, "resolve"),
        reject: PromiseReject,
        race: /* @__PURE__ */ __name(function() {
          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve, reject) {
            values.map(function(value) {
              return DexiePromise.resolve(value).then(resolve, reject);
            });
          });
        }, "race"),
        PSD: {
          get: /* @__PURE__ */ __name(function() {
            return PSD;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            return PSD = value;
          }, "set")
        },
        totalEchoes: { get: /* @__PURE__ */ __name(function() {
          return totalEchoes;
        }, "get") },
        newPSD: newScope,
        usePSD,
        scheduler: {
          get: /* @__PURE__ */ __name(function() {
            return asap2;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            asap2 = value;
          }, "set")
        },
        rejectionMapper: {
          get: /* @__PURE__ */ __name(function() {
            return rejectionMapper;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            rejectionMapper = value;
          }, "set")
        },
        follow: /* @__PURE__ */ __name(function(fn, zoneProps) {
          return new DexiePromise(function(resolve, reject) {
            return newScope(function(resolve2, reject2) {
              var psd = PSD;
              psd.unhandleds = [];
              psd.onunhandled = reject2;
              psd.finalize = callBoth(function() {
                var _this = this;
                run_at_end_of_this_or_next_physical_tick(function() {
                  _this.unhandleds.length === 0 ? resolve2() : reject2(_this.unhandleds[0]);
                });
              }, psd.finalize);
              fn();
            }, zoneProps, resolve, reject);
          });
        }, "follow")
      });
      if (NativePromise) {
        if (NativePromise.allSettled)
          setProp(DexiePromise, "allSettled", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve) {
              if (possiblePromises.length === 0)
                resolve([]);
              var remaining = possiblePromises.length;
              var results = new Array(remaining);
              possiblePromises.forEach(function(p, i) {
                return DexiePromise.resolve(p).then(function(value) {
                  return results[i] = { status: "fulfilled", value };
                }, function(reason) {
                  return results[i] = { status: "rejected", reason };
                }).then(function() {
                  return --remaining || resolve(results);
                });
              });
            });
          });
        if (NativePromise.any && typeof AggregateError !== "undefined")
          setProp(DexiePromise, "any", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
              if (possiblePromises.length === 0)
                reject(new AggregateError([]));
              var remaining = possiblePromises.length;
              var failures = new Array(remaining);
              possiblePromises.forEach(function(p, i) {
                return DexiePromise.resolve(p).then(function(value) {
                  return resolve(value);
                }, function(failure) {
                  failures[i] = failure;
                  if (!--remaining)
                    reject(new AggregateError(failures));
                });
              });
            });
          });
      }
      function executePromiseTask(promise, fn) {
        try {
          fn(function(value) {
            if (promise._state !== null)
              return;
            if (value === promise)
              throw new TypeError("A promise cannot be resolved with itself.");
            var shouldExecuteTick = promise._lib && beginMicroTickScope();
            if (value && typeof value.then === "function") {
              executePromiseTask(promise, function(resolve, reject) {
                value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
              });
            } else {
              promise._state = true;
              promise._value = value;
              propagateAllListeners(promise);
            }
            if (shouldExecuteTick)
              endMicroTickScope();
          }, handleRejection.bind(null, promise));
        } catch (ex) {
          handleRejection(promise, ex);
        }
      }
      __name(executePromiseTask, "executePromiseTask");
      function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null)
          return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick)
          endMicroTickScope();
      }
      __name(handleRejection, "handleRejection");
      function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i = 0, len = listeners.length; i < len; ++i) {
          propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
          ++numScheduledCalls;
          asap2(function() {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
          }, []);
        }
      }
      __name(propagateAllListeners, "propagateAllListeners");
      function propagateToListener(promise, listener) {
        if (promise._state === null) {
          promise._listeners.push(listener);
          return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
          return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap2(callListener, [cb, promise, listener]);
      }
      __name(propagateToListener, "propagateToListener");
      function callListener(cb, promise, listener) {
        try {
          var ret, value = promise._value;
          if (!promise._state && rejectingErrors.length)
            rejectingErrors = [];
          ret = debug21 && promise._consoleTask ? promise._consoleTask.run(function() {
            return cb(value);
          }) : cb(value);
          if (!promise._state && rejectingErrors.indexOf(value) === -1) {
            markErrorAsHandled(promise);
          }
          listener.resolve(ret);
        } catch (e) {
          listener.reject(e);
        } finally {
          if (--numScheduledCalls === 0)
            finalizePhysicalTick();
          --listener.psd.ref || listener.psd.finalize();
        }
      }
      __name(callListener, "callListener");
      function physicalTick() {
        usePSD(globalPSD, function() {
          beginMicroTickScope() && endMicroTickScope();
        });
      }
      __name(physicalTick, "physicalTick");
      function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
      }
      __name(beginMicroTickScope, "beginMicroTickScope");
      function endMicroTickScope() {
        var callbacks, i, l;
        do {
          while (microtickQueue.length > 0) {
            callbacks = microtickQueue;
            microtickQueue = [];
            l = callbacks.length;
            for (i = 0; i < l; ++i) {
              var item = callbacks[i];
              item[0].apply(null, item[1]);
            }
          }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
      }
      __name(endMicroTickScope, "endMicroTickScope");
      function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function(p) {
          p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0);
        var i = finalizers.length;
        while (i)
          finalizers[--i]();
      }
      __name(finalizePhysicalTick, "finalizePhysicalTick");
      function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
          fn();
          tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        __name(finalizer, "finalizer");
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap2(function() {
          if (--numScheduledCalls === 0)
            finalizePhysicalTick();
        }, []);
      }
      __name(run_at_end_of_this_or_next_physical_tick, "run_at_end_of_this_or_next_physical_tick");
      function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(function(p) {
          return p._value === promise._value;
        }))
          unhandledErrors.push(promise);
      }
      __name(addPossiblyUnhandledError, "addPossiblyUnhandledError");
      function markErrorAsHandled(promise) {
        var i = unhandledErrors.length;
        while (i)
          if (unhandledErrors[--i]._value === promise._value) {
            unhandledErrors.splice(i, 1);
            return;
          }
      }
      __name(markErrorAsHandled, "markErrorAsHandled");
      function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
      }
      __name(PromiseReject, "PromiseReject");
      function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function() {
          var wasRootExec = beginMicroTickScope(), outerScope = PSD;
          try {
            switchToZone(psd, true);
            return fn.apply(this, arguments);
          } catch (e) {
            errorCatcher && errorCatcher(e);
          } finally {
            switchToZone(outerScope, false);
            if (wasRootExec)
              endMicroTickScope();
          }
        };
      }
      __name(wrap, "wrap");
      var task = { awaits: 0, echoes: 0, id: 0 };
      var taskCounter = 0;
      var zoneStack = [];
      var zoneEchoes = 0;
      var totalEchoes = 0;
      var zone_id_counter = 0;
      function newScope(fn, props2, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        globalPSD.env;
        psd.env = patchGlobalPromise ? {
          Promise: DexiePromise,
          PromiseProp: { value: DexiePromise, configurable: true, writable: true },
          all: DexiePromise.all,
          race: DexiePromise.race,
          allSettled: DexiePromise.allSettled,
          any: DexiePromise.any,
          resolve: DexiePromise.resolve,
          reject: DexiePromise.reject
        } : {};
        if (props2)
          extend2(psd, props2);
        ++parent.ref;
        psd.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0)
          psd.finalize();
        return rv;
      }
      __name(newScope, "newScope");
      function incrementExpectedAwaits() {
        if (!task.id)
          task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
      }
      __name(incrementExpectedAwaits, "incrementExpectedAwaits");
      function decrementExpectedAwaits() {
        if (!task.awaits)
          return false;
        if (--task.awaits === 0)
          task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
      }
      __name(decrementExpectedAwaits, "decrementExpectedAwaits");
      if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
      }
      function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
          incrementExpectedAwaits();
          return possiblePromise.then(function(x) {
            decrementExpectedAwaits();
            return x;
          }, function(e) {
            decrementExpectedAwaits();
            return rejection(e);
          });
        }
        return possiblePromise;
      }
      __name(onPossibleParallellAsync, "onPossibleParallellAsync");
      function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
          task.echoes = task.awaits = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
      }
      __name(zoneEnterEcho, "zoneEnterEcho");
      function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
      }
      __name(zoneLeaveEcho, "zoneLeaveEcho");
      function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
          queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD)
          return;
        PSD = targetZone;
        if (currentZone === globalPSD)
          globalPSD.env = snapShot();
        if (patchGlobalPromise) {
          var GlobalPromise = globalPSD.env.Promise;
          var targetEnv = targetZone.env;
          if (currentZone.global || targetZone.global) {
            Object.defineProperty(_global2, "Promise", targetEnv.PromiseProp);
            GlobalPromise.all = targetEnv.all;
            GlobalPromise.race = targetEnv.race;
            GlobalPromise.resolve = targetEnv.resolve;
            GlobalPromise.reject = targetEnv.reject;
            if (targetEnv.allSettled)
              GlobalPromise.allSettled = targetEnv.allSettled;
            if (targetEnv.any)
              GlobalPromise.any = targetEnv.any;
          }
        }
      }
      __name(switchToZone, "switchToZone");
      function snapShot() {
        var GlobalPromise = _global2.Promise;
        return patchGlobalPromise ? {
          Promise: GlobalPromise,
          PromiseProp: Object.getOwnPropertyDescriptor(_global2, "Promise"),
          all: GlobalPromise.all,
          race: GlobalPromise.race,
          allSettled: GlobalPromise.allSettled,
          any: GlobalPromise.any,
          resolve: GlobalPromise.resolve,
          reject: GlobalPromise.reject
        } : {};
      }
      __name(snapShot, "snapShot");
      function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
          switchToZone(psd, true);
          return fn(a1, a2, a3);
        } finally {
          switchToZone(outerScope, false);
        }
      }
      __name(usePSD, "usePSD");
      function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== "function" ? fn : function() {
          var outerZone = PSD;
          if (possibleAwait)
            incrementExpectedAwaits();
          switchToZone(zone, true);
          try {
            return fn.apply(this, arguments);
          } finally {
            switchToZone(outerZone, false);
            if (cleanup)
              queueMicrotask(decrementExpectedAwaits);
          }
        };
      }
      __name(nativeAwaitCompatibleWrap, "nativeAwaitCompatibleWrap");
      function execInGlobalContext(cb) {
        if (Promise === NativePromise && task.echoes === 0) {
          if (zoneEchoes === 0) {
            cb();
          } else {
            enqueueNativeMicroTask(cb);
          }
        } else {
          setTimeout(cb, 0);
        }
      }
      __name(execInGlobalContext, "execInGlobalContext");
      var rejection = DexiePromise.reject;
      function tempTransaction(db, mode, storeNames, fn) {
        if (!db.idbdb || !db._state.openComplete && (!PSD.letThrough && !db._vip)) {
          if (db._state.openComplete) {
            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
          }
          if (!db._state.isBeingOpened) {
            if (!db._state.autoOpen)
              return rejection(new exceptions.DatabaseClosed());
            db.open().catch(nop);
          }
          return db._state.dbReadyPromise.then(function() {
            return tempTransaction(db, mode, storeNames, fn);
          });
        } else {
          var trans = db._createTransaction(mode, storeNames, db._dbSchema);
          try {
            trans.create();
            db._state.PR1398_maxLoop = 3;
          } catch (ex) {
            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
              console.warn("Dexie: Need to reopen db");
              db.close({ disableAutoOpen: false });
              return db.open().then(function() {
                return tempTransaction(db, mode, storeNames, fn);
              });
            }
            return rejection(ex);
          }
          return trans._promise(mode, function(resolve, reject) {
            return newScope(function() {
              PSD.trans = trans;
              return fn(resolve, reject, trans);
            });
          }).then(function(result) {
            if (mode === "readwrite")
              try {
                trans.idbtrans.commit();
              } catch (_a9) {
              }
            return mode === "readonly" ? result : trans._completion.then(function() {
              return result;
            });
          });
        }
      }
      __name(tempTransaction, "tempTransaction");
      var DEXIE_VERSION = "4.0.4";
      var maxString = String.fromCharCode(65535);
      var minKey = -Infinity;
      var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
      var STRING_EXPECTED = "String expected.";
      var connections = [];
      var DBNAMES_DB = "__dbnames";
      var READONLY = "readonly";
      var READWRITE = "readwrite";
      function combine(filter1, filter2) {
        return filter1 ? filter2 ? function() {
          return filter1.apply(this, arguments) && filter2.apply(this, arguments);
        } : filter1 : filter2;
      }
      __name(combine, "combine");
      var AnyRange = {
        type: 3,
        lower: -Infinity,
        lowerOpen: false,
        upper: [[]],
        upperOpen: false
      };
      function workaroundForUndefinedPrimKey(keyPath) {
        return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
          if (obj[keyPath] === void 0 && keyPath in obj) {
            obj = deepClone(obj);
            delete obj[keyPath];
          }
          return obj;
        } : function(obj) {
          return obj;
        };
      }
      __name(workaroundForUndefinedPrimKey, "workaroundForUndefinedPrimKey");
      function Entity2() {
        throw exceptions.Type();
      }
      __name(Entity2, "Entity");
      function cmp2(a, b) {
        try {
          var ta = type(a);
          var tb = type(b);
          if (ta !== tb) {
            if (ta === "Array")
              return 1;
            if (tb === "Array")
              return -1;
            if (ta === "binary")
              return 1;
            if (tb === "binary")
              return -1;
            if (ta === "string")
              return 1;
            if (tb === "string")
              return -1;
            if (ta === "Date")
              return 1;
            if (tb !== "Date")
              return NaN;
            return -1;
          }
          switch (ta) {
            case "number":
            case "Date":
            case "string":
              return a > b ? 1 : a < b ? -1 : 0;
            case "binary": {
              return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
            }
            case "Array":
              return compareArrays(a, b);
          }
        } catch (_a9) {
        }
        return NaN;
      }
      __name(cmp2, "cmp");
      function compareArrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
          var res = cmp2(a[i], b[i]);
          if (res !== 0)
            return res;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
      }
      __name(compareArrays, "compareArrays");
      function compareUint8Arrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
          if (a[i] !== b[i])
            return a[i] < b[i] ? -1 : 1;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
      }
      __name(compareUint8Arrays, "compareUint8Arrays");
      function type(x) {
        var t = typeof x;
        if (t !== "object")
          return t;
        if (ArrayBuffer.isView(x))
          return "binary";
        var tsTag = toStringTag(x);
        return tsTag === "ArrayBuffer" ? "binary" : tsTag;
      }
      __name(type, "type");
      function getUint8Array(a) {
        if (a instanceof Uint8Array)
          return a;
        if (ArrayBuffer.isView(a))
          return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
        return new Uint8Array(a);
      }
      __name(getUint8Array, "getUint8Array");
      var Table = function() {
        function Table2() {
        }
        __name(Table2, "Table");
        Table2.prototype._trans = function(mode, fn, writeLocked) {
          var trans = this._tx || PSD.trans;
          var tableName = this.name;
          var task2 = debug21 && typeof console !== "undefined" && console.createTask && console.createTask("Dexie: ".concat(mode === "readonly" ? "read" : "write", " ").concat(this.name));
          function checkTableInTransaction(resolve, reject, trans2) {
            if (!trans2.schema[tableName])
              throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            return fn(trans2.idbtrans, trans2);
          }
          __name(checkTableInTransaction, "checkTableInTransaction");
          var wasRootExec = beginMicroTickScope();
          try {
            var p = trans && trans.db._novip === this.db._novip ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
              return trans._promise(mode, checkTableInTransaction, writeLocked);
            }, { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
            if (task2) {
              p._consoleTask = task2;
              p = p.catch(function(err) {
                console.trace(err);
                return rejection(err);
              });
            }
            return p;
          } finally {
            if (wasRootExec)
              endMicroTickScope();
          }
        };
        Table2.prototype.get = function(keyOrCrit, cb) {
          var _this = this;
          if (keyOrCrit && keyOrCrit.constructor === Object)
            return this.where(keyOrCrit).first(cb);
          if (keyOrCrit == null)
            return rejection(new exceptions.Type("Invalid argument to Table.get()"));
          return this._trans("readonly", function(trans) {
            return _this.core.get({ trans, key: keyOrCrit }).then(function(res) {
              return _this.hook.reading.fire(res);
            });
          }).then(cb);
        };
        Table2.prototype.where = function(indexOrCrit) {
          if (typeof indexOrCrit === "string")
            return new this.db.WhereClause(this, indexOrCrit);
          if (isArray6(indexOrCrit))
            return new this.db.WhereClause(this, "[".concat(indexOrCrit.join("+"), "]"));
          var keyPaths = keys3(indexOrCrit);
          if (keyPaths.length === 1)
            return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
          var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
            if (ix.compound && keyPaths.every(function(keyPath) {
              return ix.keyPath.indexOf(keyPath) >= 0;
            })) {
              for (var i = 0; i < keyPaths.length; ++i) {
                if (keyPaths.indexOf(ix.keyPath[i]) === -1)
                  return false;
              }
              return true;
            }
            return false;
          }).sort(function(a, b) {
            return a.keyPath.length - b.keyPath.length;
          })[0];
          if (compoundIndex && this.db._maxKey !== maxString) {
            var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
            return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map(function(kp) {
              return indexOrCrit[kp];
            }));
          }
          if (!compoundIndex && debug21)
            console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(keyPaths.join("+"), "]"));
          var idxByName = this.schema.idxByName;
          var idb = this.db._deps.indexedDB;
          function equals(a, b) {
            return idb.cmp(a, b) === 0;
          }
          __name(equals, "equals");
          var _a9 = keyPaths.reduce(function(_a10, keyPath) {
            var prevIndex = _a10[0], prevFilterFn = _a10[1];
            var index = idxByName[keyPath];
            var value = indexOrCrit[keyPath];
            return [
              prevIndex || index,
              prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function(x) {
                var prop = getByKeyPath(x, keyPath);
                return isArray6(prop) && prop.some(function(item) {
                  return equals(value, item);
                });
              } : function(x) {
                return equals(value, getByKeyPath(x, keyPath));
              }) : prevFilterFn
            ];
          }, [null, null]), idx = _a9[0], filterFunction = _a9[1];
          return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
        };
        Table2.prototype.filter = function(filterFunction) {
          return this.toCollection().and(filterFunction);
        };
        Table2.prototype.count = function(thenShortcut) {
          return this.toCollection().count(thenShortcut);
        };
        Table2.prototype.offset = function(offset) {
          return this.toCollection().offset(offset);
        };
        Table2.prototype.limit = function(numRows) {
          return this.toCollection().limit(numRows);
        };
        Table2.prototype.each = function(callback) {
          return this.toCollection().each(callback);
        };
        Table2.prototype.toArray = function(thenShortcut) {
          return this.toCollection().toArray(thenShortcut);
        };
        Table2.prototype.toCollection = function() {
          return new this.db.Collection(new this.db.WhereClause(this));
        };
        Table2.prototype.orderBy = function(index) {
          return new this.db.Collection(new this.db.WhereClause(this, isArray6(index) ? "[".concat(index.join("+"), "]") : index));
        };
        Table2.prototype.reverse = function() {
          return this.toCollection().reverse();
        };
        Table2.prototype.mapToClass = function(constructor) {
          var _a9 = this, db = _a9.db, tableName = _a9.name;
          this.schema.mappedClass = constructor;
          if (constructor.prototype instanceof Entity2) {
            constructor = function(_super) {
              __extends2(class_1, _super);
              function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              __name(class_1, "class_1");
              Object.defineProperty(class_1.prototype, "db", {
                get: /* @__PURE__ */ __name(function() {
                  return db;
                }, "get"),
                enumerable: false,
                configurable: true
              });
              class_1.prototype.table = function() {
                return tableName;
              };
              return class_1;
            }(constructor);
          }
          var inheritedProps = /* @__PURE__ */ new Set();
          for (var proto = constructor.prototype; proto; proto = getProto(proto)) {
            Object.getOwnPropertyNames(proto).forEach(function(propName) {
              return inheritedProps.add(propName);
            });
          }
          var readHook = /* @__PURE__ */ __name(function(obj) {
            if (!obj)
              return obj;
            var res = Object.create(constructor.prototype);
            for (var m in obj)
              if (!inheritedProps.has(m))
                try {
                  res[m] = obj[m];
                } catch (_) {
                }
            return res;
          }, "readHook");
          if (this.schema.readHook) {
            this.hook.reading.unsubscribe(this.schema.readHook);
          }
          this.schema.readHook = readHook;
          this.hook("reading", readHook);
          return constructor;
        };
        Table2.prototype.defineClass = function() {
          function Class(content) {
            extend2(this, content);
          }
          __name(Class, "Class");
          return this.mapToClass(Class);
        };
        Table2.prototype.add = function(obj, key) {
          var _this = this;
          var _a9 = this.schema.primKey, auto = _a9.auto, keyPath = _a9.keyPath;
          var objToAdd = obj;
          if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
          }
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
          }).then(function(lastResult) {
            if (keyPath) {
              try {
                setByKeyPath(obj, keyPath, lastResult);
              } catch (_) {
              }
            }
            return lastResult;
          });
        };
        Table2.prototype.update = function(keyOrObject, modifications) {
          if (typeof keyOrObject === "object" && !isArray6(keyOrObject)) {
            var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
            if (key === void 0)
              return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
            return this.where(":id").equals(key).modify(modifications);
          } else {
            return this.where(":id").equals(keyOrObject).modify(modifications);
          }
        };
        Table2.prototype.put = function(obj, key) {
          var _this = this;
          var _a9 = this.schema.primKey, auto = _a9.auto, keyPath = _a9.keyPath;
          var objToAdd = obj;
          if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
          }
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
          }).then(function(lastResult) {
            if (keyPath) {
              try {
                setByKeyPath(obj, keyPath, lastResult);
              } catch (_) {
              }
            }
            return lastResult;
          });
        };
        Table2.prototype.delete = function(key) {
          var _this = this;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "delete", keys: [key] });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
          });
        };
        Table2.prototype.clear = function() {
          var _this = this;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "deleteRange", range: AnyRange });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
          });
        };
        Table2.prototype.bulkGet = function(keys4) {
          var _this = this;
          return this._trans("readonly", function(trans) {
            return _this.core.getMany({
              keys: keys4,
              trans
            }).then(function(result) {
              return result.map(function(res) {
                return _this.hook.reading.fire(res);
              });
            });
          });
        };
        Table2.prototype.bulkAdd = function(objects, keysOrOptions, options) {
          var _this = this;
          var keys4 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
          options = options || (keys4 ? void 0 : keysOrOptions);
          var wantResults = options ? options.allKeys : void 0;
          return this._trans("readwrite", function(trans) {
            var _a9 = _this.schema.primKey, auto = _a9.auto, keyPath = _a9.keyPath;
            if (keyPath && keys4)
              throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
            if (keys4 && keys4.length !== objects.length)
              throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({ trans, type: "add", keys: keys4, values: objectsToAdd, wantResults }).then(function(_a10) {
              var numFailures = _a10.numFailures, results = _a10.results, lastResult = _a10.lastResult, failures = _a10.failures;
              var result = wantResults ? results : lastResult;
              if (numFailures === 0)
                return result;
              throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
            });
          });
        };
        Table2.prototype.bulkPut = function(objects, keysOrOptions, options) {
          var _this = this;
          var keys4 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
          options = options || (keys4 ? void 0 : keysOrOptions);
          var wantResults = options ? options.allKeys : void 0;
          return this._trans("readwrite", function(trans) {
            var _a9 = _this.schema.primKey, auto = _a9.auto, keyPath = _a9.keyPath;
            if (keyPath && keys4)
              throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
            if (keys4 && keys4.length !== objects.length)
              throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({ trans, type: "put", keys: keys4, values: objectsToPut, wantResults }).then(function(_a10) {
              var numFailures = _a10.numFailures, results = _a10.results, lastResult = _a10.lastResult, failures = _a10.failures;
              var result = wantResults ? results : lastResult;
              if (numFailures === 0)
                return result;
              throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
            });
          });
        };
        Table2.prototype.bulkUpdate = function(keysAndChanges) {
          var _this = this;
          var coreTable = this.core;
          var keys4 = keysAndChanges.map(function(entry) {
            return entry.key;
          });
          var changeSpecs = keysAndChanges.map(function(entry) {
            return entry.changes;
          });
          var offsetMap = [];
          return this._trans("readwrite", function(trans) {
            return coreTable.getMany({ trans, keys: keys4, cache: "clone" }).then(function(objs) {
              var resultKeys = [];
              var resultObjs = [];
              keysAndChanges.forEach(function(_a9, idx) {
                var key = _a9.key, changes = _a9.changes;
                var obj = objs[idx];
                if (obj) {
                  for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {
                    var keyPath = _b[_i];
                    var value = changes[keyPath];
                    if (keyPath === _this.schema.primKey.keyPath) {
                      if (cmp2(value, key) !== 0) {
                        throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                      }
                    } else {
                      setByKeyPath(obj, keyPath, value);
                    }
                  }
                  offsetMap.push(idx);
                  resultKeys.push(key);
                  resultObjs.push(obj);
                }
              });
              var numEntries = resultKeys.length;
              return coreTable.mutate({
                trans,
                type: "put",
                keys: resultKeys,
                values: resultObjs,
                updates: {
                  keys: keys4,
                  changeSpecs
                }
              }).then(function(_a9) {
                var numFailures = _a9.numFailures, failures = _a9.failures;
                if (numFailures === 0)
                  return numEntries;
                for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {
                  var offset = _b[_i];
                  var mappedOffset = offsetMap[Number(offset)];
                  if (mappedOffset != null) {
                    var failure = failures[offset];
                    delete failures[offset];
                    failures[mappedOffset] = failure;
                  }
                }
                throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
              });
            });
          });
        };
        Table2.prototype.bulkDelete = function(keys4) {
          var _this = this;
          var numKeys = keys4.length;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "delete", keys: keys4 });
          }).then(function(_a9) {
            var numFailures = _a9.numFailures, lastResult = _a9.lastResult, failures = _a9.failures;
            if (numFailures === 0)
              return lastResult;
            throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
          });
        };
        return Table2;
      }();
      function Events2(ctx) {
        var evs = {};
        var rv = /* @__PURE__ */ __name(function(eventName, subscriber) {
          if (subscriber) {
            var i2 = arguments.length, args2 = new Array(i2 - 1);
            while (--i2)
              args2[i2 - 1] = arguments[i2];
            evs[eventName].subscribe.apply(null, args2);
            return ctx;
          } else if (typeof eventName === "string") {
            return evs[eventName];
          }
        }, "rv");
        rv.addEventType = add;
        for (var i = 1, l = arguments.length; i < l; ++i) {
          add(arguments[i]);
        }
        return rv;
        function add(eventName, chainFunction, defaultFunction) {
          if (typeof eventName === "object")
            return addConfiguredEvents(eventName);
          if (!chainFunction)
            chainFunction = reverseStoppableEventChain;
          if (!defaultFunction)
            defaultFunction = nop;
          var context2 = {
            subscribers: [],
            fire: defaultFunction,
            subscribe: /* @__PURE__ */ __name(function(cb) {
              if (context2.subscribers.indexOf(cb) === -1) {
                context2.subscribers.push(cb);
                context2.fire = chainFunction(context2.fire, cb);
              }
            }, "subscribe"),
            unsubscribe: /* @__PURE__ */ __name(function(cb) {
              context2.subscribers = context2.subscribers.filter(function(fn) {
                return fn !== cb;
              });
              context2.fire = context2.subscribers.reduce(chainFunction, defaultFunction);
            }, "unsubscribe")
          };
          evs[eventName] = rv[eventName] = context2;
          return context2;
        }
        __name(add, "add");
        function addConfiguredEvents(cfg) {
          keys3(cfg).forEach(function(eventName) {
            var args2 = cfg[eventName];
            if (isArray6(args2)) {
              add(eventName, cfg[eventName][0], cfg[eventName][1]);
            } else if (args2 === "asap") {
              var context2 = add(eventName, mirror, /* @__PURE__ */ __name(function fire() {
                var i2 = arguments.length, args3 = new Array(i2);
                while (i2--)
                  args3[i2] = arguments[i2];
                context2.subscribers.forEach(function(fn) {
                  asap$1(/* @__PURE__ */ __name(function fireEvent() {
                    fn.apply(null, args3);
                  }, "fireEvent"));
                });
              }, "fire"));
            } else
              throw new exceptions.InvalidArgument("Invalid event config");
          });
        }
        __name(addConfiguredEvents, "addConfiguredEvents");
      }
      __name(Events2, "Events");
      function makeClassConstructor(prototype3, constructor) {
        derive(constructor).from({ prototype: prototype3 });
        return constructor;
      }
      __name(makeClassConstructor, "makeClassConstructor");
      function createTableConstructor(db) {
        return makeClassConstructor(Table.prototype, /* @__PURE__ */ __name(function Table2(name, tableSchema, trans) {
          this.db = db;
          this._tx = trans;
          this.name = name;
          this.schema = tableSchema;
          this.hook = db._allTables[name] ? db._allTables[name].hook : Events2(null, {
            "creating": [hookCreatingChain, nop],
            "reading": [pureFunctionChain, mirror],
            "updating": [hookUpdatingChain, nop],
            "deleting": [hookDeletingChain, nop]
          });
        }, "Table"));
      }
      __name(createTableConstructor, "createTableConstructor");
      function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
      }
      __name(isPlainKeyRange, "isPlainKeyRange");
      function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
      }
      __name(addFilter, "addFilter");
      function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? function() {
          return combine(curr(), factory());
        } : factory;
        ctx.justLimit = isLimitFilter && !curr;
      }
      __name(addReplayFilter, "addReplayFilter");
      function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
      }
      __name(addMatchFilter, "addMatchFilter");
      function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey)
          return coreSchema.primaryKey;
        var index = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index)
          throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index;
      }
      __name(getIndexOrStore, "getIndexOrStore");
      function openCursor(ctx, coreTable, trans) {
        var index = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
          trans,
          values: !ctx.keysOnly,
          reverse: ctx.dir === "prev",
          unique: !!ctx.unique,
          query: {
            index,
            range: ctx.range
          }
        });
      }
      __name(openCursor, "openCursor");
      function iter(ctx, fn, coreTrans, coreTable) {
        var filter2 = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
          return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter2), fn, !ctx.keysOnly && ctx.valueMapper);
        } else {
          var set_1 = {};
          var union = /* @__PURE__ */ __name(function(item, cursor, advance) {
            if (!filter2 || filter2(cursor, advance, function(result) {
              return cursor.stop(result);
            }, function(err) {
              return cursor.fail(err);
            })) {
              var primaryKey = cursor.primaryKey;
              var key = "" + primaryKey;
              if (key === "[object ArrayBuffer]")
                key = "" + new Uint8Array(primaryKey);
              if (!hasOwn(set_1, key)) {
                set_1[key] = true;
                fn(item, cursor, advance);
              }
            }
          }, "union");
          return Promise.all([
            ctx.or._iterate(union, coreTrans),
            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
          ]);
        }
      }
      __name(iter, "iter");
      function iterate(cursorPromise, filter2, fn, valueMapper) {
        var mappedFn = valueMapper ? function(x, c, a) {
          return fn(valueMapper(x), c, a);
        } : fn;
        var wrappedFn = wrap(mappedFn);
        return cursorPromise.then(function(cursor) {
          if (cursor) {
            return cursor.start(function() {
              var c = /* @__PURE__ */ __name(function() {
                return cursor.continue();
              }, "c");
              if (!filter2 || filter2(cursor, function(advancer) {
                return c = advancer;
              }, function(val) {
                cursor.stop(val);
                c = nop;
              }, function(e) {
                cursor.fail(e);
                c = nop;
              }))
                wrappedFn(cursor.value, cursor, function(advancer) {
                  return c = advancer;
                });
              c();
            });
          }
        });
      }
      __name(iterate, "iterate");
      var PropModSymbol2 = Symbol();
      var PropModification2 = function() {
        function PropModification3(spec) {
          Object.assign(this, spec);
        }
        __name(PropModification3, "PropModification");
        PropModification3.prototype.execute = function(value) {
          var _a9;
          var prefixToReplace = (_a9 = this.replacePrefix) === null || _a9 === void 0 ? void 0 : _a9[0];
          if (prefixToReplace && typeof value === "string" && value.startsWith(prefixToReplace)) {
            return this.replacePrefix[1] + value.substring(prefixToReplace.length);
          }
          return value;
        };
        return PropModification3;
      }();
      var Collection = function() {
        function Collection2() {
        }
        __name(Collection2, "Collection");
        Collection2.prototype._read = function(fn, cb) {
          var ctx = this._ctx;
          return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
        };
        Collection2.prototype._write = function(fn) {
          var ctx = this._ctx;
          return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
        };
        Collection2.prototype._addAlgorithm = function(fn) {
          var ctx = this._ctx;
          ctx.algorithm = combine(ctx.algorithm, fn);
        };
        Collection2.prototype._iterate = function(fn, coreTrans) {
          return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        };
        Collection2.prototype.clone = function(props2) {
          var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
          if (props2)
            extend2(ctx, props2);
          rv._ctx = ctx;
          return rv;
        };
        Collection2.prototype.raw = function() {
          this._ctx.valueMapper = null;
          return this;
        };
        Collection2.prototype.each = function(fn) {
          var ctx = this._ctx;
          return this._read(function(trans) {
            return iter(ctx, fn, trans, ctx.table.core);
          });
        };
        Collection2.prototype.count = function(cb) {
          var _this = this;
          return this._read(function(trans) {
            var ctx = _this._ctx;
            var coreTable = ctx.table.core;
            if (isPlainKeyRange(ctx, true)) {
              return coreTable.count({
                trans,
                query: {
                  index: getIndexOrStore(ctx, coreTable.schema),
                  range: ctx.range
                }
              }).then(function(count3) {
                return Math.min(count3, ctx.limit);
              });
            } else {
              var count2 = 0;
              return iter(ctx, function() {
                ++count2;
                return false;
              }, trans, coreTable).then(function() {
                return count2;
              });
            }
          }).then(cb);
        };
        Collection2.prototype.sortBy = function(keyPath, cb) {
          var parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
          function getval(obj, i) {
            if (i)
              return getval(obj[parts[i]], i - 1);
            return obj[lastPart];
          }
          __name(getval, "getval");
          var order = this._ctx.dir === "next" ? 1 : -1;
          function sorter(a, b) {
            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
            return aVal < bVal ? -order : aVal > bVal ? order : 0;
          }
          __name(sorter, "sorter");
          return this.toArray(function(a) {
            return a.sort(sorter);
          }).then(cb);
        };
        Collection2.prototype.toArray = function(cb) {
          var _this = this;
          return this._read(function(trans) {
            var ctx = _this._ctx;
            if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
              var valueMapper_1 = ctx.valueMapper;
              var index = getIndexOrStore(ctx, ctx.table.core.schema);
              return ctx.table.core.query({
                trans,
                limit: ctx.limit,
                values: true,
                query: {
                  index,
                  range: ctx.range
                }
              }).then(function(_a9) {
                var result = _a9.result;
                return valueMapper_1 ? result.map(valueMapper_1) : result;
              });
            } else {
              var a_1 = [];
              return iter(ctx, function(item) {
                return a_1.push(item);
              }, trans, ctx.table.core).then(function() {
                return a_1;
              });
            }
          }, cb);
        };
        Collection2.prototype.offset = function(offset) {
          var ctx = this._ctx;
          if (offset <= 0)
            return this;
          ctx.offset += offset;
          if (isPlainKeyRange(ctx)) {
            addReplayFilter(ctx, function() {
              var offsetLeft = offset;
              return function(cursor, advance) {
                if (offsetLeft === 0)
                  return true;
                if (offsetLeft === 1) {
                  --offsetLeft;
                  return false;
                }
                advance(function() {
                  cursor.advance(offsetLeft);
                  offsetLeft = 0;
                });
                return false;
              };
            });
          } else {
            addReplayFilter(ctx, function() {
              var offsetLeft = offset;
              return function() {
                return --offsetLeft < 0;
              };
            });
          }
          return this;
        };
        Collection2.prototype.limit = function(numRows) {
          this._ctx.limit = Math.min(this._ctx.limit, numRows);
          addReplayFilter(this._ctx, function() {
            var rowsLeft = numRows;
            return function(cursor, advance, resolve) {
              if (--rowsLeft <= 0)
                advance(resolve);
              return rowsLeft >= 0;
            };
          }, true);
          return this;
        };
        Collection2.prototype.until = function(filterFunction, bIncludeStopEntry) {
          addFilter(this._ctx, function(cursor, advance, resolve) {
            if (filterFunction(cursor.value)) {
              advance(resolve);
              return bIncludeStopEntry;
            } else {
              return true;
            }
          });
          return this;
        };
        Collection2.prototype.first = function(cb) {
          return this.limit(1).toArray(function(a) {
            return a[0];
          }).then(cb);
        };
        Collection2.prototype.last = function(cb) {
          return this.reverse().first(cb);
        };
        Collection2.prototype.filter = function(filterFunction) {
          addFilter(this._ctx, function(cursor) {
            return filterFunction(cursor.value);
          });
          addMatchFilter(this._ctx, filterFunction);
          return this;
        };
        Collection2.prototype.and = function(filter2) {
          return this.filter(filter2);
        };
        Collection2.prototype.or = function(indexName) {
          return new this.db.WhereClause(this._ctx.table, indexName, this);
        };
        Collection2.prototype.reverse = function() {
          this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
          if (this._ondirectionchange)
            this._ondirectionchange(this._ctx.dir);
          return this;
        };
        Collection2.prototype.desc = function() {
          return this.reverse();
        };
        Collection2.prototype.eachKey = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          return this.each(function(val, cursor) {
            cb(cursor.key, cursor);
          });
        };
        Collection2.prototype.eachUniqueKey = function(cb) {
          this._ctx.unique = "unique";
          return this.eachKey(cb);
        };
        Collection2.prototype.eachPrimaryKey = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          return this.each(function(val, cursor) {
            cb(cursor.primaryKey, cursor);
          });
        };
        Collection2.prototype.keys = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          var a = [];
          return this.each(function(item, cursor) {
            a.push(cursor.key);
          }).then(function() {
            return a;
          }).then(cb);
        };
        Collection2.prototype.primaryKeys = function(cb) {
          var ctx = this._ctx;
          if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
            return this._read(function(trans) {
              var index = getIndexOrStore(ctx, ctx.table.core.schema);
              return ctx.table.core.query({
                trans,
                values: false,
                limit: ctx.limit,
                query: {
                  index,
                  range: ctx.range
                }
              });
            }).then(function(_a9) {
              var result = _a9.result;
              return result;
            }).then(cb);
          }
          ctx.keysOnly = !ctx.isMatch;
          var a = [];
          return this.each(function(item, cursor) {
            a.push(cursor.primaryKey);
          }).then(function() {
            return a;
          }).then(cb);
        };
        Collection2.prototype.uniqueKeys = function(cb) {
          this._ctx.unique = "unique";
          return this.keys(cb);
        };
        Collection2.prototype.firstKey = function(cb) {
          return this.limit(1).keys(function(a) {
            return a[0];
          }).then(cb);
        };
        Collection2.prototype.lastKey = function(cb) {
          return this.reverse().firstKey(cb);
        };
        Collection2.prototype.distinct = function() {
          var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
          if (!idx || !idx.multi)
            return this;
          var set = {};
          addFilter(this._ctx, function(cursor) {
            var strKey = cursor.primaryKey.toString();
            var found = hasOwn(set, strKey);
            set[strKey] = true;
            return !found;
          });
          return this;
        };
        Collection2.prototype.modify = function(changes) {
          var _this = this;
          var ctx = this._ctx;
          return this._write(function(trans) {
            var modifyer;
            if (typeof changes === "function") {
              modifyer = changes;
            } else {
              var keyPaths = keys3(changes);
              var numKeys = keyPaths.length;
              modifyer = /* @__PURE__ */ __name(function(item) {
                var anythingModified = false;
                for (var i = 0; i < numKeys; ++i) {
                  var keyPath = keyPaths[i];
                  var val = changes[keyPath];
                  var origVal = getByKeyPath(item, keyPath);
                  if (val instanceof PropModification2) {
                    setByKeyPath(item, keyPath, val.execute(origVal));
                    anythingModified = true;
                  } else if (origVal !== val) {
                    setByKeyPath(item, keyPath, val);
                    anythingModified = true;
                  }
                }
                return anythingModified;
              }, "modifyer");
            }
            var coreTable = ctx.table.core;
            var _a9 = coreTable.schema.primaryKey, outbound = _a9.outbound, extractKey = _a9.extractKey;
            var limit = _this.db._options.modifyChunkSize || 200;
            var totalFailures = [];
            var successCount = 0;
            var failedKeys = [];
            var applyMutateResult = /* @__PURE__ */ __name(function(expectedCount, res) {
              var failures = res.failures, numFailures = res.numFailures;
              successCount += expectedCount - numFailures;
              for (var _i = 0, _a10 = keys3(failures); _i < _a10.length; _i++) {
                var pos = _a10[_i];
                totalFailures.push(failures[pos]);
              }
            }, "applyMutateResult");
            return _this.clone().primaryKeys().then(function(keys4) {
              var nextChunk = /* @__PURE__ */ __name(function(offset) {
                var count2 = Math.min(limit, keys4.length - offset);
                return coreTable.getMany({
                  trans,
                  keys: keys4.slice(offset, offset + count2),
                  cache: "immutable"
                }).then(function(values) {
                  var addValues = [];
                  var putValues = [];
                  var putKeys = outbound ? [] : null;
                  var deleteKeys = [];
                  for (var i = 0; i < count2; ++i) {
                    var origValue = values[i];
                    var ctx_1 = {
                      value: deepClone(origValue),
                      primKey: keys4[offset + i]
                    };
                    if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                      if (ctx_1.value == null) {
                        deleteKeys.push(keys4[offset + i]);
                      } else if (!outbound && cmp2(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                        deleteKeys.push(keys4[offset + i]);
                        addValues.push(ctx_1.value);
                      } else {
                        putValues.push(ctx_1.value);
                        if (outbound)
                          putKeys.push(keys4[offset + i]);
                      }
                    }
                  }
                  var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
                    index: ctx.index,
                    range: ctx.range
                  };
                  return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then(function(res) {
                    for (var pos in res.failures) {
                      deleteKeys.splice(parseInt(pos), 1);
                    }
                    applyMutateResult(addValues.length, res);
                  })).then(function() {
                    return (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
                      trans,
                      type: "put",
                      keys: putKeys,
                      values: putValues,
                      criteria,
                      changeSpec: typeof changes !== "function" && changes
                    }).then(function(res) {
                      return applyMutateResult(putValues.length, res);
                    });
                  }).then(function() {
                    return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
                      trans,
                      type: "delete",
                      keys: deleteKeys,
                      criteria
                    }).then(function(res) {
                      return applyMutateResult(deleteKeys.length, res);
                    });
                  }).then(function() {
                    return keys4.length > offset + count2 && nextChunk(offset + limit);
                  });
                });
              }, "nextChunk");
              return nextChunk(0).then(function() {
                if (totalFailures.length > 0)
                  throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                return keys4.length;
              });
            });
          });
        };
        Collection2.prototype.delete = function() {
          var ctx = this._ctx, range = ctx.range;
          if (isPlainKeyRange(ctx) && (ctx.isPrimKey || range.type === 3)) {
            return this._write(function(trans) {
              var primaryKey = ctx.table.core.schema.primaryKey;
              var coreRange = range;
              return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(function(count2) {
                return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(function(_a9) {
                  var failures = _a9.failures;
                  _a9.lastResult;
                  _a9.results;
                  var numFailures = _a9.numFailures;
                  if (numFailures)
                    throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                      return failures[pos];
                    }), count2 - numFailures);
                  return count2 - numFailures;
                });
              });
            });
          }
          return this.modify(deleteCallback);
        };
        return Collection2;
      }();
      var deleteCallback = /* @__PURE__ */ __name(function(value, ctx) {
        return ctx.value = null;
      }, "deleteCallback");
      function createCollectionConstructor(db) {
        return makeClassConstructor(Collection.prototype, /* @__PURE__ */ __name(function Collection2(whereClause, keyRangeGenerator) {
          this.db = db;
          var keyRange = AnyRange, error = null;
          if (keyRangeGenerator)
            try {
              keyRange = keyRangeGenerator();
            } catch (ex) {
              error = ex;
            }
          var whereCtx = whereClause._ctx;
          var table = whereCtx.table;
          var readingHook = table.hook.reading.fire;
          this._ctx = {
            table,
            index: whereCtx.index,
            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
            range: keyRange,
            keysOnly: false,
            dir: "next",
            unique: "",
            algorithm: null,
            filter: null,
            replayFilter: null,
            justLimit: true,
            isMatch: null,
            offset: 0,
            limit: Infinity,
            error,
            or: whereCtx.or,
            valueMapper: readingHook !== mirror ? readingHook : null
          };
        }, "Collection"));
      }
      __name(createCollectionConstructor, "createCollectionConstructor");
      function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
      }
      __name(simpleCompare, "simpleCompare");
      function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
      }
      __name(simpleCompareReverse, "simpleCompareReverse");
      function fail(collectionOrWhereClause, err, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
        collection._ctx.error = T ? new T(err) : new TypeError(err);
        return collection;
      }
      __name(fail, "fail");
      function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, function() {
          return rangeEqual("");
        }).limit(0);
      }
      __name(emptyCollection, "emptyCollection");
      function upperFactory(dir) {
        return dir === "next" ? function(s) {
          return s.toUpperCase();
        } : function(s) {
          return s.toLowerCase();
        };
      }
      __name(upperFactory, "upperFactory");
      function lowerFactory(dir) {
        return dir === "next" ? function(s) {
          return s.toLowerCase();
        } : function(s) {
          return s.toUpperCase();
        };
      }
      __name(lowerFactory, "lowerFactory");
      function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp3, dir) {
        var length3 = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for (var i = 0; i < length3; ++i) {
          var lwrKeyChar = lowerKey[i];
          if (lwrKeyChar !== lowerNeedle[i]) {
            if (cmp3(key[i], upperNeedle[i]) < 0)
              return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
            if (cmp3(key[i], lowerNeedle[i]) < 0)
              return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
            if (llp >= 0)
              return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
            return null;
          }
          if (cmp3(key[i], lwrKeyChar) < 0)
            llp = i;
        }
        if (length3 < lowerNeedle.length && dir === "next")
          return key + upperNeedle.substr(key.length);
        if (length3 < key.length && dir === "prev")
          return key.substr(0, upperNeedle.length);
        return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
      }
      __name(nextCasing, "nextCasing");
      function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(function(s) {
          return typeof s === "string";
        })) {
          return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
          upper = upperFactory(dir);
          lower = lowerFactory(dir);
          compare = dir === "next" ? simpleCompare : simpleCompareReverse;
          var needleBounds = needles.map(function(needle) {
            return { lower: lower(needle), upper: upper(needle) };
          }).sort(function(a, b) {
            return compare(a.lower, b.lower);
          });
          upperNeedles = needleBounds.map(function(nb) {
            return nb.upper;
          });
          lowerNeedles = needleBounds.map(function(nb) {
            return nb.lower;
          });
          direction = dir;
          nextKeySuffix = dir === "next" ? "" : suffix;
        }
        __name(initDirection, "initDirection");
        initDirection("next");
        var c = new whereClause.Collection(whereClause, function() {
          return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
        });
        c._ondirectionchange = function(direction2) {
          initDirection(direction2);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function(cursor, advance, resolve) {
          var key = cursor.key;
          if (typeof key !== "string")
            return false;
          var lowerKey = lower(key);
          if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
            return true;
          } else {
            var lowestPossibleCasing = null;
            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
              var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
              if (casing === null && lowestPossibleCasing === null)
                firstPossibleNeedle = i + 1;
              else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                lowestPossibleCasing = casing;
              }
            }
            if (lowestPossibleCasing !== null) {
              advance(function() {
                cursor.continue(lowestPossibleCasing + nextKeySuffix);
              });
            } else {
              advance(resolve);
            }
            return false;
          }
        });
        return c;
      }
      __name(addIgnoreCaseAlgorithm, "addIgnoreCaseAlgorithm");
      function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
          type: 2,
          lower,
          upper,
          lowerOpen,
          upperOpen
        };
      }
      __name(createRange, "createRange");
      function rangeEqual(value) {
        return {
          type: 1,
          lower: value,
          upper: value
        };
      }
      __name(rangeEqual, "rangeEqual");
      var WhereClause = function() {
        function WhereClause2() {
        }
        __name(WhereClause2, "WhereClause");
        Object.defineProperty(WhereClause2.prototype, "Collection", {
          get: /* @__PURE__ */ __name(function() {
            return this._ctx.table.db.Collection;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        WhereClause2.prototype.between = function(lower, upper, includeLower, includeUpper) {
          includeLower = includeLower !== false;
          includeUpper = includeUpper === true;
          try {
            if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
              return emptyCollection(this);
            return new this.Collection(this, function() {
              return createRange(lower, upper, !includeLower, !includeUpper);
            });
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
        };
        WhereClause2.prototype.equals = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return rangeEqual(value);
          });
        };
        WhereClause2.prototype.above = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(value, void 0, true);
          });
        };
        WhereClause2.prototype.aboveOrEqual = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(value, void 0, false);
          });
        };
        WhereClause2.prototype.below = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(void 0, value, false, true);
          });
        };
        WhereClause2.prototype.belowOrEqual = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(void 0, value);
          });
        };
        WhereClause2.prototype.startsWith = function(str) {
          if (typeof str !== "string")
            return fail(this, STRING_EXPECTED);
          return this.between(str, str + maxString, true, true);
        };
        WhereClause2.prototype.startsWithIgnoreCase = function(str) {
          if (str === "")
            return this.startsWith(str);
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return x.indexOf(a[0]) === 0;
          }, [str], maxString);
        };
        WhereClause2.prototype.equalsIgnoreCase = function(str) {
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return x === a[0];
          }, [str], "");
        };
        WhereClause2.prototype.anyOfIgnoreCase = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set.length === 0)
            return emptyCollection(this);
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return a.indexOf(x) !== -1;
          }, set, "");
        };
        WhereClause2.prototype.startsWithAnyOfIgnoreCase = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set.length === 0)
            return emptyCollection(this);
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return a.some(function(n) {
              return x.indexOf(n) === 0;
            });
          }, set, maxString);
        };
        WhereClause2.prototype.anyOf = function() {
          var _this = this;
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          var compare = this._cmp;
          try {
            set.sort(compare);
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          if (set.length === 0)
            return emptyCollection(this);
          var c = new this.Collection(this, function() {
            return createRange(set[0], set[set.length - 1]);
          });
          c._ondirectionchange = function(direction) {
            compare = direction === "next" ? _this._ascending : _this._descending;
            set.sort(compare);
          };
          var i = 0;
          c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            while (compare(key, set[i]) > 0) {
              ++i;
              if (i === set.length) {
                advance(resolve);
                return false;
              }
            }
            if (compare(key, set[i]) === 0) {
              return true;
            } else {
              advance(function() {
                cursor.continue(set[i]);
              });
              return false;
            }
          });
          return c;
        };
        WhereClause2.prototype.notEqual = function(value) {
          return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        };
        WhereClause2.prototype.noneOf = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set.length === 0)
            return new this.Collection(this);
          try {
            set.sort(this._ascending);
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          var ranges = set.reduce(function(res, val) {
            return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
          }, null);
          ranges.push([set[set.length - 1], this.db._maxKey]);
          return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
        };
        WhereClause2.prototype.inAnyRange = function(ranges, options) {
          var _this = this;
          var cmp3 = this._cmp, ascending = this._ascending, descending = this._descending, min2 = this._min, max2 = this._max;
          if (ranges.length === 0)
            return emptyCollection(this);
          if (!ranges.every(function(range) {
            return range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0;
          })) {
            return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
          }
          var includeLowers = !options || options.includeLowers !== false;
          var includeUppers = options && options.includeUppers === true;
          function addRange2(ranges2, newRange) {
            var i = 0, l = ranges2.length;
            for (; i < l; ++i) {
              var range = ranges2[i];
              if (cmp3(newRange[0], range[1]) < 0 && cmp3(newRange[1], range[0]) > 0) {
                range[0] = min2(range[0], newRange[0]);
                range[1] = max2(range[1], newRange[1]);
                break;
              }
            }
            if (i === l)
              ranges2.push(newRange);
            return ranges2;
          }
          __name(addRange2, "addRange");
          var sortDirection = ascending;
          function rangeSorter(a, b) {
            return sortDirection(a[0], b[0]);
          }
          __name(rangeSorter, "rangeSorter");
          var set;
          try {
            set = ranges.reduce(addRange2, []);
            set.sort(rangeSorter);
          } catch (ex) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          var rangePos = 0;
          var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
            return ascending(key, set[rangePos][1]) > 0;
          } : function(key) {
            return ascending(key, set[rangePos][1]) >= 0;
          };
          var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
            return descending(key, set[rangePos][0]) > 0;
          } : function(key) {
            return descending(key, set[rangePos][0]) >= 0;
          };
          function keyWithinCurrentRange(key) {
            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
          }
          __name(keyWithinCurrentRange, "keyWithinCurrentRange");
          var checkKey = keyIsBeyondCurrentEntry;
          var c = new this.Collection(this, function() {
            return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
          });
          c._ondirectionchange = function(direction) {
            if (direction === "next") {
              checkKey = keyIsBeyondCurrentEntry;
              sortDirection = ascending;
            } else {
              checkKey = keyIsBeforeCurrentEntry;
              sortDirection = descending;
            }
            set.sort(rangeSorter);
          };
          c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            while (checkKey(key)) {
              ++rangePos;
              if (rangePos === set.length) {
                advance(resolve);
                return false;
              }
            }
            if (keyWithinCurrentRange(key)) {
              return true;
            } else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
              return false;
            } else {
              advance(function() {
                if (sortDirection === ascending)
                  cursor.continue(set[rangePos][0]);
                else
                  cursor.continue(set[rangePos][1]);
              });
              return false;
            }
          });
          return c;
        };
        WhereClause2.prototype.startsWithAnyOf = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (!set.every(function(s) {
            return typeof s === "string";
          })) {
            return fail(this, "startsWithAnyOf() only works with strings");
          }
          if (set.length === 0)
            return emptyCollection(this);
          return this.inAnyRange(set.map(function(str) {
            return [str, str + maxString];
          }));
        };
        return WhereClause2;
      }();
      function createWhereClauseConstructor(db) {
        return makeClassConstructor(WhereClause.prototype, /* @__PURE__ */ __name(function WhereClause2(table, index, orCollection) {
          this.db = db;
          this._ctx = {
            table,
            index: index === ":id" ? null : index,
            or: orCollection
          };
          this._cmp = this._ascending = cmp2;
          this._descending = function(a, b) {
            return cmp2(b, a);
          };
          this._max = function(a, b) {
            return cmp2(a, b) > 0 ? a : b;
          };
          this._min = function(a, b) {
            return cmp2(a, b) < 0 ? a : b;
          };
          this._IDBKeyRange = db._deps.IDBKeyRange;
          if (!this._IDBKeyRange)
            throw new exceptions.MissingAPI();
        }, "WhereClause"));
      }
      __name(createWhereClauseConstructor, "createWhereClauseConstructor");
      function eventRejectHandler(reject) {
        return wrap(function(event) {
          preventDefault(event);
          reject(event.target.error);
          return false;
        });
      }
      __name(eventRejectHandler, "eventRejectHandler");
      function preventDefault(event) {
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.preventDefault)
          event.preventDefault();
      }
      __name(preventDefault, "preventDefault");
      var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
      var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
      var globalEvents = Events2(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
      var Transaction2 = function() {
        function Transaction3() {
        }
        __name(Transaction3, "Transaction");
        Transaction3.prototype._lock = function() {
          assert(!PSD.global);
          ++this._reculock;
          if (this._reculock === 1 && !PSD.global)
            PSD.lockOwnerFor = this;
          return this;
        };
        Transaction3.prototype._unlock = function() {
          assert(!PSD.global);
          if (--this._reculock === 0) {
            if (!PSD.global)
              PSD.lockOwnerFor = null;
            while (this._blockedFuncs.length > 0 && !this._locked()) {
              var fnAndPSD = this._blockedFuncs.shift();
              try {
                usePSD(fnAndPSD[1], fnAndPSD[0]);
              } catch (e) {
              }
            }
          }
          return this;
        };
        Transaction3.prototype._locked = function() {
          return this._reculock && PSD.lockOwnerFor !== this;
        };
        Transaction3.prototype.create = function(idbtrans) {
          var _this = this;
          if (!this.mode)
            return this;
          var idbdb = this.db.idbdb;
          var dbOpenError = this.db._state.dbOpenError;
          assert(!this.idbtrans);
          if (!idbtrans && !idbdb) {
            switch (dbOpenError && dbOpenError.name) {
              case "DatabaseClosedError":
                throw new exceptions.DatabaseClosed(dbOpenError);
              case "MissingAPIError":
                throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
              default:
                throw new exceptions.OpenFailed(dbOpenError);
            }
          }
          if (!this.active)
            throw new exceptions.TransactionInactive();
          assert(this._completion._state === null);
          idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
          idbtrans.onerror = wrap(function(ev) {
            preventDefault(ev);
            _this._reject(idbtrans.error);
          });
          idbtrans.onabort = wrap(function(ev) {
            preventDefault(ev);
            _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
            _this.active = false;
            _this.on("abort").fire(ev);
          });
          idbtrans.oncomplete = wrap(function() {
            _this.active = false;
            _this._resolve();
            if ("mutatedParts" in idbtrans) {
              globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
            }
          });
          return this;
        };
        Transaction3.prototype._promise = function(mode, fn, bWriteLock) {
          var _this = this;
          if (mode === "readwrite" && this.mode !== "readwrite")
            return rejection(new exceptions.ReadOnly("Transaction is readonly"));
          if (!this.active)
            return rejection(new exceptions.TransactionInactive());
          if (this._locked()) {
            return new DexiePromise(function(resolve, reject) {
              _this._blockedFuncs.push([function() {
                _this._promise(mode, fn, bWriteLock).then(resolve, reject);
              }, PSD]);
            });
          } else if (bWriteLock) {
            return newScope(function() {
              var p2 = new DexiePromise(function(resolve, reject) {
                _this._lock();
                var rv = fn(resolve, reject, _this);
                if (rv && rv.then)
                  rv.then(resolve, reject);
              });
              p2.finally(function() {
                return _this._unlock();
              });
              p2._lib = true;
              return p2;
            });
          } else {
            var p = new DexiePromise(function(resolve, reject) {
              var rv = fn(resolve, reject, _this);
              if (rv && rv.then)
                rv.then(resolve, reject);
            });
            p._lib = true;
            return p;
          }
        };
        Transaction3.prototype._root = function() {
          return this.parent ? this.parent._root() : this;
        };
        Transaction3.prototype.waitFor = function(promiseLike) {
          var root2 = this._root();
          var promise = DexiePromise.resolve(promiseLike);
          if (root2._waitingFor) {
            root2._waitingFor = root2._waitingFor.then(function() {
              return promise;
            });
          } else {
            root2._waitingFor = promise;
            root2._waitingQueue = [];
            var store = root2.idbtrans.objectStore(root2.storeNames[0]);
            (/* @__PURE__ */ __name(function spin() {
              ++root2._spinCount;
              while (root2._waitingQueue.length)
                root2._waitingQueue.shift()();
              if (root2._waitingFor)
                store.get(-Infinity).onsuccess = spin;
            }, "spin"))();
          }
          var currentWaitPromise = root2._waitingFor;
          return new DexiePromise(function(resolve, reject) {
            promise.then(function(res) {
              return root2._waitingQueue.push(wrap(resolve.bind(null, res)));
            }, function(err) {
              return root2._waitingQueue.push(wrap(reject.bind(null, err)));
            }).finally(function() {
              if (root2._waitingFor === currentWaitPromise) {
                root2._waitingFor = null;
              }
            });
          });
        };
        Transaction3.prototype.abort = function() {
          if (this.active) {
            this.active = false;
            if (this.idbtrans)
              this.idbtrans.abort();
            this._reject(new exceptions.Abort());
          }
        };
        Transaction3.prototype.table = function(tableName) {
          var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
          if (hasOwn(memoizedTables, tableName))
            return memoizedTables[tableName];
          var tableSchema = this.schema[tableName];
          if (!tableSchema) {
            throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
          }
          var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
          transactionBoundTable.core = this.db.core.table(tableName);
          memoizedTables[tableName] = transactionBoundTable;
          return transactionBoundTable;
        };
        return Transaction3;
      }();
      function createTransactionConstructor(db) {
        return makeClassConstructor(Transaction2.prototype, /* @__PURE__ */ __name(function Transaction3(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
          var _this = this;
          this.db = db;
          this.mode = mode;
          this.storeNames = storeNames;
          this.schema = dbschema;
          this.chromeTransactionDurability = chromeTransactionDurability;
          this.idbtrans = null;
          this.on = Events2(this, "complete", "error", "abort");
          this.parent = parent || null;
          this.active = true;
          this._reculock = 0;
          this._blockedFuncs = [];
          this._resolve = null;
          this._reject = null;
          this._waitingFor = null;
          this._waitingQueue = null;
          this._spinCount = 0;
          this._completion = new DexiePromise(function(resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
          });
          this._completion.then(function() {
            _this.active = false;
            _this.on.complete.fire();
          }, function(e) {
            var wasActive = _this.active;
            _this.active = false;
            _this.on.error.fire(e);
            _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
            return rejection(e);
          });
        }, "Transaction"));
      }
      __name(createTransactionConstructor, "createTransactionConstructor");
      function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
        return {
          name,
          keyPath,
          unique,
          multi,
          auto,
          compound,
          src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
        };
      }
      __name(createIndexSpec, "createIndexSpec");
      function nameFromKeyPath(keyPath) {
        return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
      }
      __name(nameFromKeyPath, "nameFromKeyPath");
      function createTableSchema(name, primKey, indexes) {
        return {
          name,
          primKey,
          indexes,
          mappedClass: null,
          idxByName: arrayToObject2(indexes, function(index) {
            return [index.name, index];
          })
        };
      }
      __name(createTableSchema, "createTableSchema");
      function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
      }
      __name(safariMultiStoreFix, "safariMultiStoreFix");
      var getMaxKey = /* @__PURE__ */ __name(function(IdbKeyRange) {
        try {
          IdbKeyRange.only([[]]);
          getMaxKey = /* @__PURE__ */ __name(function() {
            return [[]];
          }, "getMaxKey");
          return [[]];
        } catch (e) {
          getMaxKey = /* @__PURE__ */ __name(function() {
            return maxString;
          }, "getMaxKey");
          return maxString;
        }
      }, "getMaxKey");
      function getKeyExtractor(keyPath) {
        if (keyPath == null) {
          return function() {
            return void 0;
          };
        } else if (typeof keyPath === "string") {
          return getSinglePathKeyExtractor(keyPath);
        } else {
          return function(obj) {
            return getByKeyPath(obj, keyPath);
          };
        }
      }
      __name(getKeyExtractor, "getKeyExtractor");
      function getSinglePathKeyExtractor(keyPath) {
        var split = keyPath.split(".");
        if (split.length === 1) {
          return function(obj) {
            return obj[keyPath];
          };
        } else {
          return function(obj) {
            return getByKeyPath(obj, keyPath);
          };
        }
      }
      __name(getSinglePathKeyExtractor, "getSinglePathKeyExtractor");
      function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
      }
      __name(arrayify, "arrayify");
      var _id_counter = 0;
      function getKeyPathAlias(keyPath) {
        return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : "[".concat(keyPath.join("+"), "]");
      }
      __name(getKeyPathAlias, "getKeyPathAlias");
      function createDBCore(db, IdbKeyRange, tmpTrans) {
        function extractSchema(db2, trans) {
          var tables2 = arrayify(db2.objectStoreNames);
          return {
            schema: {
              name: db2.name,
              tables: tables2.map(function(table) {
                return trans.objectStore(table);
              }).map(function(store) {
                var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                var compound = isArray6(keyPath);
                var outbound = keyPath == null;
                var indexByKeyPath = {};
                var result = {
                  name: store.name,
                  primaryKey: {
                    name: null,
                    isPrimaryKey: true,
                    outbound,
                    compound,
                    keyPath,
                    autoIncrement,
                    unique: true,
                    extractKey: getKeyExtractor(keyPath)
                  },
                  indexes: arrayify(store.indexNames).map(function(indexName) {
                    return store.index(indexName);
                  }).map(function(index) {
                    var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath2 = index.keyPath;
                    var compound2 = isArray6(keyPath2);
                    var result2 = {
                      name,
                      compound: compound2,
                      keyPath: keyPath2,
                      unique,
                      multiEntry,
                      extractKey: getKeyExtractor(keyPath2)
                    };
                    indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
                    return result2;
                  }),
                  getIndexByKeyPath: /* @__PURE__ */ __name(function(keyPath2) {
                    return indexByKeyPath[getKeyPathAlias(keyPath2)];
                  }, "getIndexByKeyPath")
                };
                indexByKeyPath[":id"] = result.primaryKey;
                if (keyPath != null) {
                  indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                }
                return result;
              })
            },
            hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
          };
        }
        __name(extractSchema, "extractSchema");
        function makeIDBKeyRange(range) {
          if (range.type === 3)
            return null;
          if (range.type === 4)
            throw new Error("Cannot convert never type to IDBKeyRange");
          var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
          var idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
          return idbRange;
        }
        __name(makeIDBKeyRange, "makeIDBKeyRange");
        function createDbCoreTable(tableSchema) {
          var tableName = tableSchema.name;
          function mutate(_a10) {
            var trans = _a10.trans, type2 = _a10.type, keys4 = _a10.keys, values = _a10.values, range = _a10.range;
            return new Promise(function(resolve, reject) {
              resolve = wrap(resolve);
              var store = trans.objectStore(tableName);
              var outbound = store.keyPath == null;
              var isAddOrPut = type2 === "put" || type2 === "add";
              if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
                throw new Error("Invalid operation type: " + type2);
              var length3 = (keys4 || values || { length: 1 }).length;
              if (keys4 && values && keys4.length !== values.length) {
                throw new Error("Given keys array must have same length as given values array.");
              }
              if (length3 === 0)
                return resolve({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              var req;
              var reqs = [];
              var failures = [];
              var numFailures = 0;
              var errorHandler = /* @__PURE__ */ __name(function(event) {
                ++numFailures;
                preventDefault(event);
              }, "errorHandler");
              if (type2 === "deleteRange") {
                if (range.type === 4)
                  return resolve({ numFailures, failures, results: [], lastResult: void 0 });
                if (range.type === 3)
                  reqs.push(req = store.clear());
                else
                  reqs.push(req = store.delete(makeIDBKeyRange(range)));
              } else {
                var _a11 = isAddOrPut ? outbound ? [values, keys4] : [values, null] : [keys4, null], args1 = _a11[0], args2 = _a11[1];
                if (isAddOrPut) {
                  for (var i = 0; i < length3; ++i) {
                    reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
                    req.onerror = errorHandler;
                  }
                } else {
                  for (var i = 0; i < length3; ++i) {
                    reqs.push(req = store[type2](args1[i]));
                    req.onerror = errorHandler;
                  }
                }
              }
              var done = /* @__PURE__ */ __name(function(event) {
                var lastResult = event.target.result;
                reqs.forEach(function(req2, i2) {
                  return req2.error != null && (failures[i2] = req2.error);
                });
                resolve({
                  numFailures,
                  failures,
                  results: type2 === "delete" ? keys4 : reqs.map(function(req2) {
                    return req2.result;
                  }),
                  lastResult
                });
              }, "done");
              req.onerror = function(event) {
                errorHandler(event);
                done(event);
              };
              req.onsuccess = done;
            });
          }
          __name(mutate, "mutate");
          function openCursor2(_a10) {
            var trans = _a10.trans, values = _a10.values, query2 = _a10.query, reverse = _a10.reverse, unique = _a10.unique;
            return new Promise(function(resolve, reject) {
              resolve = wrap(resolve);
              var index = query2.index, range = query2.range;
              var store = trans.objectStore(tableName);
              var source = index.isPrimaryKey ? store : store.index(index.name);
              var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
              var req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
              req.onerror = eventRejectHandler(reject);
              req.onsuccess = wrap(function(ev) {
                var cursor = req.result;
                if (!cursor) {
                  resolve(null);
                  return;
                }
                cursor.___id = ++_id_counter;
                cursor.done = false;
                var _cursorContinue = cursor.continue.bind(cursor);
                var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                if (_cursorContinuePrimaryKey)
                  _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                var _cursorAdvance = cursor.advance.bind(cursor);
                var doThrowCursorIsNotStarted = /* @__PURE__ */ __name(function() {
                  throw new Error("Cursor not started");
                }, "doThrowCursorIsNotStarted");
                var doThrowCursorIsStopped = /* @__PURE__ */ __name(function() {
                  throw new Error("Cursor not stopped");
                }, "doThrowCursorIsStopped");
                cursor.trans = trans;
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                cursor.fail = wrap(reject);
                cursor.next = function() {
                  var _this = this;
                  var gotOne = 1;
                  return this.start(function() {
                    return gotOne-- ? _this.continue() : _this.stop();
                  }).then(function() {
                    return _this;
                  });
                };
                cursor.start = function(callback) {
                  var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                    resolveIteration = wrap(resolveIteration);
                    req.onerror = eventRejectHandler(rejectIteration);
                    cursor.fail = rejectIteration;
                    cursor.stop = function(value) {
                      cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                      resolveIteration(value);
                    };
                  });
                  var guardedCallback = /* @__PURE__ */ __name(function() {
                    if (req.result) {
                      try {
                        callback();
                      } catch (err) {
                        cursor.fail(err);
                      }
                    } else {
                      cursor.done = true;
                      cursor.start = function() {
                        throw new Error("Cursor behind last entry");
                      };
                      cursor.stop();
                    }
                  }, "guardedCallback");
                  req.onsuccess = wrap(function(ev2) {
                    req.onsuccess = guardedCallback;
                    guardedCallback();
                  });
                  cursor.continue = _cursorContinue;
                  cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                  cursor.advance = _cursorAdvance;
                  guardedCallback();
                  return iterationPromise;
                };
                resolve(cursor);
              }, reject);
            });
          }
          __name(openCursor2, "openCursor");
          function query(hasGetAll2) {
            return function(request) {
              return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var trans = request.trans, values = request.values, limit = request.limit, query2 = request.query;
                var nonInfinitLimit = limit === Infinity ? void 0 : limit;
                var index = query2.index, range = query2.range;
                var store = trans.objectStore(tableName);
                var source = index.isPrimaryKey ? store : store.index(index.name);
                var idbKeyRange = makeIDBKeyRange(range);
                if (limit === 0)
                  return resolve({ result: [] });
                if (hasGetAll2) {
                  var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
                  req.onsuccess = function(event) {
                    return resolve({ result: event.target.result });
                  };
                  req.onerror = eventRejectHandler(reject);
                } else {
                  var count_1 = 0;
                  var req_1 = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
                  var result_1 = [];
                  req_1.onsuccess = function(event) {
                    var cursor = req_1.result;
                    if (!cursor)
                      return resolve({ result: result_1 });
                    result_1.push(values ? cursor.value : cursor.primaryKey);
                    if (++count_1 === limit)
                      return resolve({ result: result_1 });
                    cursor.continue();
                  };
                  req_1.onerror = eventRejectHandler(reject);
                }
              });
            };
          }
          __name(query, "query");
          return {
            name: tableName,
            schema: tableSchema,
            mutate,
            getMany: /* @__PURE__ */ __name(function(_a10) {
              var trans = _a10.trans, keys4 = _a10.keys;
              return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var store = trans.objectStore(tableName);
                var length3 = keys4.length;
                var result = new Array(length3);
                var keyCount = 0;
                var callbackCount = 0;
                var req;
                var successHandler = /* @__PURE__ */ __name(function(event) {
                  var req2 = event.target;
                  if ((result[req2._pos] = req2.result) != null)
                    ;
                  if (++callbackCount === keyCount)
                    resolve(result);
                }, "successHandler");
                var errorHandler = eventRejectHandler(reject);
                for (var i = 0; i < length3; ++i) {
                  var key = keys4[i];
                  if (key != null) {
                    req = store.get(keys4[i]);
                    req._pos = i;
                    req.onsuccess = successHandler;
                    req.onerror = errorHandler;
                    ++keyCount;
                  }
                }
                if (keyCount === 0)
                  resolve(result);
              });
            }, "getMany"),
            get: /* @__PURE__ */ __name(function(_a10) {
              var trans = _a10.trans, key = _a10.key;
              return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var store = trans.objectStore(tableName);
                var req = store.get(key);
                req.onsuccess = function(event) {
                  return resolve(event.target.result);
                };
                req.onerror = eventRejectHandler(reject);
              });
            }, "get"),
            query: query(hasGetAll),
            openCursor: openCursor2,
            count: /* @__PURE__ */ __name(function(_a10) {
              var query2 = _a10.query, trans = _a10.trans;
              var index = query2.index, range = query2.range;
              return new Promise(function(resolve, reject) {
                var store = trans.objectStore(tableName);
                var source = index.isPrimaryKey ? store : store.index(index.name);
                var idbKeyRange = makeIDBKeyRange(range);
                var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                req.onsuccess = wrap(function(ev) {
                  return resolve(ev.target.result);
                });
                req.onerror = eventRejectHandler(reject);
              });
            }, "count")
          };
        }
        __name(createDbCoreTable, "createDbCoreTable");
        var _a9 = extractSchema(db, tmpTrans), schema = _a9.schema, hasGetAll = _a9.hasGetAll;
        var tables = schema.tables.map(function(tableSchema) {
          return createDbCoreTable(tableSchema);
        });
        var tableMap = {};
        tables.forEach(function(table) {
          return tableMap[table.name] = table;
        });
        return {
          stack: "dbcore",
          transaction: db.transaction.bind(db),
          table: /* @__PURE__ */ __name(function(name) {
            var result = tableMap[name];
            if (!result)
              throw new Error("Table '".concat(name, "' not found"));
            return tableMap[name];
          }, "table"),
          MIN_KEY: -Infinity,
          MAX_KEY: getMaxKey(IdbKeyRange),
          schema
        };
      }
      __name(createDBCore, "createDBCore");
      function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce(function(down, _a9) {
          var create7 = _a9.create;
          return __assign(__assign({}, down), create7(down));
        }, stackImpl);
      }
      __name(createMiddlewareStack, "createMiddlewareStack");
      function createMiddlewareStacks(middlewares, idbdb, _a9, tmpTrans) {
        var IDBKeyRange2 = _a9.IDBKeyRange;
        _a9.indexedDB;
        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange2, tmpTrans), middlewares.dbcore);
        return {
          dbcore
        };
      }
      __name(createMiddlewareStacks, "createMiddlewareStacks");
      function generateMiddlewareStacks(db, tmpTrans) {
        var idbdb = tmpTrans.db;
        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
        db.core = stacks.dbcore;
        db.tables.forEach(function(table) {
          var tableName = table.name;
          if (db.core.schema.tables.some(function(tbl) {
            return tbl.name === tableName;
          })) {
            table.core = db.core.table(tableName);
            if (db[tableName] instanceof db.Table) {
              db[tableName].core = table.core;
            }
          }
        });
      }
      __name(generateMiddlewareStacks, "generateMiddlewareStacks");
      function setApiOnPlace(db, objs, tableNames, dbschema) {
        tableNames.forEach(function(tableName) {
          var schema = dbschema[tableName];
          objs.forEach(function(obj) {
            var propDesc = getPropertyDescriptor(obj, tableName);
            if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
              if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                setProp(obj, tableName, {
                  get: /* @__PURE__ */ __name(function() {
                    return this.table(tableName);
                  }, "get"),
                  set: /* @__PURE__ */ __name(function(value) {
                    defineProperty2(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                  }, "set")
                });
              } else {
                obj[tableName] = new db.Table(tableName, schema);
              }
            }
          });
        });
      }
      __name(setApiOnPlace, "setApiOnPlace");
      function removeTablesApi(db, objs) {
        objs.forEach(function(obj) {
          for (var key in obj) {
            if (obj[key] instanceof db.Table)
              delete obj[key];
          }
        });
      }
      __name(removeTablesApi, "removeTablesApi");
      function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
      }
      __name(lowerVersionFirst, "lowerVersionFirst");
      function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
        var globalSchema = db._dbSchema;
        if (idbUpgradeTrans.objectStoreNames.contains("$meta") && !globalSchema.$meta) {
          globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
          db._storeNames.push("$meta");
        }
        var trans = db._createTransaction("readwrite", db._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        var transless = PSD.transless || PSD;
        newScope(function() {
          PSD.trans = trans;
          PSD.transless = transless;
          if (oldVersion === 0) {
            keys3(globalSchema).forEach(function(tableName) {
              createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
            });
            generateMiddlewareStacks(db, idbUpgradeTrans);
            DexiePromise.follow(function() {
              return db.on.populate.fire(trans);
            }).catch(rejectTransaction);
          } else {
            generateMiddlewareStacks(db, idbUpgradeTrans);
            return getExistingVersion(db, trans, oldVersion).then(function(oldVersion2) {
              return updateTablesAndIndexes(db, oldVersion2, trans, idbUpgradeTrans);
            }).catch(rejectTransaction);
          }
        });
      }
      __name(runUpgraders, "runUpgraders");
      function patchCurrentVersion(db, idbUpgradeTrans) {
        createMissingTables(db._dbSchema, idbUpgradeTrans);
        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains("$meta")) {
          idbUpgradeTrans.db.createObjectStore("$meta").add(Math.ceil(idbUpgradeTrans.db.version / 10 - 1), "version");
        }
        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);
        var diff = getSchemaDiff(globalSchema, db._dbSchema);
        var _loop_1 = /* @__PURE__ */ __name(function(tableChange2) {
          if (tableChange2.change.length || tableChange2.recreate) {
            console.warn("Unable to patch indexes of table ".concat(tableChange2.name, " because it has changes on the type of index or primary key."));
            return { value: void 0 };
          }
          var store = idbUpgradeTrans.objectStore(tableChange2.name);
          tableChange2.add.forEach(function(idx) {
            if (debug21)
              console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange2.name, ".").concat(idx.src));
            addIndex(store, idx);
          });
        }, "_loop_1");
        for (var _i = 0, _a9 = diff.change; _i < _a9.length; _i++) {
          var tableChange = _a9[_i];
          var state_1 = _loop_1(tableChange);
          if (typeof state_1 === "object")
            return state_1.value;
        }
      }
      __name(patchCurrentVersion, "patchCurrentVersion");
      function getExistingVersion(db, trans, oldVersion) {
        if (trans.storeNames.includes("$meta")) {
          return trans.table("$meta").get("version").then(function(metaVersion) {
            return metaVersion != null ? metaVersion : oldVersion;
          });
        } else {
          return DexiePromise.resolve(oldVersion);
        }
      }
      __name(getExistingVersion, "getExistingVersion");
      function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {
        var queue = [];
        var versions = db._versions;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        var versToRun = versions.filter(function(v) {
          return v._cfg.version >= oldVersion;
        });
        if (versToRun.length === 0) {
          return DexiePromise.resolve();
        }
        versToRun.forEach(function(version) {
          queue.push(function() {
            var oldSchema = globalSchema;
            var newSchema = version._cfg.dbschema;
            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
            globalSchema = db._dbSchema = newSchema;
            var diff = getSchemaDiff(oldSchema, newSchema);
            diff.add.forEach(function(tuple) {
              createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
            });
            diff.change.forEach(function(change) {
              if (change.recreate) {
                throw new exceptions.Upgrade("Not yet support for changing primary key");
              } else {
                var store_1 = idbUpgradeTrans.objectStore(change.name);
                change.add.forEach(function(idx) {
                  return addIndex(store_1, idx);
                });
                change.change.forEach(function(idx) {
                  store_1.deleteIndex(idx.name);
                  addIndex(store_1, idx);
                });
                change.del.forEach(function(idxName) {
                  return store_1.deleteIndex(idxName);
                });
              }
            });
            var contentUpgrade = version._cfg.contentUpgrade;
            if (contentUpgrade && version._cfg.version > oldVersion) {
              generateMiddlewareStacks(db, idbUpgradeTrans);
              trans._memoizedTables = {};
              var upgradeSchema_1 = shallowClone(newSchema);
              diff.del.forEach(function(table) {
                upgradeSchema_1[table] = oldSchema[table];
              });
              removeTablesApi(db, [db.Transaction.prototype]);
              setApiOnPlace(db, [db.Transaction.prototype], keys3(upgradeSchema_1), upgradeSchema_1);
              trans.schema = upgradeSchema_1;
              var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
              if (contentUpgradeIsAsync_1) {
                incrementExpectedAwaits();
              }
              var returnValue_1;
              var promiseFollowed = DexiePromise.follow(function() {
                returnValue_1 = contentUpgrade(trans);
                if (returnValue_1) {
                  if (contentUpgradeIsAsync_1) {
                    var decrementor = decrementExpectedAwaits.bind(null, null);
                    returnValue_1.then(decrementor, decrementor);
                  }
                }
              });
              return returnValue_1 && typeof returnValue_1.then === "function" ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
                return returnValue_1;
              });
            }
          });
          queue.push(function(idbtrans) {
            var newSchema = version._cfg.dbschema;
            deleteRemovedTables(newSchema, idbtrans);
            removeTablesApi(db, [db.Transaction.prototype]);
            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
            trans.schema = db._dbSchema;
          });
          queue.push(function(idbtrans) {
            if (db.idbdb.objectStoreNames.contains("$meta")) {
              if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {
                db.idbdb.deleteObjectStore("$meta");
                delete db._dbSchema.$meta;
                db._storeNames = db._storeNames.filter(function(name) {
                  return name !== "$meta";
                });
              } else {
                idbtrans.objectStore("$meta").put(version._cfg.version, "version");
              }
            }
          });
        });
        function runQueue() {
          return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
        }
        __name(runQueue, "runQueue");
        return runQueue().then(function() {
          createMissingTables(globalSchema, idbUpgradeTrans);
        });
      }
      __name(updateTablesAndIndexes, "updateTablesAndIndexes");
      function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
          del: [],
          add: [],
          change: []
        };
        var table;
        for (table in oldSchema) {
          if (!newSchema[table])
            diff.del.push(table);
        }
        for (table in newSchema) {
          var oldDef = oldSchema[table], newDef = newSchema[table];
          if (!oldDef) {
            diff.add.push([table, newDef]);
          } else {
            var change = {
              name: table,
              def: newDef,
              recreate: false,
              del: [],
              add: [],
              change: []
            };
            if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto) {
              change.recreate = true;
              diff.change.push(change);
            } else {
              var oldIndexes = oldDef.idxByName;
              var newIndexes = newDef.idxByName;
              var idxName = void 0;
              for (idxName in oldIndexes) {
                if (!newIndexes[idxName])
                  change.del.push(idxName);
              }
              for (idxName in newIndexes) {
                var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                if (!oldIdx)
                  change.add.push(newIdx);
                else if (oldIdx.src !== newIdx.src)
                  change.change.push(newIdx);
              }
              if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                diff.change.push(change);
              }
            }
          }
        }
        return diff;
      }
      __name(getSchemaDiff, "getSchemaDiff");
      function createTable(idbtrans, tableName, primKey, indexes) {
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
        indexes.forEach(function(idx) {
          return addIndex(store, idx);
        });
        return store;
      }
      __name(createTable, "createTable");
      function createMissingTables(newSchema, idbtrans) {
        keys3(newSchema).forEach(function(tableName) {
          if (!idbtrans.db.objectStoreNames.contains(tableName)) {
            if (debug21)
              console.debug("Dexie: Creating missing table", tableName);
            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
          }
        });
      }
      __name(createMissingTables, "createMissingTables");
      function deleteRemovedTables(newSchema, idbtrans) {
        [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
          return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
        });
      }
      __name(deleteRemovedTables, "deleteRemovedTables");
      function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
      }
      __name(addIndex, "addIndex");
      function buildGlobalSchema(db, idbdb, tmpTrans) {
        var globalSchema = {};
        var dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(function(storeName) {
          var store = tmpTrans.objectStore(storeName);
          var keyPath = store.keyPath;
          var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
          var indexes = [];
          for (var j = 0; j < store.indexNames.length; ++j) {
            var idbindex = store.index(store.indexNames[j]);
            keyPath = idbindex.keyPath;
            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
            indexes.push(index);
          }
          globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
      }
      __name(buildGlobalSchema, "buildGlobalSchema");
      function readGlobalSchema(db, idbdb, tmpTrans) {
        db.verno = idbdb.version / 10;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
        db._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db, [db._allTables], keys3(globalSchema), globalSchema);
      }
      __name(readGlobalSchema, "readGlobalSchema");
      function verifyInstalledSchema(db, tmpTrans) {
        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
        var diff = getSchemaDiff(installedSchema, db._dbSchema);
        return !(diff.add.length || diff.change.some(function(ch) {
          return ch.add.length || ch.change.length;
        }));
      }
      __name(verifyInstalledSchema, "verifyInstalledSchema");
      function adjustToExistingIndexNames(db, schema, idbtrans) {
        var storeNames = idbtrans.db.objectStoreNames;
        for (var i = 0; i < storeNames.length; ++i) {
          var storeName = storeNames[i];
          var store = idbtrans.objectStore(storeName);
          db._hasGetAll = "getAll" in store;
          for (var j = 0; j < store.indexNames.length; ++j) {
            var indexName = store.indexNames[j];
            var keyPath = store.index(indexName).keyPath;
            var dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
            if (schema[storeName]) {
              var indexSpec = schema[storeName].idxByName[dexieName];
              if (indexSpec) {
                indexSpec.name = indexName;
                delete schema[storeName].idxByName[dexieName];
                schema[storeName].idxByName[indexName] = indexSpec;
              }
            }
          }
        }
        if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global2.WorkerGlobalScope && _global2 instanceof _global2.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
          db._hasGetAll = false;
        }
      }
      __name(adjustToExistingIndexNames, "adjustToExistingIndexNames");
      function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(",").map(function(index, indexNum) {
          index = index.trim();
          var name = index.replace(/([&*]|\+\+)/g, "");
          var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
          return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray6(keyPath), indexNum === 0);
        });
      }
      __name(parseIndexSyntax, "parseIndexSyntax");
      var Version = function() {
        function Version2() {
        }
        __name(Version2, "Version");
        Version2.prototype._parseStoresSpec = function(stores, outSchema) {
          keys3(stores).forEach(function(tableName) {
            if (stores[tableName] !== null) {
              var indexes = parseIndexSyntax(stores[tableName]);
              var primKey = indexes.shift();
              primKey.unique = true;
              if (primKey.multi)
                throw new exceptions.Schema("Primary key cannot be multi-valued");
              indexes.forEach(function(idx) {
                if (idx.auto)
                  throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                if (!idx.keyPath)
                  throw new exceptions.Schema("Index must have a name and cannot be an empty string");
              });
              outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
            }
          });
        };
        Version2.prototype.stores = function(stores) {
          var db = this.db;
          this._cfg.storesSource = this._cfg.storesSource ? extend2(this._cfg.storesSource, stores) : stores;
          var versions = db._versions;
          var storesSpec = {};
          var dbschema = {};
          versions.forEach(function(version) {
            extend2(storesSpec, version._cfg.storesSource);
            dbschema = version._cfg.dbschema = {};
            version._parseStoresSpec(storesSpec, dbschema);
          });
          db._dbSchema = dbschema;
          removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
          setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys3(dbschema), dbschema);
          db._storeNames = keys3(dbschema);
          return this;
        };
        Version2.prototype.upgrade = function(upgradeFunction) {
          this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
          return this;
        };
        return Version2;
      }();
      function createVersionConstructor(db) {
        return makeClassConstructor(Version.prototype, /* @__PURE__ */ __name(function Version2(versionNumber) {
          this.db = db;
          this._cfg = {
            version: versionNumber,
            storesSource: null,
            dbschema: {},
            tables: {},
            contentUpgrade: null
          };
        }, "Version"));
      }
      __name(createVersionConstructor, "createVersionConstructor");
      function getDbNamesTable(indexedDB2, IDBKeyRange2) {
        var dbNamesDB = indexedDB2["_dbNamesDB"];
        if (!dbNamesDB) {
          dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
            addons: [],
            indexedDB: indexedDB2,
            IDBKeyRange: IDBKeyRange2
          });
          dbNamesDB.version(1).stores({ dbnames: "name" });
        }
        return dbNamesDB.table("dbnames");
      }
      __name(getDbNamesTable, "getDbNamesTable");
      function hasDatabasesNative(indexedDB2) {
        return indexedDB2 && typeof indexedDB2.databases === "function";
      }
      __name(hasDatabasesNative, "hasDatabasesNative");
      function getDatabaseNames(_a9) {
        var indexedDB2 = _a9.indexedDB, IDBKeyRange2 = _a9.IDBKeyRange;
        return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then(function(infos) {
          return infos.map(function(info) {
            return info.name;
          }).filter(function(name) {
            return name !== DBNAMES_DB;
          });
        }) : getDbNamesTable(indexedDB2, IDBKeyRange2).toCollection().primaryKeys();
      }
      __name(getDatabaseNames, "getDatabaseNames");
      function _onDatabaseCreated(_a9, name) {
        var indexedDB2 = _a9.indexedDB, IDBKeyRange2 = _a9.IDBKeyRange;
        !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).put({ name }).catch(nop);
      }
      __name(_onDatabaseCreated, "_onDatabaseCreated");
      function _onDatabaseDeleted(_a9, name) {
        var indexedDB2 = _a9.indexedDB, IDBKeyRange2 = _a9.IDBKeyRange;
        !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).delete(name).catch(nop);
      }
      __name(_onDatabaseDeleted, "_onDatabaseDeleted");
      function vip(fn) {
        return newScope(function() {
          PSD.letThrough = true;
          return fn();
        });
      }
      __name(vip, "vip");
      function idbReady() {
        var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
        if (!isSafari || !indexedDB.databases)
          return Promise.resolve();
        var intervalId;
        return new Promise(function(resolve) {
          var tryIdb = /* @__PURE__ */ __name(function() {
            return indexedDB.databases().finally(resolve);
          }, "tryIdb");
          intervalId = setInterval(tryIdb, 100);
          tryIdb();
        }).finally(function() {
          return clearInterval(intervalId);
        });
      }
      __name(idbReady, "idbReady");
      var _a8;
      function isEmptyRange(node) {
        return !("from" in node);
      }
      __name(isEmptyRange, "isEmptyRange");
      var RangeSet3 = /* @__PURE__ */ __name(function(fromOrTree, to) {
        if (this) {
          extend2(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
        } else {
          var rv = new RangeSet3();
          if (fromOrTree && "d" in fromOrTree) {
            extend2(rv, fromOrTree);
          }
          return rv;
        }
      }, "RangeSet");
      props(RangeSet3.prototype, (_a8 = {
        add: /* @__PURE__ */ __name(function(rangeSet) {
          mergeRanges2(this, rangeSet);
          return this;
        }, "add"),
        addKey: /* @__PURE__ */ __name(function(key) {
          addRange(this, key, key);
          return this;
        }, "addKey"),
        addKeys: /* @__PURE__ */ __name(function(keys4) {
          var _this = this;
          keys4.forEach(function(key) {
            return addRange(_this, key, key);
          });
          return this;
        }, "addKeys")
      }, _a8[iteratorSymbol] = function() {
        return getRangeSetIterator(this);
      }, _a8));
      function addRange(target, from3, to) {
        var diff = cmp2(from3, to);
        if (isNaN(diff))
          return;
        if (diff > 0)
          throw RangeError();
        if (isEmptyRange(target))
          return extend2(target, { from: from3, to, d: 1 });
        var left = target.l;
        var right = target.r;
        if (cmp2(to, target.from) < 0) {
          left ? addRange(left, from3, to) : target.l = { from: from3, to, d: 1, l: null, r: null };
          return rebalance(target);
        }
        if (cmp2(from3, target.to) > 0) {
          right ? addRange(right, from3, to) : target.r = { from: from3, to, d: 1, l: null, r: null };
          return rebalance(target);
        }
        if (cmp2(from3, target.from) < 0) {
          target.from = from3;
          target.l = null;
          target.d = right ? right.d + 1 : 1;
        }
        if (cmp2(to, target.to) > 0) {
          target.to = to;
          target.r = null;
          target.d = target.l ? target.l.d + 1 : 1;
        }
        var rightWasCutOff = !target.r;
        if (left && !target.l) {
          mergeRanges2(target, left);
        }
        if (right && rightWasCutOff) {
          mergeRanges2(target, right);
        }
      }
      __name(addRange, "addRange");
      function mergeRanges2(target, newSet) {
        function _addRangeSet(target2, _a9) {
          var from3 = _a9.from, to = _a9.to, l = _a9.l, r = _a9.r;
          addRange(target2, from3, to);
          if (l)
            _addRangeSet(target2, l);
          if (r)
            _addRangeSet(target2, r);
        }
        __name(_addRangeSet, "_addRangeSet");
        if (!isEmptyRange(newSet))
          _addRangeSet(target, newSet);
      }
      __name(mergeRanges2, "mergeRanges");
      function rangesOverlap2(rangeSet1, rangeSet2) {
        var i1 = getRangeSetIterator(rangeSet2);
        var nextResult1 = i1.next();
        if (nextResult1.done)
          return false;
        var a = nextResult1.value;
        var i2 = getRangeSetIterator(rangeSet1);
        var nextResult2 = i2.next(a.from);
        var b = nextResult2.value;
        while (!nextResult1.done && !nextResult2.done) {
          if (cmp2(b.from, a.to) <= 0 && cmp2(b.to, a.from) >= 0)
            return true;
          cmp2(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
        }
        return false;
      }
      __name(rangesOverlap2, "rangesOverlap");
      function getRangeSetIterator(node) {
        var state = isEmptyRange(node) ? null : { s: 0, n: node };
        return {
          next: /* @__PURE__ */ __name(function(key) {
            var keyProvided = arguments.length > 0;
            while (state) {
              switch (state.s) {
                case 0:
                  state.s = 1;
                  if (keyProvided) {
                    while (state.n.l && cmp2(key, state.n.from) < 0)
                      state = { up: state, n: state.n.l, s: 1 };
                  } else {
                    while (state.n.l)
                      state = { up: state, n: state.n.l, s: 1 };
                  }
                case 1:
                  state.s = 2;
                  if (!keyProvided || cmp2(key, state.n.to) <= 0)
                    return { value: state.n, done: false };
                case 2:
                  if (state.n.r) {
                    state.s = 3;
                    state = { up: state, n: state.n.r, s: 0 };
                    continue;
                  }
                case 3:
                  state = state.up;
              }
            }
            return { done: true };
          }, "next")
        };
      }
      __name(getRangeSetIterator, "getRangeSetIterator");
      function rebalance(target) {
        var _a9, _b;
        var diff = (((_a9 = target.r) === null || _a9 === void 0 ? void 0 : _a9.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
        var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
        if (r) {
          var l = r === "r" ? "l" : "r";
          var rootClone = __assign({}, target);
          var oldRootRight = target[r];
          target.from = oldRootRight.from;
          target.to = oldRootRight.to;
          target[r] = oldRootRight[r];
          rootClone[r] = oldRootRight[l];
          target[l] = rootClone;
          rootClone.d = computeDepth(rootClone);
        }
        target.d = computeDepth(target);
      }
      __name(rebalance, "rebalance");
      function computeDepth(_a9) {
        var r = _a9.r, l = _a9.l;
        return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
      }
      __name(computeDepth, "computeDepth");
      function extendObservabilitySet(target, newSet) {
        keys3(newSet).forEach(function(part) {
          if (target[part])
            mergeRanges2(target[part], newSet[part]);
          else
            target[part] = cloneSimpleObjectTree(newSet[part]);
        });
        return target;
      }
      __name(extendObservabilitySet, "extendObservabilitySet");
      function obsSetsOverlap(os1, os2) {
        return os1.all || os2.all || Object.keys(os1).some(function(key) {
          return os2[key] && rangesOverlap2(os2[key], os1[key]);
        });
      }
      __name(obsSetsOverlap, "obsSetsOverlap");
      var cache = {};
      var unsignaledParts = {};
      var isTaskEnqueued = false;
      function signalSubscribersLazily(part, optimistic) {
        extendObservabilitySet(unsignaledParts, part);
        if (!isTaskEnqueued) {
          isTaskEnqueued = true;
          setTimeout(function() {
            isTaskEnqueued = false;
            var parts = unsignaledParts;
            unsignaledParts = {};
            signalSubscribersNow(parts, false);
          }, 0);
        }
      }
      __name(signalSubscribersLazily, "signalSubscribersLazily");
      function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
        if (deleteAffectedCacheEntries === void 0) {
          deleteAffectedCacheEntries = false;
        }
        var queriesToSignal = /* @__PURE__ */ new Set();
        if (updatedParts.all) {
          for (var _i = 0, _a9 = Object.values(cache); _i < _a9.length; _i++) {
            var tblCache = _a9[_i];
            collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
          }
        } else {
          for (var key in updatedParts) {
            var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
            if (parts) {
              var dbName = parts[1], tableName = parts[2];
              var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
              if (tblCache)
                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
          }
        }
        queriesToSignal.forEach(function(requery) {
          return requery();
        });
      }
      __name(signalSubscribersNow, "signalSubscribersNow");
      function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
        var updatedEntryLists = [];
        for (var _i = 0, _a9 = Object.entries(tblCache.queries.query); _i < _a9.length; _i++) {
          var _b = _a9[_i], indexName = _b[0], entries = _b[1];
          var filteredEntries = [];
          for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
            var entry = entries_1[_c];
            if (obsSetsOverlap(updatedParts, entry.obsSet)) {
              entry.subscribers.forEach(function(requery) {
                return outQueriesToSignal.add(requery);
              });
            } else if (deleteAffectedCacheEntries) {
              filteredEntries.push(entry);
            }
          }
          if (deleteAffectedCacheEntries)
            updatedEntryLists.push([indexName, filteredEntries]);
        }
        if (deleteAffectedCacheEntries) {
          for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
            var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
            tblCache.queries.query[indexName] = filteredEntries;
          }
        }
      }
      __name(collectTableSubscribers, "collectTableSubscribers");
      function dexieOpen(db) {
        var state = db._state;
        var indexedDB2 = db._deps.indexedDB;
        if (state.isBeingOpened || db.idbdb)
          return state.dbReadyPromise.then(function() {
            return state.dbOpenError ? rejection(state.dbOpenError) : db;
          });
        state.isBeingOpened = true;
        state.dbOpenError = null;
        state.openComplete = false;
        var openCanceller = state.openCanceller;
        var nativeVerToOpen = Math.round(db.verno * 10);
        var schemaPatchMode = false;
        function throwIfCancelled() {
          if (state.openCanceller !== openCanceller)
            throw new exceptions.DatabaseClosed("db.open() was cancelled");
        }
        __name(throwIfCancelled, "throwIfCancelled");
        var resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
        var tryOpenDB = /* @__PURE__ */ __name(function() {
          return new DexiePromise(function(resolve, reject) {
            throwIfCancelled();
            if (!indexedDB2)
              throw new exceptions.MissingAPI();
            var dbName = db.name;
            var req = state.autoSchema || !nativeVerToOpen ? indexedDB2.open(dbName) : indexedDB2.open(dbName, nativeVerToOpen);
            if (!req)
              throw new exceptions.MissingAPI();
            req.onerror = eventRejectHandler(reject);
            req.onblocked = wrap(db._fireOnBlocked);
            req.onupgradeneeded = wrap(function(e) {
              upgradeTransaction = req.transaction;
              if (state.autoSchema && !db._options.allowEmptyDB) {
                req.onerror = preventDefault;
                upgradeTransaction.abort();
                req.result.close();
                var delreq = indexedDB2.deleteDatabase(dbName);
                delreq.onsuccess = delreq.onerror = wrap(function() {
                  reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                });
              } else {
                upgradeTransaction.onerror = eventRejectHandler(reject);
                var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                wasCreated = oldVer < 1;
                db.idbdb = req.result;
                if (schemaPatchMode) {
                  patchCurrentVersion(db, upgradeTransaction);
                }
                runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
              }
            }, reject);
            req.onsuccess = wrap(function() {
              upgradeTransaction = null;
              var idbdb = db.idbdb = req.result;
              var objectStoreNames = slice(idbdb.objectStoreNames);
              if (objectStoreNames.length > 0)
                try {
                  var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
                  if (state.autoSchema)
                    readGlobalSchema(db, idbdb, tmpTrans);
                  else {
                    adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                    if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {
                      console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                      idbdb.close();
                      nativeVerToOpen = idbdb.version + 1;
                      schemaPatchMode = true;
                      return resolve(tryOpenDB());
                    }
                  }
                  generateMiddlewareStacks(db, tmpTrans);
                } catch (e) {
                }
              connections.push(db);
              idbdb.onversionchange = wrap(function(ev) {
                state.vcFired = true;
                db.on("versionchange").fire(ev);
              });
              idbdb.onclose = wrap(function(ev) {
                db.on("close").fire(ev);
              });
              if (wasCreated)
                _onDatabaseCreated(db._deps, dbName);
              resolve();
            }, reject);
          }).catch(function(err) {
            switch (err === null || err === void 0 ? void 0 : err.name) {
              case "UnknownError":
                if (state.PR1398_maxLoop > 0) {
                  state.PR1398_maxLoop--;
                  console.warn("Dexie: Workaround for Chrome UnknownError on open()");
                  return tryOpenDB();
                }
                break;
              case "VersionError":
                if (nativeVerToOpen > 0) {
                  nativeVerToOpen = 0;
                  return tryOpenDB();
                }
                break;
            }
            return DexiePromise.reject(err);
          });
        }, "tryOpenDB");
        return DexiePromise.race([
          openCanceller,
          (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
        ]).then(function() {
          throwIfCancelled();
          state.onReadyBeingFired = [];
          return DexiePromise.resolve(vip(function() {
            return db.on.ready.fire(db.vip);
          })).then(/* @__PURE__ */ __name(function fireRemainders() {
            if (state.onReadyBeingFired.length > 0) {
              var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
              state.onReadyBeingFired = [];
              return DexiePromise.resolve(vip(function() {
                return remainders_1(db.vip);
              })).then(fireRemainders);
            }
          }, "fireRemainders"));
        }).finally(function() {
          if (state.openCanceller === openCanceller) {
            state.onReadyBeingFired = null;
            state.isBeingOpened = false;
          }
        }).catch(function(err) {
          state.dbOpenError = err;
          try {
            upgradeTransaction && upgradeTransaction.abort();
          } catch (_a9) {
          }
          if (openCanceller === state.openCanceller) {
            db._close();
          }
          return rejection(err);
        }).finally(function() {
          state.openComplete = true;
          resolveDbReady();
        }).then(function() {
          if (wasCreated) {
            var everything_1 = {};
            db.tables.forEach(function(table) {
              table.schema.indexes.forEach(function(idx) {
                if (idx.name)
                  everything_1["idb://".concat(db.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet3(-Infinity, [[[]]]);
              });
              everything_1["idb://".concat(db.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db.name, "/").concat(table.name, "/:dels")] = new RangeSet3(-Infinity, [[[]]]);
            });
            globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
            signalSubscribersNow(everything_1, true);
          }
          return db;
        });
      }
      __name(dexieOpen, "dexieOpen");
      function awaitIterator(iterator2) {
        var callNext = /* @__PURE__ */ __name(function(result) {
          return iterator2.next(result);
        }, "callNext"), doThrow = /* @__PURE__ */ __name(function(error) {
          return iterator2.throw(error);
        }, "doThrow"), onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
          return function(val) {
            var next = getNext(val), value = next.value;
            return next.done ? value : !value || typeof value.then !== "function" ? isArray6(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
          };
        }
        __name(step, "step");
        return step(callNext)();
      }
      __name(awaitIterator, "awaitIterator");
      function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i = arguments.length;
        if (i < 2)
          throw new exceptions.InvalidArgument("Too few arguments");
        var args2 = new Array(i - 1);
        while (--i)
          args2[i - 1] = arguments[i];
        scopeFunc = args2.pop();
        var tables = flatten(args2);
        return [mode, tables, scopeFunc];
      }
      __name(extractTransactionArgs, "extractTransactionArgs");
      function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(function() {
          var transless = PSD.transless || PSD;
          var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
          trans.explicit = true;
          var zoneProps = {
            trans,
            transless
          };
          if (parentTransaction) {
            trans.idbtrans = parentTransaction.idbtrans;
          } else {
            try {
              trans.create();
              trans.idbtrans._explicit = true;
              db._state.PR1398_maxLoop = 3;
            } catch (ex) {
              if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                console.warn("Dexie: Need to reopen db");
                db.close({ disableAutoOpen: false });
                return db.open().then(function() {
                  return enterTransactionScope(db, mode, storeNames, null, scopeFunc);
                });
              }
              return rejection(ex);
            }
          }
          var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
          if (scopeFuncIsAsync) {
            incrementExpectedAwaits();
          }
          var returnValue;
          var promiseFollowed = DexiePromise.follow(function() {
            returnValue = scopeFunc.call(trans, trans);
            if (returnValue) {
              if (scopeFuncIsAsync) {
                var decrementor = decrementExpectedAwaits.bind(null, null);
                returnValue.then(decrementor, decrementor);
              } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
                returnValue = awaitIterator(returnValue);
              }
            }
          }, zoneProps);
          return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then(function(x) {
            return trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
          }) : promiseFollowed.then(function() {
            return returnValue;
          })).then(function(x) {
            if (parentTransaction)
              trans._resolve();
            return trans._completion.then(function() {
              return x;
            });
          }).catch(function(e) {
            trans._reject(e);
            return rejection(e);
          });
        });
      }
      __name(enterTransactionScope, "enterTransactionScope");
      function pad(a, value, count2) {
        var result = isArray6(a) ? a.slice() : [a];
        for (var i = 0; i < count2; ++i)
          result.push(value);
        return result;
      }
      __name(pad, "pad");
      function createVirtualIndexMiddleware(down) {
        return __assign(__assign({}, down), { table: /* @__PURE__ */ __name(function(tableName) {
          var table = down.table(tableName);
          var schema = table.schema;
          var indexLookup = {};
          var allVirtualIndexes = [];
          function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
            var keyPathAlias = getKeyPathAlias(keyPath);
            var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
            var keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
            var isVirtual = keyTail > 0;
            var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")") : lowLevelIndex.name, lowLevelIndex, isVirtual, keyTail, keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
            indexList.push(virtualIndex);
            if (!virtualIndex.isPrimaryKey) {
              allVirtualIndexes.push(virtualIndex);
            }
            if (keyLength > 1) {
              var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
              addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
            }
            indexList.sort(function(a, b) {
              return a.keyTail - b.keyTail;
            });
            return virtualIndex;
          }
          __name(addVirtualIndexes, "addVirtualIndexes");
          var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
          indexLookup[":id"] = [primaryKey];
          for (var _i = 0, _a9 = schema.indexes; _i < _a9.length; _i++) {
            var index = _a9[_i];
            addVirtualIndexes(index.keyPath, 0, index);
          }
          function findBestIndex(keyPath) {
            var result2 = indexLookup[getKeyPathAlias(keyPath)];
            return result2 && result2[0];
          }
          __name(findBestIndex, "findBestIndex");
          function translateRange(range, keyTail) {
            return {
              type: range.type === 1 ? 2 : range.type,
              lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
              lowerOpen: true,
              upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
              upperOpen: true
            };
          }
          __name(translateRange, "translateRange");
          function translateRequest(req) {
            var index2 = req.query.index;
            return index2.isVirtual ? __assign(__assign({}, req), { query: {
              index: index2.lowLevelIndex,
              range: translateRange(req.query.range, index2.keyTail)
            } }) : req;
          }
          __name(translateRequest, "translateRequest");
          var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: /* @__PURE__ */ __name(function(req) {
            return table.count(translateRequest(req));
          }, "count"), query: /* @__PURE__ */ __name(function(req) {
            return table.query(translateRequest(req));
          }, "query"), openCursor: /* @__PURE__ */ __name(function(req) {
            var _a10 = req.query.index, keyTail = _a10.keyTail, isVirtual = _a10.isVirtual, keyLength = _a10.keyLength;
            if (!isVirtual)
              return table.openCursor(req);
            function createVirtualCursor(cursor) {
              function _continue(key) {
                key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
              }
              __name(_continue, "_continue");
              var virtualCursor = Object.create(cursor, {
                continue: { value: _continue },
                continuePrimaryKey: {
                  value: /* @__PURE__ */ __name(function(key, primaryKey2) {
                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                  }, "value")
                },
                primaryKey: {
                  get: /* @__PURE__ */ __name(function() {
                    return cursor.primaryKey;
                  }, "get")
                },
                key: {
                  get: /* @__PURE__ */ __name(function() {
                    var key = cursor.key;
                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                  }, "get")
                },
                value: {
                  get: /* @__PURE__ */ __name(function() {
                    return cursor.value;
                  }, "get")
                }
              });
              return virtualCursor;
            }
            __name(createVirtualCursor, "createVirtualCursor");
            return table.openCursor(translateRequest(req)).then(function(cursor) {
              return cursor && createVirtualCursor(cursor);
            });
          }, "openCursor") });
          return result;
        }, "table") });
      }
      __name(createVirtualIndexMiddleware, "createVirtualIndexMiddleware");
      var virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
      };
      function getObjectDiff(a, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || "";
        keys3(a).forEach(function(prop) {
          if (!hasOwn(b, prop)) {
            rv[prfx + prop] = void 0;
          } else {
            var ap = a[prop], bp = b[prop];
            if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
              var apTypeName = toStringTag(ap);
              var bpTypeName = toStringTag(bp);
              if (apTypeName !== bpTypeName) {
                rv[prfx + prop] = b[prop];
              } else if (apTypeName === "Object") {
                getObjectDiff(ap, bp, rv, prfx + prop + ".");
              } else if (ap !== bp) {
                rv[prfx + prop] = b[prop];
              }
            } else if (ap !== bp)
              rv[prfx + prop] = b[prop];
          }
        });
        keys3(b).forEach(function(prop) {
          if (!hasOwn(a, prop)) {
            rv[prfx + prop] = b[prop];
          }
        });
        return rv;
      }
      __name(getObjectDiff, "getObjectDiff");
      function getEffectiveKeys(primaryKey, req) {
        if (req.type === "delete")
          return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
      }
      __name(getEffectiveKeys, "getEffectiveKeys");
      var hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: /* @__PURE__ */ __name(function(downCore) {
          return __assign(__assign({}, downCore), { table: /* @__PURE__ */ __name(function(tableName) {
            var downTable = downCore.table(tableName);
            var primaryKey = downTable.schema.primaryKey;
            var tableMiddleware = __assign(__assign({}, downTable), { mutate: /* @__PURE__ */ __name(function(req) {
              var dxTrans = PSD.trans;
              var _a9 = dxTrans.table(tableName).hook, deleting = _a9.deleting, creating = _a9.creating, updating = _a9.updating;
              switch (req.type) {
                case "add":
                  if (creating.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "put":
                  if (creating.fire === nop && updating.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "delete":
                  if (deleting.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "deleteRange":
                  if (deleting.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return deleteRange(req);
                  }, true);
              }
              return downTable.mutate(req);
              function addPutOrDelete(req2) {
                var dxTrans2 = PSD.trans;
                var keys4 = req2.keys || getEffectiveKeys(primaryKey, req2);
                if (!keys4)
                  throw new Error("Keys missing");
                req2 = req2.type === "add" || req2.type === "put" ? __assign(__assign({}, req2), { keys: keys4 }) : __assign({}, req2);
                if (req2.type !== "delete")
                  req2.values = __spreadArray2([], req2.values, true);
                if (req2.keys)
                  req2.keys = __spreadArray2([], req2.keys, true);
                return getExistingValues(downTable, req2, keys4).then(function(existingValues) {
                  var contexts = keys4.map(function(key, i) {
                    var existingValue = existingValues[i];
                    var ctx = { onerror: null, onsuccess: null };
                    if (req2.type === "delete") {
                      deleting.fire.call(ctx, key, existingValue, dxTrans2);
                    } else if (req2.type === "add" || existingValue === void 0) {
                      var generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                      if (key == null && generatedPrimaryKey != null) {
                        key = generatedPrimaryKey;
                        req2.keys[i] = key;
                        if (!primaryKey.outbound) {
                          setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                        }
                      }
                    } else {
                      var objectDiff = getObjectDiff(existingValue, req2.values[i]);
                      var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                      if (additionalChanges_1) {
                        var requestedValue_1 = req2.values[i];
                        Object.keys(additionalChanges_1).forEach(function(keyPath) {
                          if (hasOwn(requestedValue_1, keyPath)) {
                            requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                          } else {
                            setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                          }
                        });
                      }
                    }
                    return ctx;
                  });
                  return downTable.mutate(req2).then(function(_a10) {
                    var failures = _a10.failures, results = _a10.results, numFailures = _a10.numFailures, lastResult = _a10.lastResult;
                    for (var i = 0; i < keys4.length; ++i) {
                      var primKey = results ? results[i] : keys4[i];
                      var ctx = contexts[i];
                      if (primKey == null) {
                        ctx.onerror && ctx.onerror(failures[i]);
                      } else {
                        ctx.onsuccess && ctx.onsuccess(
                          req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                        );
                      }
                    }
                    return { failures, results, numFailures, lastResult };
                  }).catch(function(error) {
                    contexts.forEach(function(ctx) {
                      return ctx.onerror && ctx.onerror(error);
                    });
                    return Promise.reject(error);
                  });
                });
              }
              __name(addPutOrDelete, "addPutOrDelete");
              function deleteRange(req2) {
                return deleteNextChunk(req2.trans, req2.range, 1e4);
              }
              __name(deleteRange, "deleteRange");
              function deleteNextChunk(trans, range, limit) {
                return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(function(_a10) {
                  var result = _a10.result;
                  return addPutOrDelete({ type: "delete", keys: result, trans }).then(function(res) {
                    if (res.numFailures > 0)
                      return Promise.reject(res.failures[0]);
                    if (result.length < limit) {
                      return { failures: [], numFailures: 0, lastResult: void 0 };
                    } else {
                      return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                    }
                  });
                });
              }
              __name(deleteNextChunk, "deleteNextChunk");
            }, "mutate") });
            return tableMiddleware;
          }, "table") });
        }, "create")
      };
      function getExistingValues(table, req, effectiveKeys) {
        return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
      }
      __name(getExistingValues, "getExistingValues");
      function getFromTransactionCache(keys4, cache2, clone) {
        try {
          if (!cache2)
            return null;
          if (cache2.keys.length < keys4.length)
            return null;
          var result = [];
          for (var i = 0, j = 0; i < cache2.keys.length && j < keys4.length; ++i) {
            if (cmp2(cache2.keys[i], keys4[j]) !== 0)
              continue;
            result.push(clone ? deepClone(cache2.values[i]) : cache2.values[i]);
            ++j;
          }
          return result.length === keys4.length ? result : null;
        } catch (_a9) {
          return null;
        }
      }
      __name(getFromTransactionCache, "getFromTransactionCache");
      var cacheExistingValuesMiddleware = {
        stack: "dbcore",
        level: -1,
        create: /* @__PURE__ */ __name(function(core) {
          return {
            table: /* @__PURE__ */ __name(function(tableName) {
              var table = core.table(tableName);
              return __assign(__assign({}, table), { getMany: /* @__PURE__ */ __name(function(req) {
                if (!req.cache) {
                  return table.getMany(req);
                }
                var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                if (cachedResult) {
                  return DexiePromise.resolve(cachedResult);
                }
                return table.getMany(req).then(function(res) {
                  req.trans["_cache"] = {
                    keys: req.keys,
                    values: req.cache === "clone" ? deepClone(res) : res
                  };
                  return res;
                });
              }, "getMany"), mutate: /* @__PURE__ */ __name(function(req) {
                if (req.type !== "add")
                  req.trans["_cache"] = null;
                return table.mutate(req);
              }, "mutate") });
            }, "table")
          };
        }, "create")
      };
      function isCachableContext(ctx, table) {
        return ctx.trans.mode === "readonly" && !!ctx.subscr && !ctx.trans.explicit && ctx.trans.db._options.cache !== "disabled" && !table.schema.primaryKey.outbound;
      }
      __name(isCachableContext, "isCachableContext");
      function isCachableRequest(type2, req) {
        switch (type2) {
          case "query":
            return req.values && !req.unique;
          case "get":
            return false;
          case "getMany":
            return false;
          case "count":
            return false;
          case "openCursor":
            return false;
        }
      }
      __name(isCachableRequest, "isCachableRequest");
      var observabilityMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Observability",
        create: /* @__PURE__ */ __name(function(core) {
          var dbName = core.schema.name;
          var FULL_RANGE = new RangeSet3(core.MIN_KEY, core.MAX_KEY);
          return __assign(__assign({}, core), { transaction: /* @__PURE__ */ __name(function(stores, mode, options) {
            if (PSD.subscr && mode !== "readonly") {
              throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
            }
            return core.transaction(stores, mode, options);
          }, "transaction"), table: /* @__PURE__ */ __name(function(tableName) {
            var table = core.table(tableName);
            var schema = table.schema;
            var primaryKey = schema.primaryKey, indexes = schema.indexes;
            var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
            var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function(index) {
              return index.compound && index.keyPath.includes(primaryKey.keyPath);
            });
            var tableClone = __assign(__assign({}, table), { mutate: /* @__PURE__ */ __name(function(req) {
              var trans = req.trans;
              var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
              var getRangeSet = /* @__PURE__ */ __name(function(indexName) {
                var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                return mutatedParts[part] || (mutatedParts[part] = new RangeSet3());
              }, "getRangeSet");
              var pkRangeSet = getRangeSet("");
              var delsRangeSet = getRangeSet(":dels");
              var type2 = req.type;
              var _a9 = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [getEffectiveKeys(primaryKey, req).filter(function(id) {
                return id;
              }), req.values] : [], keys4 = _a9[0], newObjs = _a9[1];
              var oldCache = req.trans["_cache"];
              if (isArray6(keys4)) {
                pkRangeSet.addKeys(keys4);
                var oldObjs = type2 === "delete" || keys4.length === newObjs.length ? getFromTransactionCache(keys4, oldCache) : null;
                if (!oldObjs) {
                  delsRangeSet.addKeys(keys4);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys4) {
                var range = { from: keys4.lower, to: keys4.upper };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach(function(idx) {
                  return getRangeSet(idx.name).add(FULL_RANGE);
                });
              }
              return table.mutate(req).then(function(res) {
                if (keys4 && (req.type === "add" || req.type === "put")) {
                  pkRangeSet.addKeys(res.results);
                  if (indexesWithAutoIncPK) {
                    indexesWithAutoIncPK.forEach(function(idx) {
                      var idxVals = req.values.map(function(v) {
                        return idx.extractKey(v);
                      });
                      var pkPos = idx.keyPath.findIndex(function(prop) {
                        return prop === primaryKey.keyPath;
                      });
                      res.results.forEach(function(pk) {
                        return idxVals[pkPos] = pk;
                      });
                      getRangeSet(idx.name).addKeys(idxVals);
                    });
                  }
                }
                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                return res;
              });
            }, "mutate") });
            var getRange = /* @__PURE__ */ __name(function(_a9) {
              var _b, _c;
              var _d = _a9.query, index = _d.index, range = _d.range;
              return [
                index,
                new RangeSet3((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
              ];
            }, "getRange");
            var readSubscribers = {
              get: /* @__PURE__ */ __name(function(req) {
                return [primaryKey, new RangeSet3(req.key)];
              }, "get"),
              getMany: /* @__PURE__ */ __name(function(req) {
                return [primaryKey, new RangeSet3().addKeys(req.keys)];
              }, "getMany"),
              count: getRange,
              query: getRange,
              openCursor: getRange
            };
            keys3(readSubscribers).forEach(function(method) {
              tableClone[method] = function(req) {
                var subscr = PSD.subscr;
                var isLiveQuery = !!subscr;
                var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                var obsSet = cachable ? req.obsSet = {} : subscr;
                if (isLiveQuery) {
                  var getRangeSet = /* @__PURE__ */ __name(function(indexName) {
                    var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                    return obsSet[part] || (obsSet[part] = new RangeSet3());
                  }, "getRangeSet");
                  var pkRangeSet_1 = getRangeSet("");
                  var delsRangeSet_1 = getRangeSet(":dels");
                  var _a9 = readSubscribers[method](req), queriedIndex = _a9[0], queriedRanges = _a9[1];
                  if (method === "query" && queriedIndex.isPrimaryKey && !req.values) {
                    delsRangeSet_1.add(queriedRanges);
                  } else {
                    getRangeSet(queriedIndex.name || "").add(queriedRanges);
                  }
                  if (!queriedIndex.isPrimaryKey) {
                    if (method === "count") {
                      delsRangeSet_1.add(FULL_RANGE);
                    } else {
                      var keysPromise_1 = method === "query" && outbound && req.values && table.query(__assign(__assign({}, req), { values: false }));
                      return table[method].apply(this, arguments).then(function(res) {
                        if (method === "query") {
                          if (outbound && req.values) {
                            return keysPromise_1.then(function(_a10) {
                              var resultingKeys = _a10.result;
                              pkRangeSet_1.addKeys(resultingKeys);
                              return res;
                            });
                          }
                          var pKeys = req.values ? res.result.map(extractKey) : res.result;
                          if (req.values) {
                            pkRangeSet_1.addKeys(pKeys);
                          } else {
                            delsRangeSet_1.addKeys(pKeys);
                          }
                        } else if (method === "openCursor") {
                          var cursor_1 = res;
                          var wantValues_1 = req.values;
                          return cursor_1 && Object.create(cursor_1, {
                            key: {
                              get: /* @__PURE__ */ __name(function() {
                                delsRangeSet_1.addKey(cursor_1.primaryKey);
                                return cursor_1.key;
                              }, "get")
                            },
                            primaryKey: {
                              get: /* @__PURE__ */ __name(function() {
                                var pkey = cursor_1.primaryKey;
                                delsRangeSet_1.addKey(pkey);
                                return pkey;
                              }, "get")
                            },
                            value: {
                              get: /* @__PURE__ */ __name(function() {
                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                return cursor_1.value;
                              }, "get")
                            }
                          });
                        }
                        return res;
                      });
                    }
                  }
                }
                return table[method].apply(this, arguments);
              };
            });
            return tableClone;
          }, "table") });
        }, "create")
      };
      function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
        function addAffectedIndex(ix) {
          var rangeSet = getRangeSet(ix.name || "");
          function extractKey(obj) {
            return obj != null ? ix.extractKey(obj) : null;
          }
          __name(extractKey, "extractKey");
          var addKeyOrKeys = /* @__PURE__ */ __name(function(key) {
            return ix.multiEntry && isArray6(key) ? key.forEach(function(key2) {
              return rangeSet.addKey(key2);
            }) : rangeSet.addKey(key);
          }, "addKeyOrKeys");
          (oldObjs || newObjs).forEach(function(_, i) {
            var oldKey = oldObjs && extractKey(oldObjs[i]);
            var newKey = newObjs && extractKey(newObjs[i]);
            if (cmp2(oldKey, newKey) !== 0) {
              if (oldKey != null)
                addKeyOrKeys(oldKey);
              if (newKey != null)
                addKeyOrKeys(newKey);
            }
          });
        }
        __name(addAffectedIndex, "addAffectedIndex");
        schema.indexes.forEach(addAffectedIndex);
      }
      __name(trackAffectedIndexes, "trackAffectedIndexes");
      function adjustOptimisticFromFailures(tblCache, req, res) {
        if (res.numFailures === 0)
          return req;
        if (req.type === "deleteRange") {
          return null;
        }
        var numBulkOps = req.keys ? req.keys.length : "values" in req && req.values ? req.values.length : 1;
        if (res.numFailures === numBulkOps) {
          return null;
        }
        var clone = __assign({}, req);
        if (isArray6(clone.keys)) {
          clone.keys = clone.keys.filter(function(_, i) {
            return !(i in res.failures);
          });
        }
        if ("values" in clone && isArray6(clone.values)) {
          clone.values = clone.values.filter(function(_, i) {
            return !(i in res.failures);
          });
        }
        return clone;
      }
      __name(adjustOptimisticFromFailures, "adjustOptimisticFromFailures");
      function isAboveLower(key, range) {
        return range.lower === void 0 ? true : range.lowerOpen ? cmp2(key, range.lower) > 0 : cmp2(key, range.lower) >= 0;
      }
      __name(isAboveLower, "isAboveLower");
      function isBelowUpper(key, range) {
        return range.upper === void 0 ? true : range.upperOpen ? cmp2(key, range.upper) < 0 : cmp2(key, range.upper) <= 0;
      }
      __name(isBelowUpper, "isBelowUpper");
      function isWithinRange(key, range) {
        return isAboveLower(key, range) && isBelowUpper(key, range);
      }
      __name(isWithinRange, "isWithinRange");
      function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
        if (!ops || ops.length === 0)
          return result;
        var index = req.query.index;
        var multiEntry = index.multiEntry;
        var queryRange = req.query.range;
        var primaryKey = table.schema.primaryKey;
        var extractPrimKey = primaryKey.extractKey;
        var extractIndex = index.extractKey;
        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;
        var finalResult = ops.reduce(function(result2, op) {
          var modifedResult = result2;
          var includedValues = op.type === "add" || op.type === "put" ? op.values.filter(function(v) {
            var key = extractIndex(v);
            return multiEntry && isArray6(key) ? key.some(function(k) {
              return isWithinRange(k, queryRange);
            }) : isWithinRange(key, queryRange);
          }).map(function(v) {
            v = deepClone(v);
            if (immutable)
              Object.freeze(v);
            return v;
          }) : [];
          switch (op.type) {
            case "add":
              modifedResult = result2.concat(req.values ? includedValues : includedValues.map(function(v) {
                return extractPrimKey(v);
              }));
              break;
            case "put":
              var keySet_1 = new RangeSet3().addKeys(op.values.map(function(v) {
                return extractPrimKey(v);
              }));
              modifedResult = result2.filter(function(item) {
                var key = req.values ? extractPrimKey(item) : item;
                return !rangesOverlap2(new RangeSet3(key), keySet_1);
              }).concat(req.values ? includedValues : includedValues.map(function(v) {
                return extractPrimKey(v);
              }));
              break;
            case "delete":
              var keysToDelete_1 = new RangeSet3().addKeys(op.keys);
              modifedResult = result2.filter(function(item) {
                var key = req.values ? extractPrimKey(item) : item;
                return !rangesOverlap2(new RangeSet3(key), keysToDelete_1);
              });
              break;
            case "deleteRange":
              var range_1 = op.range;
              modifedResult = result2.filter(function(item) {
                return !isWithinRange(extractPrimKey(item), range_1);
              });
              break;
          }
          return modifedResult;
        }, result);
        if (finalResult === result)
          return result;
        finalResult.sort(function(a, b) {
          return cmp2(extractLowLevelIndex(a), extractLowLevelIndex(b)) || cmp2(extractPrimKey(a), extractPrimKey(b));
        });
        if (req.limit && req.limit < Infinity) {
          if (finalResult.length > req.limit) {
            finalResult.length = req.limit;
          } else if (result.length === req.limit && finalResult.length < req.limit) {
            cacheEntry.dirty = true;
          }
        }
        return immutable ? Object.freeze(finalResult) : finalResult;
      }
      __name(applyOptimisticOps, "applyOptimisticOps");
      function areRangesEqual(r1, r2) {
        return cmp2(r1.lower, r2.lower) === 0 && cmp2(r1.upper, r2.upper) === 0 && !!r1.lowerOpen === !!r2.lowerOpen && !!r1.upperOpen === !!r2.upperOpen;
      }
      __name(areRangesEqual, "areRangesEqual");
      function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
        if (lower1 === void 0)
          return lower2 !== void 0 ? -1 : 0;
        if (lower2 === void 0)
          return 1;
        var c = cmp2(lower1, lower2);
        if (c === 0) {
          if (lowerOpen1 && lowerOpen2)
            return 0;
          if (lowerOpen1)
            return 1;
          if (lowerOpen2)
            return -1;
        }
        return c;
      }
      __name(compareLowers, "compareLowers");
      function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
        if (upper1 === void 0)
          return upper2 !== void 0 ? 1 : 0;
        if (upper2 === void 0)
          return -1;
        var c = cmp2(upper1, upper2);
        if (c === 0) {
          if (upperOpen1 && upperOpen2)
            return 0;
          if (upperOpen1)
            return -1;
          if (upperOpen2)
            return 1;
        }
        return c;
      }
      __name(compareUppers, "compareUppers");
      function isSuperRange(r1, r2) {
        return compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 && compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0;
      }
      __name(isSuperRange, "isSuperRange");
      function findCompatibleQuery(dbName, tableName, type2, req) {
        var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
        if (!tblCache)
          return [];
        var queries = tblCache.queries[type2];
        if (!queries)
          return [null, false, tblCache, null];
        var indexName = req.query ? req.query.index.name : null;
        var entries = queries[indexName || ""];
        if (!entries)
          return [null, false, tblCache, null];
        switch (type2) {
          case "query":
            var equalEntry = entries.find(function(entry) {
              return entry.req.limit === req.limit && entry.req.values === req.values && areRangesEqual(entry.req.query.range, req.query.range);
            });
            if (equalEntry)
              return [
                equalEntry,
                true,
                tblCache,
                entries
              ];
            var superEntry = entries.find(function(entry) {
              var limit = "limit" in entry.req ? entry.req.limit : Infinity;
              return limit >= req.limit && (req.values ? entry.req.values : true) && isSuperRange(entry.req.query.range, req.query.range);
            });
            return [superEntry, false, tblCache, entries];
          case "count":
            var countQuery = entries.find(function(entry) {
              return areRangesEqual(entry.req.query.range, req.query.range);
            });
            return [countQuery, !!countQuery, tblCache, entries];
        }
      }
      __name(findCompatibleQuery, "findCompatibleQuery");
      function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
        cacheEntry.subscribers.add(requery);
        signal.addEventListener("abort", function() {
          cacheEntry.subscribers.delete(requery);
          if (cacheEntry.subscribers.size === 0) {
            enqueForDeletion(cacheEntry, container);
          }
        });
      }
      __name(subscribeToCacheEntry, "subscribeToCacheEntry");
      function enqueForDeletion(cacheEntry, container) {
        setTimeout(function() {
          if (cacheEntry.subscribers.size === 0) {
            delArrayItem(container, cacheEntry);
          }
        }, 3e3);
      }
      __name(enqueForDeletion, "enqueForDeletion");
      var cacheMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Cache",
        create: /* @__PURE__ */ __name(function(core) {
          var dbName = core.schema.name;
          var coreMW = __assign(__assign({}, core), { transaction: /* @__PURE__ */ __name(function(stores, mode, options) {
            var idbtrans = core.transaction(stores, mode, options);
            if (mode === "readwrite") {
              var ac_1 = new AbortController();
              var signal = ac_1.signal;
              var endTransaction = /* @__PURE__ */ __name(function(wasCommitted) {
                return function() {
                  ac_1.abort();
                  if (mode === "readwrite") {
                    var affectedSubscribers_1 = /* @__PURE__ */ new Set();
                    for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {
                      var storeName = stores_1[_i];
                      var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                      if (tblCache) {
                        var table = core.table(storeName);
                        var ops = tblCache.optimisticOps.filter(function(op) {
                          return op.trans === idbtrans;
                        });
                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                          for (var _a9 = 0, _b = Object.values(tblCache.queries.query); _a9 < _b.length; _a9++) {
                            var entries = _b[_a9];
                            for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                              var entry = _d[_c];
                              if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                delArrayItem(entries, entry);
                                entry.subscribers.forEach(function(requery) {
                                  return affectedSubscribers_1.add(requery);
                                });
                              }
                            }
                          }
                        } else if (ops.length > 0) {
                          tblCache.optimisticOps = tblCache.optimisticOps.filter(function(op) {
                            return op.trans !== idbtrans;
                          });
                          for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                            var entries = _f[_e];
                            for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                              var entry = _h[_g];
                              if (entry.res != null && idbtrans.mutatedParts) {
                                if (wasCommitted && !entry.dirty) {
                                  var freezeResults = Object.isFrozen(entry.res);
                                  var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                  if (entry.dirty) {
                                    delArrayItem(entries, entry);
                                    entry.subscribers.forEach(function(requery) {
                                      return affectedSubscribers_1.add(requery);
                                    });
                                  } else if (modRes !== entry.res) {
                                    entry.res = modRes;
                                    entry.promise = DexiePromise.resolve({ result: modRes });
                                  }
                                } else {
                                  if (entry.dirty) {
                                    delArrayItem(entries, entry);
                                  }
                                  entry.subscribers.forEach(function(requery) {
                                    return affectedSubscribers_1.add(requery);
                                  });
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    affectedSubscribers_1.forEach(function(requery) {
                      return requery();
                    });
                  }
                };
              }, "endTransaction");
              idbtrans.addEventListener("abort", endTransaction(false), {
                signal
              });
              idbtrans.addEventListener("error", endTransaction(false), {
                signal
              });
              idbtrans.addEventListener("complete", endTransaction(true), {
                signal
              });
            }
            return idbtrans;
          }, "transaction"), table: /* @__PURE__ */ __name(function(tableName) {
            var downTable = core.table(tableName);
            var primKey = downTable.schema.primaryKey;
            var tableMW = __assign(__assign({}, downTable), { mutate: /* @__PURE__ */ __name(function(req) {
              var trans = PSD.trans;
              if (primKey.outbound || trans.db._options.cache === "disabled" || trans.explicit) {
                return downTable.mutate(req);
              }
              var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
              if (!tblCache)
                return downTable.mutate(req);
              var promise = downTable.mutate(req);
              if ((req.type === "add" || req.type === "put") && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function(key) {
                return key == null;
              }))) {
                promise.then(function(res) {
                  var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function(value, i) {
                    var _a9;
                    var valueWithKey = ((_a9 = primKey.keyPath) === null || _a9 === void 0 ? void 0 : _a9.includes(".")) ? deepClone(value) : __assign({}, value);
                    setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                    return valueWithKey;
                  }) });
                  var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                  tblCache.optimisticOps.push(adjustedReq);
                  queueMicrotask(function() {
                    return req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  });
                });
              } else {
                tblCache.optimisticOps.push(req);
                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                promise.then(function(res) {
                  if (res.numFailures > 0) {
                    delArrayItem(tblCache.optimisticOps, req);
                    var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                    if (adjustedReq) {
                      tblCache.optimisticOps.push(adjustedReq);
                    }
                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  }
                });
                promise.catch(function() {
                  delArrayItem(tblCache.optimisticOps, req);
                  req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                });
              }
              return promise;
            }, "mutate"), query: /* @__PURE__ */ __name(function(req) {
              var _a9;
              if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                return downTable.query(req);
              var freezeResults = ((_a9 = PSD.trans) === null || _a9 === void 0 ? void 0 : _a9.db._options.cache) === "immutable";
              var _b = PSD, requery = _b.requery, signal = _b.signal;
              var _c = findCompatibleQuery(dbName, tableName, "query", req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
              if (cacheEntry && exactMatch) {
                cacheEntry.obsSet = req.obsSet;
              } else {
                var promise = downTable.query(req).then(function(res) {
                  var result = res.result;
                  if (cacheEntry)
                    cacheEntry.res = result;
                  if (freezeResults) {
                    for (var i = 0, l = result.length; i < l; ++i) {
                      Object.freeze(result[i]);
                    }
                    Object.freeze(result);
                  } else {
                    res.result = deepClone(result);
                  }
                  return res;
                }).catch(function(error) {
                  if (container && cacheEntry)
                    delArrayItem(container, cacheEntry);
                  return Promise.reject(error);
                });
                cacheEntry = {
                  obsSet: req.obsSet,
                  promise,
                  subscribers: /* @__PURE__ */ new Set(),
                  type: "query",
                  req,
                  dirty: false
                };
                if (container) {
                  container.push(cacheEntry);
                } else {
                  container = [cacheEntry];
                  if (!tblCache) {
                    tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                      queries: {
                        query: {},
                        count: {}
                      },
                      objs: /* @__PURE__ */ new Map(),
                      optimisticOps: [],
                      unsignaledParts: {}
                    };
                  }
                  tblCache.queries.query[req.query.index.name || ""] = container;
                }
              }
              subscribeToCacheEntry(cacheEntry, container, requery, signal);
              return cacheEntry.promise.then(function(res) {
                return {
                  result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults)
                };
              });
            }, "query") });
            return tableMW;
          }, "table") });
          return coreMW;
        }, "create")
      };
      function vipify(target, vipDb) {
        return new Proxy(target, {
          get: /* @__PURE__ */ __name(function(target2, prop, receiver) {
            if (prop === "db")
              return vipDb;
            return Reflect.get(target2, prop, receiver);
          }, "get")
        });
      }
      __name(vipify, "vipify");
      var Dexie$1 = function() {
        function Dexie3(name, options) {
          var _this = this;
          this._middlewares = {};
          this.verno = 0;
          var deps = Dexie3.dependencies;
          this._options = options = __assign({
            addons: Dexie3.addons,
            autoOpen: true,
            indexedDB: deps.indexedDB,
            IDBKeyRange: deps.IDBKeyRange,
            cache: "cloned"
          }, options);
          this._deps = {
            indexedDB: options.indexedDB,
            IDBKeyRange: options.IDBKeyRange
          };
          var addons = options.addons;
          this._dbSchema = {};
          this._versions = [];
          this._storeNames = [];
          this._allTables = {};
          this.idbdb = null;
          this._novip = this;
          var state = {
            dbOpenError: null,
            isBeingOpened: false,
            onReadyBeingFired: null,
            openComplete: false,
            dbReadyResolve: nop,
            dbReadyPromise: null,
            cancelOpen: nop,
            openCanceller: null,
            autoSchema: true,
            PR1398_maxLoop: 3,
            autoOpen: options.autoOpen
          };
          state.dbReadyPromise = new DexiePromise(function(resolve) {
            state.dbReadyResolve = resolve;
          });
          state.openCanceller = new DexiePromise(function(_, reject) {
            state.cancelOpen = reject;
          });
          this._state = state;
          this.name = name;
          this.on = Events2(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
          this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
            return function(subscriber, bSticky) {
              Dexie3.vip(function() {
                var state2 = _this._state;
                if (state2.openComplete) {
                  if (!state2.dbOpenError)
                    DexiePromise.resolve().then(subscriber);
                  if (bSticky)
                    subscribe(subscriber);
                } else if (state2.onReadyBeingFired) {
                  state2.onReadyBeingFired.push(subscriber);
                  if (bSticky)
                    subscribe(subscriber);
                } else {
                  subscribe(subscriber);
                  var db_1 = _this;
                  if (!bSticky)
                    subscribe(/* @__PURE__ */ __name(function unsubscribe() {
                      db_1.on.ready.unsubscribe(subscriber);
                      db_1.on.ready.unsubscribe(unsubscribe);
                    }, "unsubscribe"));
                }
              });
            };
          });
          this.Collection = createCollectionConstructor(this);
          this.Table = createTableConstructor(this);
          this.Transaction = createTransactionConstructor(this);
          this.Version = createVersionConstructor(this);
          this.WhereClause = createWhereClauseConstructor(this);
          this.on("versionchange", function(ev) {
            if (ev.newVersion > 0)
              console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
            else
              console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
            _this.close({ disableAutoOpen: false });
          });
          this.on("blocked", function(ev) {
            if (!ev.newVersion || ev.newVersion < ev.oldVersion)
              console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
            else
              console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
          });
          this._maxKey = getMaxKey(options.IDBKeyRange);
          this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
            return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
          };
          this._fireOnBlocked = function(ev) {
            _this.on("blocked").fire(ev);
            connections.filter(function(c) {
              return c.name === _this.name && c !== _this && !c._state.vcFired;
            }).map(function(c) {
              return c.on("versionchange").fire(ev);
            });
          };
          this.use(cacheExistingValuesMiddleware);
          this.use(cacheMiddleware);
          this.use(observabilityMiddleware);
          this.use(virtualIndexMiddleware);
          this.use(hooksMiddleware);
          var vipDB = new Proxy(this, {
            get: /* @__PURE__ */ __name(function(_, prop, receiver) {
              if (prop === "_vip")
                return true;
              if (prop === "table")
                return function(tableName) {
                  return vipify(_this.table(tableName), vipDB);
                };
              var rv = Reflect.get(_, prop, receiver);
              if (rv instanceof Table)
                return vipify(rv, vipDB);
              if (prop === "tables")
                return rv.map(function(t) {
                  return vipify(t, vipDB);
                });
              if (prop === "_createTransaction")
                return function() {
                  var tx = rv.apply(this, arguments);
                  return vipify(tx, vipDB);
                };
              return rv;
            }, "get")
          });
          this.vip = vipDB;
          addons.forEach(function(addon) {
            return addon(_this);
          });
        }
        __name(Dexie3, "Dexie");
        Dexie3.prototype.version = function(versionNumber) {
          if (isNaN(versionNumber) || versionNumber < 0.1)
            throw new exceptions.Type("Given version is not a positive number");
          versionNumber = Math.round(versionNumber * 10) / 10;
          if (this.idbdb || this._state.isBeingOpened)
            throw new exceptions.Schema("Cannot add version when database is open");
          this.verno = Math.max(this.verno, versionNumber);
          var versions = this._versions;
          var versionInstance = versions.filter(function(v) {
            return v._cfg.version === versionNumber;
          })[0];
          if (versionInstance)
            return versionInstance;
          versionInstance = new this.Version(versionNumber);
          versions.push(versionInstance);
          versions.sort(lowerVersionFirst);
          versionInstance.stores({});
          this._state.autoSchema = false;
          return versionInstance;
        };
        Dexie3.prototype._whenReady = function(fn) {
          var _this = this;
          return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function(resolve, reject) {
            if (_this._state.openComplete) {
              return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
            }
            if (!_this._state.isBeingOpened) {
              if (!_this._state.autoOpen) {
                reject(new exceptions.DatabaseClosed());
                return;
              }
              _this.open().catch(nop);
            }
            _this._state.dbReadyPromise.then(resolve, reject);
          }).then(fn);
        };
        Dexie3.prototype.use = function(_a9) {
          var stack = _a9.stack, create7 = _a9.create, level = _a9.level, name = _a9.name;
          if (name)
            this.unuse({ stack, name });
          var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
          middlewares.push({ stack, create: create7, level: level == null ? 10 : level, name });
          middlewares.sort(function(a, b) {
            return a.level - b.level;
          });
          return this;
        };
        Dexie3.prototype.unuse = function(_a9) {
          var stack = _a9.stack, name = _a9.name, create7 = _a9.create;
          if (stack && this._middlewares[stack]) {
            this._middlewares[stack] = this._middlewares[stack].filter(function(mw) {
              return create7 ? mw.create !== create7 : name ? mw.name !== name : false;
            });
          }
          return this;
        };
        Dexie3.prototype.open = function() {
          var _this = this;
          return usePSD(
            globalPSD,
            function() {
              return dexieOpen(_this);
            }
          );
        };
        Dexie3.prototype._close = function() {
          var state = this._state;
          var idx = connections.indexOf(this);
          if (idx >= 0)
            connections.splice(idx, 1);
          if (this.idbdb) {
            try {
              this.idbdb.close();
            } catch (e) {
            }
            this.idbdb = null;
          }
          if (!state.isBeingOpened) {
            state.dbReadyPromise = new DexiePromise(function(resolve) {
              state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function(_, reject) {
              state.cancelOpen = reject;
            });
          }
        };
        Dexie3.prototype.close = function(_a9) {
          var _b = _a9 === void 0 ? { disableAutoOpen: true } : _a9, disableAutoOpen = _b.disableAutoOpen;
          var state = this._state;
          if (disableAutoOpen) {
            if (state.isBeingOpened) {
              state.cancelOpen(new exceptions.DatabaseClosed());
            }
            this._close();
            state.autoOpen = false;
            state.dbOpenError = new exceptions.DatabaseClosed();
          } else {
            this._close();
            state.autoOpen = this._options.autoOpen || state.isBeingOpened;
            state.openComplete = false;
            state.dbOpenError = null;
          }
        };
        Dexie3.prototype.delete = function(closeOptions) {
          var _this = this;
          if (closeOptions === void 0) {
            closeOptions = { disableAutoOpen: true };
          }
          var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== "object";
          var state = this._state;
          return new DexiePromise(function(resolve, reject) {
            var doDelete = /* @__PURE__ */ __name(function() {
              _this.close(closeOptions);
              var req = _this._deps.indexedDB.deleteDatabase(_this.name);
              req.onsuccess = wrap(function() {
                _onDatabaseDeleted(_this._deps, _this.name);
                resolve();
              });
              req.onerror = eventRejectHandler(reject);
              req.onblocked = _this._fireOnBlocked;
            }, "doDelete");
            if (hasInvalidArguments)
              throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
            if (state.isBeingOpened) {
              state.dbReadyPromise.then(doDelete);
            } else {
              doDelete();
            }
          });
        };
        Dexie3.prototype.backendDB = function() {
          return this.idbdb;
        };
        Dexie3.prototype.isOpen = function() {
          return this.idbdb !== null;
        };
        Dexie3.prototype.hasBeenClosed = function() {
          var dbOpenError = this._state.dbOpenError;
          return dbOpenError && dbOpenError.name === "DatabaseClosed";
        };
        Dexie3.prototype.hasFailed = function() {
          return this._state.dbOpenError !== null;
        };
        Dexie3.prototype.dynamicallyOpened = function() {
          return this._state.autoSchema;
        };
        Object.defineProperty(Dexie3.prototype, "tables", {
          get: /* @__PURE__ */ __name(function() {
            var _this = this;
            return keys3(this._allTables).map(function(name) {
              return _this._allTables[name];
            });
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Dexie3.prototype.transaction = function() {
          var args2 = extractTransactionArgs.apply(this, arguments);
          return this._transaction.apply(this, args2);
        };
        Dexie3.prototype._transaction = function(mode, tables, scopeFunc) {
          var _this = this;
          var parentTransaction = PSD.trans;
          if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
            parentTransaction = null;
          var onlyIfCompatible = mode.indexOf("?") !== -1;
          mode = mode.replace("!", "").replace("?", "");
          var idbMode, storeNames;
          try {
            storeNames = tables.map(function(table) {
              var storeName = table instanceof _this.Table ? table.name : table;
              if (typeof storeName !== "string")
                throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
              return storeName;
            });
            if (mode == "r" || mode === READONLY)
              idbMode = READONLY;
            else if (mode == "rw" || mode == READWRITE)
              idbMode = READWRITE;
            else
              throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
            if (parentTransaction) {
              if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                if (onlyIfCompatible) {
                  parentTransaction = null;
                } else
                  throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              }
              if (parentTransaction) {
                storeNames.forEach(function(storeName) {
                  if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                    if (onlyIfCompatible) {
                      parentTransaction = null;
                    } else
                      throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                  }
                });
              }
              if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                parentTransaction = null;
              }
            }
          } catch (e) {
            return parentTransaction ? parentTransaction._promise(null, function(_, reject) {
              reject(e);
            }) : rejection(e);
          }
          var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
          return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
            return _this._whenReady(enterTransaction);
          }) : this._whenReady(enterTransaction);
        };
        Dexie3.prototype.table = function(tableName) {
          if (!hasOwn(this._allTables, tableName)) {
            throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
          }
          return this._allTables[tableName];
        };
        return Dexie3;
      }();
      var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
      var Observable8 = function() {
        function Observable9(subscribe) {
          this._subscribe = subscribe;
        }
        __name(Observable9, "Observable");
        Observable9.prototype.subscribe = function(x, error, complete) {
          return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
        };
        Observable9.prototype[symbolObservable] = function() {
          return this;
        };
        return Observable9;
      }();
      var domDeps;
      try {
        domDeps = {
          indexedDB: _global2.indexedDB || _global2.mozIndexedDB || _global2.webkitIndexedDB || _global2.msIndexedDB,
          IDBKeyRange: _global2.IDBKeyRange || _global2.webkitIDBKeyRange
        };
      } catch (e) {
        domDeps = { indexedDB: null, IDBKeyRange: null };
      }
      function liveQuery2(querier) {
        var hasValue = false;
        var currentValue;
        var observable2 = new Observable8(function(observer) {
          var scopeFuncIsAsync = isAsyncFunction(querier);
          function execute(ctx) {
            var wasRootExec = beginMicroTickScope();
            try {
              if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
              }
              var rv = newScope(querier, ctx);
              if (scopeFuncIsAsync) {
                rv = rv.finally(decrementExpectedAwaits);
              }
              return rv;
            } finally {
              wasRootExec && endMicroTickScope();
            }
          }
          __name(execute, "execute");
          var closed = false;
          var abortController;
          var accumMuts = {};
          var currentObs = {};
          var subscription = {
            get closed() {
              return closed;
            },
            unsubscribe: /* @__PURE__ */ __name(function() {
              if (closed)
                return;
              closed = true;
              if (abortController)
                abortController.abort();
              if (startedListening)
                globalEvents.storagemutated.unsubscribe(mutationListener);
            }, "unsubscribe")
          };
          observer.start && observer.start(subscription);
          var startedListening = false;
          var doQuery = /* @__PURE__ */ __name(function() {
            return execInGlobalContext(_doQuery);
          }, "doQuery");
          function shouldNotify() {
            return obsSetsOverlap(currentObs, accumMuts);
          }
          __name(shouldNotify, "shouldNotify");
          var mutationListener = /* @__PURE__ */ __name(function(parts) {
            extendObservabilitySet(accumMuts, parts);
            if (shouldNotify()) {
              doQuery();
            }
          }, "mutationListener");
          var _doQuery = /* @__PURE__ */ __name(function() {
            if (closed || !domDeps.indexedDB) {
              return;
            }
            accumMuts = {};
            var subscr = {};
            if (abortController)
              abortController.abort();
            abortController = new AbortController();
            var ctx = {
              subscr,
              signal: abortController.signal,
              requery: doQuery,
              querier,
              trans: null
            };
            var ret = execute(ctx);
            Promise.resolve(ret).then(function(result) {
              hasValue = true;
              currentValue = result;
              if (closed || ctx.signal.aborted) {
                return;
              }
              accumMuts = {};
              currentObs = subscr;
              if (!objectIsEmpty(currentObs) && !startedListening) {
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                startedListening = true;
              }
              execInGlobalContext(function() {
                return !closed && observer.next && observer.next(result);
              });
            }, function(err) {
              hasValue = false;
              if (!["DatabaseClosedError", "AbortError"].includes(err === null || err === void 0 ? void 0 : err.name)) {
                if (!closed)
                  execInGlobalContext(function() {
                    if (closed)
                      return;
                    observer.error && observer.error(err);
                  });
              }
            });
          }, "_doQuery");
          setTimeout(doQuery, 0);
          return subscription;
        });
        observable2.hasValue = function() {
          return hasValue;
        };
        observable2.getValue = function() {
          return currentValue;
        };
        return observable2;
      }
      __name(liveQuery2, "liveQuery");
      var Dexie2 = Dexie$1;
      props(Dexie2, __assign(__assign({}, fullNameExceptions), {
        delete: /* @__PURE__ */ __name(function(databaseName) {
          var db = new Dexie2(databaseName, { addons: [] });
          return db.delete();
        }, "delete"),
        exists: /* @__PURE__ */ __name(function(name) {
          return new Dexie2(name, { addons: [] }).open().then(function(db) {
            db.close();
            return true;
          }).catch("NoSuchDatabaseError", function() {
            return false;
          });
        }, "exists"),
        getDatabaseNames: /* @__PURE__ */ __name(function(cb) {
          try {
            return getDatabaseNames(Dexie2.dependencies).then(cb);
          } catch (_a9) {
            return rejection(new exceptions.MissingAPI());
          }
        }, "getDatabaseNames"),
        defineClass: /* @__PURE__ */ __name(function() {
          function Class(content) {
            extend2(this, content);
          }
          __name(Class, "Class");
          return Class;
        }, "defineClass"),
        ignoreTransaction: /* @__PURE__ */ __name(function(scopeFunc) {
          return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
        }, "ignoreTransaction"),
        vip,
        async: /* @__PURE__ */ __name(function(generatorFn) {
          return function() {
            try {
              var rv = awaitIterator(generatorFn.apply(this, arguments));
              if (!rv || typeof rv.then !== "function")
                return DexiePromise.resolve(rv);
              return rv;
            } catch (e) {
              return rejection(e);
            }
          };
        }, "async"),
        spawn: /* @__PURE__ */ __name(function(generatorFn, args2, thiz) {
          try {
            var rv = awaitIterator(generatorFn.apply(thiz, args2 || []));
            if (!rv || typeof rv.then !== "function")
              return DexiePromise.resolve(rv);
            return rv;
          } catch (e) {
            return rejection(e);
          }
        }, "spawn"),
        currentTransaction: {
          get: /* @__PURE__ */ __name(function() {
            return PSD.trans || null;
          }, "get")
        },
        waitFor: /* @__PURE__ */ __name(function(promiseOrFunction, optionalTimeout) {
          var promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie2.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
          return PSD.trans ? PSD.trans.waitFor(promise) : promise;
        }, "waitFor"),
        Promise: DexiePromise,
        debug: {
          get: /* @__PURE__ */ __name(function() {
            return debug21;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            setDebug(value);
          }, "set")
        },
        derive,
        extend: extend2,
        props,
        override,
        Events: Events2,
        on: globalEvents,
        liveQuery: liveQuery2,
        extendObservabilitySet,
        getByKeyPath,
        setByKeyPath,
        delByKeyPath,
        shallowClone,
        deepClone,
        getObjectDiff,
        cmp: cmp2,
        asap: asap$1,
        minKey,
        addons: [],
        connections,
        errnames,
        dependencies: domDeps,
        cache,
        semVer: DEXIE_VERSION,
        version: DEXIE_VERSION.split(".").map(function(n) {
          return parseInt(n);
        }).reduce(function(p, c, i) {
          return p + c / Math.pow(10, i * 2);
        })
      }));
      Dexie2.maxKey = getMaxKey(Dexie2.dependencies.IDBKeyRange);
      if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
          if (!propagatingLocally) {
            var event_1;
            event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
              detail: updatedParts
            });
            propagatingLocally = true;
            dispatchEvent(event_1);
            propagatingLocally = false;
          }
        });
        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a9) {
          var detail = _a9.detail;
          if (!propagatingLocally) {
            propagateLocally(detail);
          }
        });
      }
      function propagateLocally(updateParts) {
        var wasMe = propagatingLocally;
        try {
          propagatingLocally = true;
          globalEvents.storagemutated.fire(updateParts);
          signalSubscribersNow(updateParts, true);
        } finally {
          propagatingLocally = wasMe;
        }
      }
      __name(propagateLocally, "propagateLocally");
      var propagatingLocally = false;
      var bc;
      var createBC = /* @__PURE__ */ __name(function() {
      }, "createBC");
      if (typeof BroadcastChannel !== "undefined") {
        createBC = /* @__PURE__ */ __name(function() {
          bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
          bc.onmessage = function(ev) {
            return ev.data && propagateLocally(ev.data);
          };
        }, "createBC");
        createBC();
        if (typeof bc.unref === "function") {
          bc.unref();
        }
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
          if (!propagatingLocally) {
            bc.postMessage(changedParts);
          }
        });
      }
      if (typeof addEventListener !== "undefined") {
        addEventListener("pagehide", function(event) {
          if (!Dexie$1.disableBfCache && event.persisted) {
            if (debug21)
              console.debug("Dexie: handling persisted pagehide");
            bc === null || bc === void 0 ? void 0 : bc.close();
            for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {
              var db = connections_1[_i];
              db.close({ disableAutoOpen: false });
            }
          }
        });
        addEventListener("pageshow", function(event) {
          if (!Dexie$1.disableBfCache && event.persisted) {
            if (debug21)
              console.debug("Dexie: handling persisted pageshow");
            createBC();
            propagateLocally({ all: new RangeSet3(-Infinity, [[]]) });
          }
        });
      }
      function replacePrefix2(a, b) {
        return new PropModification2({ replacePrefix: [a, b] });
      }
      __name(replacePrefix2, "replacePrefix");
      DexiePromise.rejectionMapper = mapError;
      setDebug(debug21);
      var namedExports = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        Dexie: Dexie$1,
        liveQuery: liveQuery2,
        Entity: Entity2,
        cmp: cmp2,
        PropModSymbol: PropModSymbol2,
        PropModification: PropModification2,
        replacePrefix: replacePrefix2,
        "default": Dexie$1,
        RangeSet: RangeSet3,
        mergeRanges: mergeRanges2,
        rangesOverlap: rangesOverlap2
      });
      __assign(Dexie$1, namedExports, { default: Dexie$1 });
      return Dexie$1;
    });
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports2) {
    "use strict";
    init_process_shim();
    var l = Symbol.for("react.element");
    var n = Symbol.for("react.portal");
    var p = Symbol.for("react.fragment");
    var q = Symbol.for("react.strict_mode");
    var r = Symbol.for("react.profiler");
    var t = Symbol.for("react.provider");
    var u = Symbol.for("react.context");
    var v = Symbol.for("react.forward_ref");
    var w = Symbol.for("react.suspense");
    var x = Symbol.for("react.memo");
    var y = Symbol.for("react.lazy");
    var z = Symbol.iterator;
    function A(a) {
      if (null === a || "object" !== typeof a) return null;
      a = z && a[z] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    __name(A, "A");
    var B = { isMounted: /* @__PURE__ */ __name(function() {
      return false;
    }, "isMounted"), enqueueForceUpdate: /* @__PURE__ */ __name(function() {
    }, "enqueueForceUpdate"), enqueueReplaceState: /* @__PURE__ */ __name(function() {
    }, "enqueueReplaceState"), enqueueSetState: /* @__PURE__ */ __name(function() {
    }, "enqueueSetState") };
    var C = Object.assign;
    var D = {};
    function E(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    __name(E, "E");
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    __name(F, "F");
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    __name(G, "G");
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = true;
    var I = Array.isArray;
    var J = Object.prototype.hasOwnProperty;
    var K = { current: null };
    var L = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, e) {
      var d2, c = {}, k = null, h = null;
      if (null != b) for (d2 in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d2) && !L.hasOwnProperty(d2) && (c[d2] = b[d2]);
      var g = arguments.length - 2;
      if (1 === g) c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps) for (d2 in g = a.defaultProps, g) void 0 === c[d2] && (c[d2] = g[d2]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    __name(M, "M");
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    __name(N, "N");
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l;
    }
    __name(O, "O");
    function escape2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    __name(escape2, "escape");
    var P = /\/+/g;
    function Q(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
    }
    __name(Q, "Q");
    function R(a, b, e, d2, c) {
      var k = typeof a;
      if ("undefined" === k || "boolean" === k) a = null;
      var h = false;
      if (null === a) h = true;
      else switch (k) {
        case "string":
        case "number":
          h = true;
          break;
        case "object":
          switch (a.$$typeof) {
            case l:
            case n:
              h = true;
          }
      }
      if (h) return h = a, c = c(h), a = "" === d2 ? "." + Q(h, 0) : d2, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
        return a2;
      })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      h = 0;
      d2 = "" === d2 ? "." : d2 + ":";
      if (I(a)) for (var g = 0; g < a.length; g++) {
        k = a[g];
        var f = d2 + Q(k, g);
        h += R(k, b, e, f, c);
      }
      else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d2 + Q(k, g++), h += R(k, b, e, f, c);
      else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    __name(R, "R");
    function S(a, b, e) {
      if (null == a) return a;
      var d2 = [], c = 0;
      R(a, d2, "", "", function(a2) {
        return b.call(e, a2, c++);
      });
      return d2;
    }
    __name(S, "S");
    function T(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
        }, function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
        });
        -1 === a._status && (a._status = 0, a._result = b);
      }
      if (1 === a._status) return a._result.default;
      throw a._result;
    }
    __name(T, "T");
    var U = { current: null };
    var V = { transition: null };
    var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    exports2.Children = { map: S, forEach: /* @__PURE__ */ __name(function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, "forEach"), count: /* @__PURE__ */ __name(function(a) {
      var b = 0;
      S(a, function() {
        b++;
      });
      return b;
    }, "count"), toArray: /* @__PURE__ */ __name(function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, "toArray"), only: /* @__PURE__ */ __name(function(a) {
      if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    }, "only") };
    exports2.Component = E;
    exports2.Fragment = p;
    exports2.Profiler = r;
    exports2.PureComponent = G;
    exports2.StrictMode = q;
    exports2.Suspense = w;
    exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports2.cloneElement = function(a, b, e) {
      if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d2 = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (null != b) {
        void 0 !== b.ref && (k = b.ref, h = K.current);
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
        for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d2[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (1 === f) d2.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
        d2.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d2, _owner: h };
    };
    exports2.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t, _context: a };
      return a.Consumer = a;
    };
    exports2.createElement = M;
    exports2.createFactory = function(a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    exports2.createRef = function() {
      return { current: null };
    };
    exports2.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports2.isValidElement = O;
    exports2.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports2.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    exports2.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports2.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports2.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports2.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports2.useDebugValue = function() {
    };
    exports2.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports2.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports2.useId = function() {
      return U.current.useId();
    };
    exports2.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports2.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports2.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports2.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports2.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports2.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports2.useState = function(a) {
      return U.current.useState(a);
    };
    exports2.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports2.useTransition = function() {
      return U.current.useTransition();
    };
    exports2.version = "18.2.0";
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    if (true) {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.min.js
var require_react_jsx_runtime_production_min = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports2) {
    "use strict";
    init_process_shim();
    var f = require_react();
    var k = Symbol.for("react.element");
    var l = Symbol.for("react.fragment");
    var m = Object.prototype.hasOwnProperty;
    var n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
    var p = { key: true, ref: true, __self: true, __source: true };
    function q(c, a, g) {
      var b, d2 = {}, e = null, h = null;
      void 0 !== g && (e = "" + g);
      void 0 !== a.key && (e = "" + a.key);
      void 0 !== a.ref && (h = a.ref);
      for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d2[b] = a[b]);
      if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d2[b] && (d2[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h, props: d2, _owner: n.current };
    }
    __name(q, "q");
    exports2.Fragment = l;
    exports2.jsx = q;
    exports2.jsxs = q;
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    if (true) {
      module2.exports = require_react_jsx_runtime_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS({
  "node_modules/scheduler/cjs/scheduler.production.min.js"(exports2) {
    "use strict";
    init_process_shim();
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d2 = c - 1 >>> 1, e = a[d2];
        if (0 < g(e, b)) a[d2] = b, a[c] = e, c = d2;
        else break a;
      }
    }
    __name(f, "f");
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    __name(h, "h");
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d2 = 0, e = a.length, w = e >>> 1; d2 < w; ) {
          var m = 2 * (d2 + 1) - 1, C = a[m], n = m + 1, x = a[n];
          if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d2] = x, a[n] = c, d2 = n) : (a[d2] = C, a[m] = c, d2 = m);
          else if (n < e && 0 > g(x, c)) a[d2] = x, a[n] = c, d2 = n;
          else break a;
        }
      }
      return b;
    }
    __name(k, "k");
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    __name(g, "g");
    if ("object" === typeof performance && "function" === typeof performance.now) {
      l = performance;
      exports2.unstable_now = function() {
        return l.now();
      };
    } else {
      p = Date, q = p.now();
      exports2.unstable_now = function() {
        return p.now() - q;
      };
    }
    var l;
    var p;
    var q;
    var r = [];
    var t = [];
    var u = 1;
    var v = null;
    var y = 3;
    var z = false;
    var A = false;
    var B = false;
    var D = "function" === typeof setTimeout ? setTimeout : null;
    var E = "function" === typeof clearTimeout ? clearTimeout : null;
    var F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t); null !== b; ) {
        if (null === b.callback) k(t);
        else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
        else break;
        b = h(t);
      }
    }
    __name(G, "G");
    function H(a) {
      B = false;
      G(a);
      if (!A) if (null !== h(r)) A = true, I(J);
      else {
        var b = h(t);
        null !== b && K(H, b.startTime - a);
      }
    }
    __name(H, "H");
    function J(a, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c = y;
      try {
        G(b);
        for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d2 = v.callback;
          if ("function" === typeof d2) {
            v.callback = null;
            y = v.priorityLevel;
            var e = d2(v.expirationTime <= b);
            b = exports2.unstable_now();
            "function" === typeof e ? v.callback = e : v === h(r) && k(r);
            G(b);
          } else k(r);
          v = h(r);
        }
        if (null !== v) var w = true;
        else {
          var m = h(t);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y = c, z = false;
      }
    }
    __name(J, "J");
    var N = false;
    var O = null;
    var L = -1;
    var P = 5;
    var Q = -1;
    function M() {
      return exports2.unstable_now() - Q < P ? false : true;
    }
    __name(M, "M");
    function R() {
      if (null !== O) {
        var a = exports2.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    __name(R, "R");
    var S;
    if ("function" === typeof F) S = /* @__PURE__ */ __name(function() {
      F(R);
    }, "S");
    else if ("undefined" !== typeof MessageChannel) {
      T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = /* @__PURE__ */ __name(function() {
        U.postMessage(null);
      }, "S");
    } else S = /* @__PURE__ */ __name(function() {
      D(R, 0);
    }, "S");
    var T;
    var U;
    function I(a) {
      O = a;
      N || (N = true, S());
    }
    __name(I, "I");
    function K(a, b) {
      L = D(function() {
        a(exports2.unstable_now());
      }, b);
    }
    __name(K, "K");
    exports2.unstable_IdlePriority = 5;
    exports2.unstable_ImmediatePriority = 1;
    exports2.unstable_LowPriority = 4;
    exports2.unstable_NormalPriority = 3;
    exports2.unstable_Profiling = null;
    exports2.unstable_UserBlockingPriority = 2;
    exports2.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports2.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports2.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports2.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports2.unstable_getFirstCallbackNode = function() {
      return h(r);
    };
    exports2.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports2.unstable_pauseExecution = function() {
    };
    exports2.unstable_requestPaint = function() {
    };
    exports2.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports2.unstable_scheduleCallback = function(a, b, c) {
      var d2 = exports2.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d2 + c : d2) : c = d2;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d2 ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d2))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
      return a;
    };
    exports2.unstable_shouldYield = M;
    exports2.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    if (true) {
      module2.exports = require_scheduler_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react-dom/cjs/react-dom.production.min.js
var require_react_dom_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom.production.min.js"(exports2) {
    "use strict";
    init_process_shim();
    var aa = require_react();
    var ca = require_scheduler();
    function p(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    __name(p, "p");
    var da = /* @__PURE__ */ new Set();
    var ea = {};
    function fa(a, b) {
      ha(a, b);
      ha(a + "Capture", b);
    }
    __name(fa, "fa");
    function ha(a, b) {
      ea[a] = b;
      for (a = 0; a < b.length; a++) da.add(b[a]);
    }
    __name(ha, "ha");
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
    var ja = Object.prototype.hasOwnProperty;
    var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    var la = {};
    var ma = {};
    function oa(a) {
      if (ja.call(ma, a)) return true;
      if (ja.call(la, a)) return false;
      if (ka.test(a)) return ma[a] = true;
      la[a] = true;
      return false;
    }
    __name(oa, "oa");
    function pa(a, b, c, d2) {
      if (null !== c && 0 === c.type) return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2) return false;
          if (null !== c) return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    __name(pa, "pa");
    function qa(a, b, c, d2) {
      if (null === b || "undefined" === typeof b || pa(a, b, c, d2)) return true;
      if (d2) return false;
      if (null !== c) switch (c.type) {
        case 3:
          return !b;
        case 4:
          return false === b;
        case 5:
          return isNaN(b);
        case 6:
          return isNaN(b) || 1 > b;
      }
      return false;
    }
    __name(qa, "qa");
    function v(a, b, c, d2, e, f, g) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d2;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f;
      this.removeEmptyString = g;
    }
    __name(v, "v");
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z[a] = new v(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      z[b] = new v(b, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z[a] = new v(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z[a] = new v(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z[a] = new v(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z[a] = new v(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    __name(sa, "sa");
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ra,
        sa
      );
      z[b] = new v(b, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b, c, d2) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      if (null !== e ? 0 !== e.type : d2 || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d2) && (c = null), d2 || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d2 = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d2 ? a.setAttributeNS(d2, b, c) : a.setAttribute(b, c)));
    }
    __name(ta, "ta");
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var va = Symbol.for("react.element");
    var wa = Symbol.for("react.portal");
    var ya = Symbol.for("react.fragment");
    var za = Symbol.for("react.strict_mode");
    var Aa = Symbol.for("react.profiler");
    var Ba = Symbol.for("react.provider");
    var Ca = Symbol.for("react.context");
    var Da = Symbol.for("react.forward_ref");
    var Ea = Symbol.for("react.suspense");
    var Fa = Symbol.for("react.suspense_list");
    var Ga = Symbol.for("react.memo");
    var Ha = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    Symbol.for("react.debug_trace_mode");
    var Ia = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.cache");
    Symbol.for("react.tracing_marker");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a) return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    __name(Ka, "Ka");
    var A = Object.assign;
    var La;
    function Ma(a) {
      if (void 0 === La) try {
        throw Error();
      } catch (c) {
        var b = c.stack.trim().match(/\n( *(at )?)/);
        La = b && b[1] || "";
      }
      return "\n" + La + a;
    }
    __name(Ma, "Ma");
    var Na = false;
    function Oa(a, b) {
      if (!a || Na) return "";
      Na = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b) if (b = /* @__PURE__ */ __name(function() {
          throw Error();
        }, "b"), Object.defineProperty(b.prototype, "props", { set: /* @__PURE__ */ __name(function() {
          throw Error();
        }, "set") }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b, []);
          } catch (l) {
            var d2 = l;
          }
          Reflect.construct(a, [], b);
        } else {
          try {
            b.call();
          } catch (l) {
            d2 = l;
          }
          a.call(b.prototype);
        }
        else {
          try {
            throw Error();
          } catch (l) {
            d2 = l;
          }
          a();
        }
      } catch (l) {
        if (l && d2 && "string" === typeof l.stack) {
          for (var e = l.stack.split("\n"), f = d2.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
          for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
            if (1 !== g || 1 !== h) {
              do
                if (g--, h--, 0 > h || e[g] !== f[h]) {
                  var k = "\n" + e[g].replace(" at new ", " at ");
                  a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                  return k;
                }
              while (1 <= g && 0 <= h);
            }
            break;
          }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    __name(Oa, "Oa");
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, false), a;
        case 11:
          return a = Oa(a.type.render, false), a;
        case 1:
          return a = Oa(a.type, true), a;
        default:
          return "";
      }
    }
    __name(Pa, "Pa");
    function Qa(a) {
      if (null == a) return null;
      if ("function" === typeof a) return a.displayName || a.name || null;
      if ("string" === typeof a) return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a) switch (a.$$typeof) {
        case Ca:
          return (a.displayName || "Context") + ".Consumer";
        case Ba:
          return (a._context.displayName || "Context") + ".Provider";
        case Da:
          var b = a.render;
          a = a.displayName;
          a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          return a;
        case Ga:
          return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
        case Ha:
          b = a._payload;
          a = a._init;
          try {
            return Qa(a(b));
          } catch (c) {
          }
      }
      return null;
    }
    __name(Qa, "Qa");
    function Ra(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b) return b.displayName || b.name || null;
          if ("string" === typeof b) return b;
      }
      return null;
    }
    __name(Ra, "Ra");
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    __name(Sa, "Sa");
    function Ta(a) {
      var b = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    __name(Ta, "Ta");
    function Ua(a) {
      var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d2 = "" + a[b];
      if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
        var e = c.get, f = c.set;
        Object.defineProperty(a, b, { configurable: true, get: /* @__PURE__ */ __name(function() {
          return e.call(this);
        }, "get"), set: /* @__PURE__ */ __name(function(a2) {
          d2 = "" + a2;
          f.call(this, a2);
        }, "set") });
        Object.defineProperty(a, b, { enumerable: c.enumerable });
        return { getValue: /* @__PURE__ */ __name(function() {
          return d2;
        }, "getValue"), setValue: /* @__PURE__ */ __name(function(a2) {
          d2 = "" + a2;
        }, "setValue"), stopTracking: /* @__PURE__ */ __name(function() {
          a._valueTracker = null;
          delete a[b];
        }, "stopTracking") };
      }
    }
    __name(Ua, "Ua");
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    __name(Va, "Va");
    function Wa(a) {
      if (!a) return false;
      var b = a._valueTracker;
      if (!b) return true;
      var c = b.getValue();
      var d2 = "";
      a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d2;
      return a !== c ? (b.setValue(a), true) : false;
    }
    __name(Wa, "Wa");
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a) return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    __name(Xa, "Xa");
    function Ya(a, b) {
      var c = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
    }
    __name(Ya, "Ya");
    function Za(a, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue, d2 = null != b.checked ? b.checked : b.defaultChecked;
      c = Sa(null != b.value ? b.value : c);
      a._wrapperState = { initialChecked: d2, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    __name(Za, "Za");
    function ab(a, b) {
      b = b.checked;
      null != b && ta(a, "checked", b, false);
    }
    __name(ab, "ab");
    function bb(a, b) {
      ab(a, b);
      var c = Sa(b.value), d2 = b.type;
      if (null != c) if ("number" === d2) {
        if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
      } else a.value !== "" + c && (a.value = "" + c);
      else if ("submit" === d2 || "reset" === d2) {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
    }
    __name(bb, "bb");
    function db(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d2 = b.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b.value && null !== b.value)) return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      "" !== c && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c && (a.name = c);
    }
    __name(db, "db");
    function cb(a, b, c) {
      if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    __name(cb, "cb");
    var eb = Array.isArray;
    function fb(a, b, c, d2) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d2 && (a[c].defaultSelected = true);
      } else {
        c = "" + Sa(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d2 && (a[e].defaultSelected = true);
            return;
          }
          null !== b || a[e].disabled || (b = a[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    __name(fb, "fb");
    function gb(a, b) {
      if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    __name(gb, "gb");
    function hb(a, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b) throw Error(p(92));
          if (eb(c)) {
            if (1 < c.length) throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a._wrapperState = { initialValue: Sa(c) };
    }
    __name(hb, "hb");
    function ib(a, b) {
      var c = Sa(b.value), d2 = Sa(b.defaultValue);
      null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
      null != d2 && (a.defaultValue = "" + d2);
    }
    __name(ib, "ib");
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
    }
    __name(jb, "jb");
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    __name(kb, "kb");
    function lb(a, b) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
    }
    __name(lb, "lb");
    var mb;
    var nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d2, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d2, e);
        });
      } : a;
    }(function(a, b) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
        for (; b.firstChild; ) a.appendChild(b.firstChild);
      }
    });
    function ob(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    __name(ob, "ob");
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b] = pb[a];
      });
    });
    function rb(a, b, c) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
    }
    __name(rb, "rb");
    function sb(a, b) {
      a = a.style;
      for (var c in b) if (b.hasOwnProperty(c)) {
        var d2 = 0 === c.indexOf("--"), e = rb(c, b[c], d2);
        "float" === c && (c = "cssFloat");
        d2 ? a.setProperty(c, e) : a[c] = e;
      }
    }
    __name(sb, "sb");
    var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b) {
      if (b) {
        if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children) throw Error(p(60));
          if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
        }
        if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
      }
    }
    __name(ub, "ub");
    function vb(a, b) {
      if (-1 === a.indexOf("-")) return "string" === typeof b.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    __name(vb, "vb");
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    __name(xb, "xb");
    var yb = null;
    var zb = null;
    var Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb) throw Error(p(280));
        var b = a.stateNode;
        b && (b = Db(b), yb(a.stateNode, a.type, b));
      }
    }
    __name(Bb, "Bb");
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    __name(Eb, "Eb");
    function Fb() {
      if (zb) {
        var a = zb, b = Ab;
        Ab = zb = null;
        Bb(a);
        if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
      }
    }
    __name(Fb, "Fb");
    function Gb(a, b) {
      return a(b);
    }
    __name(Gb, "Gb");
    function Hb() {
    }
    __name(Hb, "Hb");
    var Ib = false;
    function Jb(a, b, c) {
      if (Ib) return a(b, c);
      Ib = true;
      try {
        return Gb(a, b, c);
      } finally {
        if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
      }
    }
    __name(Jb, "Jb");
    function Kb(a, b) {
      var c = a.stateNode;
      if (null === c) return null;
      var d2 = Db(c);
      if (null === d2) return null;
      c = d2[b];
      a: switch (b) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
          a = !d2;
          break a;
        default:
          a = false;
      }
      if (a) return null;
      if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
      return c;
    }
    __name(Kb, "Kb");
    var Lb = false;
    if (ia) try {
      Mb = {};
      Object.defineProperty(Mb, "passive", { get: /* @__PURE__ */ __name(function() {
        Lb = true;
      }, "get") });
      window.addEventListener("test", Mb, Mb);
      window.removeEventListener("test", Mb, Mb);
    } catch (a) {
      Lb = false;
    }
    var Mb;
    function Nb(a, b, c, d2, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (m) {
        this.onError(m);
      }
    }
    __name(Nb, "Nb");
    var Ob = false;
    var Pb = null;
    var Qb = false;
    var Rb = null;
    var Sb = { onError: /* @__PURE__ */ __name(function(a) {
      Ob = true;
      Pb = a;
    }, "onError") };
    function Tb(a, b, c, d2, e, f, g, h, k) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    __name(Tb, "Tb");
    function Ub(a, b, c, d2, e, f, g, h, k) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l = Pb;
          Ob = false;
          Pb = null;
        } else throw Error(p(198));
        Qb || (Qb = true, Rb = l);
      }
    }
    __name(Ub, "Ub");
    function Vb(a) {
      var b = a, c = a;
      if (a.alternate) for (; b.return; ) b = b.return;
      else {
        a = b;
        do
          b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
        while (a);
      }
      return 3 === b.tag ? c : null;
    }
    __name(Vb, "Vb");
    function Wb(a) {
      if (13 === a.tag) {
        var b = a.memoizedState;
        null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
        if (null !== b) return b.dehydrated;
      }
      return null;
    }
    __name(Wb, "Wb");
    function Xb(a) {
      if (Vb(a) !== a) throw Error(p(188));
    }
    __name(Xb, "Xb");
    function Yb(a) {
      var b = a.alternate;
      if (!b) {
        b = Vb(a);
        if (null === b) throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d2 = b; ; ) {
        var e = c.return;
        if (null === e) break;
        var f = e.alternate;
        if (null === f) {
          d2 = e.return;
          if (null !== d2) {
            c = d2;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c) return Xb(e), a;
            if (f === d2) return Xb(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d2.return) c = e, d2 = f;
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c) {
              g = true;
              c = e;
              d2 = f;
              break;
            }
            if (h === d2) {
              g = true;
              d2 = e;
              c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = true;
                c = f;
                d2 = e;
                break;
              }
              if (h === d2) {
                g = true;
                d2 = f;
                c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g) throw Error(p(189));
          }
        }
        if (c.alternate !== d2) throw Error(p(190));
      }
      if (3 !== c.tag) throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    __name(Yb, "Yb");
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    __name(Zb, "Zb");
    function $b(a) {
      if (5 === a.tag || 6 === a.tag) return a;
      for (a = a.child; null !== a; ) {
        var b = $b(a);
        if (null !== b) return b;
        a = a.sibling;
      }
      return null;
    }
    __name($b, "$b");
    var ac = ca.unstable_scheduleCallback;
    var bc = ca.unstable_cancelCallback;
    var cc = ca.unstable_shouldYield;
    var dc = ca.unstable_requestPaint;
    var B = ca.unstable_now;
    var ec = ca.unstable_getCurrentPriorityLevel;
    var fc = ca.unstable_ImmediatePriority;
    var gc = ca.unstable_UserBlockingPriority;
    var hc = ca.unstable_NormalPriority;
    var ic = ca.unstable_LowPriority;
    var jc = ca.unstable_IdlePriority;
    var kc = null;
    var lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot) try {
        lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
      } catch (b) {
      }
    }
    __name(mc, "mc");
    var oc = Math.clz32 ? Math.clz32 : nc;
    var pc = Math.log;
    var qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    __name(nc, "nc");
    var rc = 64;
    var sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    __name(tc, "tc");
    function uc(a, b) {
      var c = a.pendingLanes;
      if (0 === c) return 0;
      var d2 = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
      if (0 !== g) {
        var h = g & ~e;
        0 !== h ? d2 = tc(h) : (f &= g, 0 !== f && (d2 = tc(f)));
      } else g = c & ~e, 0 !== g ? d2 = tc(g) : 0 !== f && (d2 = tc(f));
      if (0 === d2) return 0;
      if (0 !== b && b !== d2 && 0 === (b & e) && (e = d2 & -d2, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
      0 !== (d2 & 4) && (d2 |= c & 16);
      b = a.entangledLanes;
      if (0 !== b) for (a = a.entanglements, b &= d2; 0 < b; ) c = 31 - oc(b), e = 1 << c, d2 |= a[c], b &= ~e;
      return d2;
    }
    __name(uc, "uc");
    function vc(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    __name(vc, "vc");
    function wc(a, b) {
      for (var c = a.suspendedLanes, d2 = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
        var g = 31 - oc(f), h = 1 << g, k = e[g];
        if (-1 === k) {
          if (0 === (h & c) || 0 !== (h & d2)) e[g] = vc(h, b);
        } else k <= b && (a.expiredLanes |= h);
        f &= ~h;
      }
    }
    __name(wc, "wc");
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    __name(xc, "xc");
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    __name(yc, "yc");
    function zc(a) {
      for (var b = [], c = 0; 31 > c; c++) b.push(a);
      return b;
    }
    __name(zc, "zc");
    function Ac(a, b, c) {
      a.pendingLanes |= b;
      536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b = 31 - oc(b);
      a[b] = c;
    }
    __name(Ac, "Ac");
    function Bc(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b;
      a.mutableReadLanes &= b;
      a.entangledLanes &= b;
      b = a.entanglements;
      var d2 = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc(c), f = 1 << e;
        b[e] = 0;
        d2[e] = -1;
        a[e] = -1;
        c &= ~f;
      }
    }
    __name(Bc, "Bc");
    function Cc(a, b) {
      var c = a.entangledLanes |= b;
      for (a = a.entanglements; c; ) {
        var d2 = 31 - oc(c), e = 1 << d2;
        e & b | a[d2] & b && (a[d2] |= b);
        c &= ~e;
      }
    }
    __name(Cc, "Cc");
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    __name(Dc, "Dc");
    var Ec;
    var Fc;
    var Gc;
    var Hc;
    var Ic;
    var Jc = false;
    var Kc = [];
    var Lc = null;
    var Mc = null;
    var Nc = null;
    var Oc = /* @__PURE__ */ new Map();
    var Pc = /* @__PURE__ */ new Map();
    var Qc = [];
    var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    __name(Sc, "Sc");
    function Tc(a, b, c, d2, e, f) {
      if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d2, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
      a.eventSystemFlags |= d2;
      b = a.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a;
    }
    __name(Tc, "Tc");
    function Uc(a, b, c, d2, e) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a, b, c, d2, e), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b, c, d2, e), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b, c, d2, e), true;
        case "pointerover":
          var f = e.pointerId;
          Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d2, e));
          return true;
        case "gotpointercapture":
          return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d2, e)), true;
      }
      return false;
    }
    __name(Uc, "Uc");
    function Vc(a) {
      var b = Wc(a.target);
      if (null !== b) {
        var c = Vb(b);
        if (null !== c) {
          if (b = c.tag, 13 === b) {
            if (b = Wb(c), null !== b) {
              a.blockedOn = b;
              Ic(a.priority, function() {
                Gc(c);
              });
              return;
            }
          } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    __name(Vc, "Vc");
    function Xc(a) {
      if (null !== a.blockedOn) return false;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (null === c) {
          c = a.nativeEvent;
          var d2 = new c.constructor(c.type, c);
          wb = d2;
          c.target.dispatchEvent(d2);
          wb = null;
        } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
        b.shift();
      }
      return true;
    }
    __name(Xc, "Xc");
    function Zc(a, b, c) {
      Xc(a) && c.delete(b);
    }
    __name(Zc, "Zc");
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    __name($c, "$c");
    function ad(a, b) {
      a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    __name(ad, "ad");
    function bd(a) {
      function b(b2) {
        return ad(b2, a);
      }
      __name(b, "b");
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c = 1; c < Kc.length; c++) {
          var d2 = Kc[c];
          d2.blockedOn === a && (d2.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b);
      Pc.forEach(b);
      for (c = 0; c < Qc.length; c++) d2 = Qc[c], d2.blockedOn === a && (d2.blockedOn = null);
      for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
    }
    __name(bd, "bd");
    var cd = ua.ReactCurrentBatchConfig;
    var dd = true;
    function ed(a, b, c, d2) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b, c, d2);
      } finally {
        C = e, cd.transition = f;
      }
    }
    __name(ed, "ed");
    function gd(a, b, c, d2) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b, c, d2);
      } finally {
        C = e, cd.transition = f;
      }
    }
    __name(gd, "gd");
    function fd(a, b, c, d2) {
      if (dd) {
        var e = Yc(a, b, c, d2);
        if (null === e) hd(a, b, d2, id, c), Sc(a, d2);
        else if (Uc(e, a, b, c, d2)) d2.stopPropagation();
        else if (Sc(a, d2), b & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e; ) {
            var f = Cb(e);
            null !== f && Ec(f);
            f = Yc(a, b, c, d2);
            null === f && hd(a, b, d2, id, c);
            if (f === e) break;
            e = f;
          }
          null !== e && d2.stopPropagation();
        } else hd(a, b, d2, null, c);
      }
    }
    __name(fd, "fd");
    var id = null;
    function Yc(a, b, c, d2) {
      id = null;
      a = xb(d2);
      a = Wc(a);
      if (null !== a) if (b = Vb(a), null === b) a = null;
      else if (c = b.tag, 13 === c) {
        a = Wb(b);
        if (null !== a) return a;
        a = null;
      } else if (3 === c) {
        if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
        a = null;
      } else b !== a && (a = null);
      id = a;
      return null;
    }
    __name(Yc, "Yc");
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    __name(jd, "jd");
    var kd = null;
    var ld = null;
    var md = null;
    function nd() {
      if (md) return md;
      var a, b = ld, c = b.length, d2, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++) ;
      var g = c - a;
      for (d2 = 1; d2 <= g && b[c - d2] === e[f - d2]; d2++) ;
      return md = e.slice(a, 1 < d2 ? 1 - d2 : void 0);
    }
    __name(nd, "nd");
    function od(a) {
      var b = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    __name(od, "od");
    function pd() {
      return true;
    }
    __name(pd, "pd");
    function qd() {
      return false;
    }
    __name(qd, "qd");
    function rd(a) {
      function b(b2, d2, e, f, g) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d2;
        this.nativeEvent = f;
        this.target = g;
        this.currentTarget = null;
        for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
        this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      __name(b, "b");
      A(b.prototype, { preventDefault: /* @__PURE__ */ __name(function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, "preventDefault"), stopPropagation: /* @__PURE__ */ __name(function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, "stopPropagation"), persist: /* @__PURE__ */ __name(function() {
      }, "persist"), isPersistent: pd });
      return b;
    }
    __name(rd, "rd");
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: /* @__PURE__ */ __name(function(a) {
      return a.timeStamp || Date.now();
    }, "timeStamp"), defaultPrevented: 0, isTrusted: 0 };
    var td = rd(sd);
    var ud = A({}, sd, { view: 0, detail: 0 });
    var vd = rd(ud);
    var wd;
    var xd;
    var yd;
    var Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: /* @__PURE__ */ __name(function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, "relatedTarget"), movementX: /* @__PURE__ */ __name(function(a) {
      if ("movementX" in a) return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, "movementX"), movementY: /* @__PURE__ */ __name(function(a) {
      return "movementY" in a ? a.movementY : xd;
    }, "movementY") });
    var Bd = rd(Ad);
    var Cd = A({}, Ad, { dataTransfer: 0 });
    var Dd = rd(Cd);
    var Ed = A({}, ud, { relatedTarget: 0 });
    var Fd = rd(Ed);
    var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Hd = rd(Gd);
    var Id = A({}, sd, { clipboardData: /* @__PURE__ */ __name(function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }, "clipboardData") });
    var Jd = rd(Id);
    var Kd = A({}, sd, { data: 0 });
    var Ld = rd(Kd);
    var Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    var Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
    }
    __name(Pd, "Pd");
    function zd() {
      return Pd;
    }
    __name(zd, "zd");
    var Qd = A({}, ud, { key: /* @__PURE__ */ __name(function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b) return b;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, "key"), code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: /* @__PURE__ */ __name(function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, "charCode"), keyCode: /* @__PURE__ */ __name(function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, "keyCode"), which: /* @__PURE__ */ __name(function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, "which") });
    var Rd = rd(Qd);
    var Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
    var Td = rd(Sd);
    var Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
    var Vd = rd(Ud);
    var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Xd = rd(Wd);
    var Yd = A({}, Ad, {
      deltaX: /* @__PURE__ */ __name(function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      }, "deltaX"),
      deltaY: /* @__PURE__ */ __name(function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      }, "deltaY"),
      deltaZ: 0,
      deltaMode: 0
    });
    var Zd = rd(Yd);
    var $d = [9, 13, 27, 32];
    var ae = ia && "CompositionEvent" in window;
    var be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be;
    var de = ia && (!ae || be && 8 < be && 11 >= be);
    var ee = String.fromCharCode(32);
    var fe = false;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    __name(ge, "ge");
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    __name(he, "he");
    var ie = false;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which) return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    __name(je, "je");
    function ke(a, b) {
      if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length) return b.char;
            if (b.which) return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    __name(ke, "ke");
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
    }
    __name(me, "me");
    function ne(a, b, c, d2) {
      Eb(d2);
      b = oe(b, "onChange");
      0 < b.length && (c = new td("onChange", "change", null, c, d2), a.push({ event: c, listeners: b }));
    }
    __name(ne, "ne");
    var pe = null;
    var qe = null;
    function re(a) {
      se(a, 0);
    }
    __name(re, "re");
    function te(a) {
      var b = ue(a);
      if (Wa(b)) return a;
    }
    __name(te, "te");
    function ve(a, b) {
      if ("change" === a) return b;
    }
    __name(ve, "ve");
    var we = false;
    if (ia) {
      if (ia) {
        ye = "oninput" in document;
        if (!ye) {
          ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    var xe;
    var ye;
    var ze;
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    __name(Ae, "Ae");
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a));
        Jb(re, b);
      }
    }
    __name(Be, "Be");
    function Ce(a, b, c) {
      "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
    }
    __name(Ce, "Ce");
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
    }
    __name(De, "De");
    function Ee(a, b) {
      if ("click" === a) return te(b);
    }
    __name(Ee, "Ee");
    function Fe(a, b) {
      if ("input" === a || "change" === a) return te(b);
    }
    __name(Fe, "Fe");
    function Ge(a, b) {
      return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
    }
    __name(Ge, "Ge");
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b) {
      if (He(a, b)) return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
      var c = Object.keys(a), d2 = Object.keys(b);
      if (c.length !== d2.length) return false;
      for (d2 = 0; d2 < c.length; d2++) {
        var e = c[d2];
        if (!ja.call(b, e) || !He(a[e], b[e])) return false;
      }
      return true;
    }
    __name(Ie, "Ie");
    function Je(a) {
      for (; a && a.firstChild; ) a = a.firstChild;
      return a;
    }
    __name(Je, "Je");
    function Ke(a, b) {
      var c = Je(a);
      a = 0;
      for (var d2; c; ) {
        if (3 === c.nodeType) {
          d2 = a + c.textContent.length;
          if (a <= b && d2 >= b) return { node: c, offset: b - a };
          a = d2;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je(c);
      }
    }
    __name(Ke, "Ke");
    function Le(a, b) {
      return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
    }
    __name(Le, "Le");
    function Me() {
      for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d2) {
          c = false;
        }
        if (c) a = b.contentWindow;
        else break;
        b = Xa(a.document);
      }
      return b;
    }
    __name(Me, "Me");
    function Ne(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
    }
    __name(Ne, "Ne");
    function Oe(a) {
      var b = Me(), c = a.focusedElem, d2 = a.selectionRange;
      if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
        if (null !== d2 && Ne(c)) {
          if (b = d2.start, a = d2.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
          else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e = c.textContent.length, f = Math.min(d2.start, e);
            d2 = void 0 === d2.end ? f : Math.min(d2.end, e);
            !a.extend && f > d2 && (e = d2, d2 = f, f = e);
            e = Ke(c, f);
            var g = Ke(
              c,
              d2
            );
            e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d2 ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        b = [];
        for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c.focus && c.focus();
        for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    __name(Oe, "Oe");
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
    var Qe = null;
    var Re = null;
    var Se = null;
    var Te = false;
    function Ue(a, b, c) {
      var d2 = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
      Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d2 }), b.target = Qe)));
    }
    __name(Ue, "Ue");
    function Ve(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    __name(Ve, "Ve");
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
    var Xe = {};
    var Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a]) return Xe[a];
      if (!We[a]) return a;
      var b = We[a], c;
      for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
      return a;
    }
    __name(Ze, "Ze");
    var $e = Ze("animationend");
    var af = Ze("animationiteration");
    var bf = Ze("animationstart");
    var cf = Ze("transitionend");
    var df = /* @__PURE__ */ new Map();
    var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b) {
      df.set(a, b);
      fa(b, [a]);
    }
    __name(ff, "ff");
    for (gf = 0; gf < ef.length; gf++) {
      hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    var hf;
    var jf;
    var kf;
    var gf;
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
    var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b, c) {
      var d2 = a.type || "unknown-event";
      a.currentTarget = c;
      Ub(d2, b, void 0, a);
      a.currentTarget = null;
    }
    __name(nf, "nf");
    function se(a, b) {
      b = 0 !== (b & 4);
      for (var c = 0; c < a.length; c++) {
        var d2 = a[c], e = d2.event;
        d2 = d2.listeners;
        a: {
          var f = void 0;
          if (b) for (var g = d2.length - 1; 0 <= g; g--) {
            var h = d2[g], k = h.instance, l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
          else for (g = 0; g < d2.length; g++) {
            h = d2[g];
            k = h.instance;
            l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
        }
      }
      if (Qb) throw a = Rb, Qb = false, Rb = null, a;
    }
    __name(se, "se");
    function D(a, b) {
      var c = b[of];
      void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
      var d2 = a + "__bubble";
      c.has(d2) || (pf(b, a, 2, false), c.add(d2));
    }
    __name(D, "D");
    function qf(a, b, c) {
      var d2 = 0;
      b && (d2 |= 4);
      pf(c, a, d2, b);
    }
    __name(qf, "qf");
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b2) {
          "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
        });
        var b = 9 === a.nodeType ? a : a.ownerDocument;
        null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
      }
    }
    __name(sf, "sf");
    function pf(a, b, c, d2) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd;
      }
      c = e.bind(null, b, c, a);
      e = void 0;
      !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
      d2 ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
    }
    __name(pf, "pf");
    function hd(a, b, c, d2, e) {
      var f = d2;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d2) a: for (; ; ) {
        if (null === d2) return;
        var g = d2.tag;
        if (3 === g || 4 === g) {
          var h = d2.stateNode.containerInfo;
          if (h === e || 8 === h.nodeType && h.parentNode === e) break;
          if (4 === g) for (g = d2.return; null !== g; ) {
            var k = g.tag;
            if (3 === k || 4 === k) {
              if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
            }
            g = g.return;
          }
          for (; null !== h; ) {
            g = Wc(h);
            if (null === g) return;
            k = g.tag;
            if (5 === k || 6 === k) {
              d2 = f = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d2 = d2.return;
      }
      Jb(function() {
        var d3 = f, e2 = xb(c), g2 = [];
        a: {
          var h2 = df.get(a);
          if (void 0 !== h2) {
            var k2 = td, n = a;
            switch (a) {
              case "keypress":
                if (0 === od(c)) break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                n = "focus";
                k2 = Fd;
                break;
              case "focusout":
                n = "blur";
                k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (2 === c.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k2 = Hd;
                break;
              case cf:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
            t = [];
            for (var w = d3, u; null !== w; ) {
              u = w;
              var F = u.stateNode;
              5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
              if (J) break;
              w = w.return;
            }
            0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h2 = "mouseover" === a || "pointerover" === a;
            k2 = "mouseout" === a || "pointerout" === a;
            if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
            if (k2 || h2) {
              h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
              if (k2) {
                if (n = c.relatedTarget || c.toElement, k2 = d3, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
              } else k2 = null, n = d3;
              if (k2 !== n) {
                t = Bd;
                F = "onMouseLeave";
                x = "onMouseEnter";
                w = "mouse";
                if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                J = null == k2 ? h2 : ue(k2);
                u = null == n ? h2 : ue(n);
                h2 = new t(F, w + "leave", k2, c, e2);
                h2.target = J;
                h2.relatedTarget = u;
                F = null;
                Wc(e2) === d3 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                J = F;
                if (k2 && n) b: {
                  t = k2;
                  x = n;
                  w = 0;
                  for (u = t; u; u = vf(u)) w++;
                  u = 0;
                  for (F = x; F; F = vf(F)) u++;
                  for (; 0 < w - u; ) t = vf(t), w--;
                  for (; 0 < u - w; ) x = vf(x), u--;
                  for (; w--; ) {
                    if (t === x || null !== x && t === x.alternate) break b;
                    t = vf(t);
                    x = vf(x);
                  }
                  t = null;
                }
                else t = null;
                null !== k2 && wf(g2, h2, k2, t, false);
                null !== n && null !== J && wf(g2, J, n, t, true);
              }
            }
          }
          a: {
            h2 = d3 ? ue(d3) : window;
            k2 = h2.nodeName && h2.nodeName.toLowerCase();
            if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
            else if (me(h2)) if (we) na = Fe;
            else {
              na = De;
              var xa = Ce;
            }
            else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
            if (na && (na = na(a, d3))) {
              ne(g2, na, c, e2);
              break a;
            }
            xa && xa(a, h2, d3);
            "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
          }
          xa = d3 ? ue(d3) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe) break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var $a;
          if (ae) b: {
            switch (a) {
              case "compositionstart":
                var ba = "onCompositionStart";
                break b;
              case "compositionend":
                ba = "onCompositionEnd";
                break b;
              case "compositionupdate":
                ba = "onCompositionUpdate";
                break b;
            }
            ba = void 0;
          }
          else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a, c) : ke(a, c)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d3 }), e2.data = $a);
        }
        se(g2, b);
      });
    }
    __name(hd, "hd");
    function tf(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    __name(tf, "tf");
    function oe(a, b) {
      for (var c = b + "Capture", d2 = []; null !== a; ) {
        var e = a, f = e.stateNode;
        5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d2.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d2.push(tf(a, f, e)));
        a = a.return;
      }
      return d2;
    }
    __name(oe, "oe");
    function vf(a) {
      if (null === a) return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    __name(vf, "vf");
    function wf(a, b, c, d2, e) {
      for (var f = b._reactName, g = []; null !== c && c !== d2; ) {
        var h = c, k = h.alternate, l = h.stateNode;
        if (null !== k && k === d2) break;
        5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
        c = c.return;
      }
      0 !== g.length && a.push({ event: b, listeners: g });
    }
    __name(wf, "wf");
    var xf = /\r\n?/g;
    var yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    __name(zf, "zf");
    function Af(a, b, c) {
      b = zf(b);
      if (zf(a) !== b && c) throw Error(p(425));
    }
    __name(Af, "Af");
    function Bf() {
    }
    __name(Bf, "Bf");
    var Cf = null;
    var Df = null;
    function Ef(a, b) {
      return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    __name(Ef, "Ef");
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
    var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
    var Hf = "function" === typeof Promise ? Promise : void 0;
    var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    __name(If, "If");
    function Kf(a, b) {
      var c = b, d2 = 0;
      do {
        var e = c.nextSibling;
        a.removeChild(c);
        if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
          if (0 === d2) {
            a.removeChild(e);
            bd(b);
            return;
          }
          d2--;
        } else "$" !== c && "$?" !== c && "$!" !== c || d2++;
        c = e;
      } while (c);
      bd(b);
    }
    __name(Kf, "Kf");
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b = a.nodeType;
        if (1 === b || 3 === b) break;
        if (8 === b) {
          b = a.data;
          if ("$" === b || "$!" === b || "$?" === b) break;
          if ("/$" === b) return null;
        }
      }
      return a;
    }
    __name(Lf, "Lf");
    function Mf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("$" === c || "$!" === c || "$?" === c) {
            if (0 === b) return a;
            b--;
          } else "/$" === c && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    __name(Mf, "Mf");
    var Nf = Math.random().toString(36).slice(2);
    var Of = "__reactFiber$" + Nf;
    var Pf = "__reactProps$" + Nf;
    var uf = "__reactContainer$" + Nf;
    var of = "__reactEvents$" + Nf;
    var Qf = "__reactListeners$" + Nf;
    var Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b = a[Of];
      if (b) return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[uf] || c[Of]) {
          c = b.alternate;
          if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
            if (c = a[Of]) return c;
            a = Mf(a);
          }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    __name(Wc, "Wc");
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    __name(Cb, "Cb");
    function ue(a) {
      if (5 === a.tag || 6 === a.tag) return a.stateNode;
      throw Error(p(33));
    }
    __name(ue, "ue");
    function Db(a) {
      return a[Pf] || null;
    }
    __name(Db, "Db");
    var Sf = [];
    var Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    __name(Uf, "Uf");
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    __name(E, "E");
    function G(a, b) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b;
    }
    __name(G, "G");
    var Vf = {};
    var H = Uf(Vf);
    var Wf = Uf(false);
    var Xf = Vf;
    function Yf(a, b) {
      var c = a.type.contextTypes;
      if (!c) return Vf;
      var d2 = a.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b) return d2.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c) e[f] = b[f];
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    __name(Yf, "Yf");
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    __name(Zf, "Zf");
    function $f() {
      E(Wf);
      E(H);
    }
    __name($f, "$f");
    function ag(a, b, c) {
      if (H.current !== Vf) throw Error(p(168));
      G(H, b);
      G(Wf, c);
    }
    __name(ag, "ag");
    function bg(a, b, c) {
      var d2 = a.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d2.getChildContext) return c;
      d2 = d2.getChildContext();
      for (var e in d2) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
      return A({}, c, d2);
    }
    __name(bg, "bg");
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    __name(cg, "cg");
    function dg(a, b, c) {
      var d2 = a.stateNode;
      if (!d2) throw Error(p(169));
      c ? (a = bg(a, b, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c);
    }
    __name(dg, "dg");
    var eg = null;
    var fg = false;
    var gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    __name(hg, "hg");
    function ig(a) {
      fg = true;
      hg(a);
    }
    __name(ig, "ig");
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b = C;
        try {
          var c = eg;
          for (C = 1; a < c.length; a++) {
            var d2 = c[a];
            do
              d2 = d2(true);
            while (null !== d2);
          }
          eg = null;
          fg = false;
        } catch (e) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
        } finally {
          C = b, gg = false;
        }
      }
      return null;
    }
    __name(jg, "jg");
    var kg = [];
    var lg = 0;
    var mg = null;
    var ng = 0;
    var og = [];
    var pg = 0;
    var qg = null;
    var rg = 1;
    var sg = "";
    function tg(a, b) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b;
    }
    __name(tg, "tg");
    function ug(a, b, c) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d2 = rg;
      a = sg;
      var e = 32 - oc(d2) - 1;
      d2 &= ~(1 << e);
      c += 1;
      var f = 32 - oc(b) + e;
      if (30 < f) {
        var g = e - e % 5;
        f = (d2 & (1 << g) - 1).toString(32);
        d2 >>= g;
        e -= g;
        rg = 1 << 32 - oc(b) + e | c << e | d2;
        sg = f + a;
      } else rg = 1 << f | c << e | d2, sg = a;
    }
    __name(ug, "ug");
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    __name(vg, "vg");
    function wg(a) {
      for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    __name(wg, "wg");
    var xg = null;
    var yg = null;
    var I = false;
    var zg = null;
    function Ag(a, b) {
      var c = Bg(5, null, null, 0);
      c.elementType = "DELETED";
      c.stateNode = b;
      c.return = a;
      b = a.deletions;
      null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
    }
    __name(Ag, "Ag");
    function Cg(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
        case 6:
          return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
        case 13:
          return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    __name(Cg, "Cg");
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    __name(Dg, "Dg");
    function Eg(a) {
      if (I) {
        var b = yg;
        if (b) {
          var c = b;
          if (!Cg(a, b)) {
            if (Dg(a)) throw Error(p(418));
            b = Lf(c.nextSibling);
            var d2 = xg;
            b && Cg(a, b) ? Ag(d2, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a)) throw Error(p(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    __name(Eg, "Eg");
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
      xg = a;
    }
    __name(Fg, "Fg");
    function Gg(a) {
      if (a !== xg) return false;
      if (!I) return Fg(a), I = true, false;
      var b;
      (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
      if (b && (b = yg)) {
        if (Dg(a)) throw Hg(), Error(p(418));
        for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a) throw Error(p(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("/$" === c) {
                if (0 === b) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b--;
              } else "$" !== c && "$!" !== c && "$?" !== c || b++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    __name(Gg, "Gg");
    function Hg() {
      for (var a = yg; a; ) a = Lf(a.nextSibling);
    }
    __name(Hg, "Hg");
    function Ig() {
      yg = xg = null;
      I = false;
    }
    __name(Ig, "Ig");
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    __name(Jg, "Jg");
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b);
        a = a.defaultProps;
        for (var c in a) void 0 === b[c] && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    __name(Lg, "Lg");
    var Mg = Uf(null);
    var Ng = null;
    var Og = null;
    var Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    __name(Qg, "Qg");
    function Rg(a) {
      var b = Mg.current;
      E(Mg);
      a._currentValue = b;
    }
    __name(Rg, "Rg");
    function Sg(a, b, c) {
      for (; null !== a; ) {
        var d2 = a.alternate;
        (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d2 && (d2.childLanes |= b)) : null !== d2 && (d2.childLanes & b) !== b && (d2.childLanes |= b);
        if (a === c) break;
        a = a.return;
      }
    }
    __name(Sg, "Sg");
    function Tg(a, b) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = true), a.firstContext = null);
    }
    __name(Tg, "Tg");
    function Vg(a) {
      var b = a._currentValue;
      if (Pg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Og) {
        if (null === Ng) throw Error(p(308));
        Og = a;
        Ng.dependencies = { lanes: 0, firstContext: a };
      } else Og = Og.next = a;
      return b;
    }
    __name(Vg, "Vg");
    var Wg = null;
    function Xg(a) {
      null === Wg ? Wg = [a] : Wg.push(a);
    }
    __name(Xg, "Xg");
    function Yg(a, b, c, d2) {
      var e = b.interleaved;
      null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
      b.interleaved = c;
      return Zg(a, d2);
    }
    __name(Yg, "Yg");
    function Zg(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      null !== c && (c.lanes |= b);
      c = a;
      for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
      return 3 === c.tag ? c.stateNode : null;
    }
    __name(Zg, "Zg");
    var $g = false;
    function ah(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    __name(ah, "ah");
    function bh(a, b) {
      a = a.updateQueue;
      b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    __name(bh, "bh");
    function ch(a, b) {
      return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    __name(ch, "ch");
    function dh(a, b, c) {
      var d2 = a.updateQueue;
      if (null === d2) return null;
      d2 = d2.shared;
      if (0 !== (K & 2)) {
        var e = d2.pending;
        null === e ? b.next = b : (b.next = e.next, e.next = b);
        d2.pending = b;
        return Zg(a, c);
      }
      e = d2.interleaved;
      null === e ? (b.next = b, Xg(d2)) : (b.next = e.next, e.next = b);
      d2.interleaved = b;
      return Zg(a, c);
    }
    __name(dh, "dh");
    function eh(a, b, c) {
      b = b.updateQueue;
      if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
        var d2 = b.lanes;
        d2 &= a.pendingLanes;
        c |= d2;
        b.lanes = c;
        Cc(a, c);
      }
    }
    __name(eh, "eh");
    function fh(a, b) {
      var c = a.updateQueue, d2 = a.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c === d2)) {
        var e = null, f = null;
        c = c.firstBaseUpdate;
        if (null !== c) {
          do {
            var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            null === f ? e = f = g : f = f.next = g;
            c = c.next;
          } while (null !== c);
          null === f ? e = f = b : f = f.next = b;
        } else e = f = b;
        c = { baseState: d2.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d2.shared, effects: d2.effects };
        a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate;
      null === a ? c.firstBaseUpdate = b : a.next = b;
      c.lastBaseUpdate = b;
    }
    __name(fh, "fh");
    function gh(a, b, c, d2) {
      var e = a.updateQueue;
      $g = false;
      var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (null !== h) {
        e.shared.pending = null;
        var k = h, l = k.next;
        k.next = null;
        null === g ? f = l : g.next = l;
        g = k;
        var m = a.alternate;
        null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
      }
      if (null !== f) {
        var q = e.baseState;
        g = 0;
        m = l = k = null;
        h = f;
        do {
          var r = h.lane, y = h.eventTime;
          if ((d2 & r) === r) {
            null !== m && (m = m.next = {
              eventTime: y,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null
            });
            a: {
              var n = a, t = h;
              r = b;
              y = c;
              switch (t.tag) {
                case 1:
                  n = t.payload;
                  if ("function" === typeof n) {
                    q = n.call(y, q, r);
                    break a;
                  }
                  q = n;
                  break a;
                case 3:
                  n.flags = n.flags & -65537 | 128;
                case 0:
                  n = t.payload;
                  r = "function" === typeof n ? n.call(y, q, r) : n;
                  if (null === r || void 0 === r) break a;
                  q = A({}, q, r);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
          } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
          h = h.next;
          if (null === h) if (h = e.shared.pending, null === h) break;
          else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
        } while (1);
        null === m && (k = q);
        e.baseState = k;
        e.firstBaseUpdate = l;
        e.lastBaseUpdate = m;
        b = e.shared.interleaved;
        if (null !== b) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else null === f && (e.shared.lanes = 0);
        hh |= g;
        a.lanes = g;
        a.memoizedState = q;
      }
    }
    __name(gh, "gh");
    function ih(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (null !== a) for (b = 0; b < a.length; b++) {
        var d2 = a[b], e = d2.callback;
        if (null !== e) {
          d2.callback = null;
          d2 = c;
          if ("function" !== typeof e) throw Error(p(191, e));
          e.call(d2);
        }
      }
    }
    __name(ih, "ih");
    var jh = new aa.Component().refs;
    function kh(a, b, c, d2) {
      b = a.memoizedState;
      c = c(d2, b);
      c = null === c || void 0 === c ? b : A({}, b, c);
      a.memoizedState = c;
      0 === a.lanes && (a.updateQueue.baseState = c);
    }
    __name(kh, "kh");
    var nh = { isMounted: /* @__PURE__ */ __name(function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, "isMounted"), enqueueSetState: /* @__PURE__ */ __name(function(a, b, c) {
      a = a._reactInternals;
      var d2 = L(), e = lh(a), f = ch(d2, e);
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = dh(a, f, e);
      null !== b && (mh(b, a, e, d2), eh(b, a, e));
    }, "enqueueSetState"), enqueueReplaceState: /* @__PURE__ */ __name(function(a, b, c) {
      a = a._reactInternals;
      var d2 = L(), e = lh(a), f = ch(d2, e);
      f.tag = 1;
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = dh(a, f, e);
      null !== b && (mh(b, a, e, d2), eh(b, a, e));
    }, "enqueueReplaceState"), enqueueForceUpdate: /* @__PURE__ */ __name(function(a, b) {
      a = a._reactInternals;
      var c = L(), d2 = lh(a), e = ch(c, d2);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      b = dh(a, e, d2);
      null !== b && (mh(b, a, d2, c), eh(b, a, d2));
    }, "enqueueForceUpdate") };
    function oh(a, b, c, d2, e, f, g) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d2) || !Ie(e, f) : true;
    }
    __name(oh, "oh");
    function ph(a, b, c) {
      var d2 = false, e = Vf;
      var f = b.contextType;
      "object" === typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H.current, d2 = b.contextTypes, f = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e) : Vf);
      b = new b(c, f);
      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = nh;
      a.stateNode = b;
      b._reactInternals = a;
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    __name(ph, "ph");
    function qh(a, b, c, d2) {
      a = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d2);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d2);
      b.state !== a && nh.enqueueReplaceState(b, b.state, null);
    }
    __name(qh, "qh");
    function rh(a, b, c, d2) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = jh;
      ah(a);
      var f = b.contextType;
      "object" === typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
      e.state = a.memoizedState;
      f = b.getDerivedStateFromProps;
      "function" === typeof f && (kh(a, b, f, c), e.state = a.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d2), e.state = a.memoizedState);
      "function" === typeof e.componentDidMount && (a.flags |= 4194308);
    }
    __name(rh, "rh");
    function sh(a, b, c) {
      a = c.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag) throw Error(p(309));
            var d2 = c.stateNode;
          }
          if (!d2) throw Error(p(147, a));
          var e = d2, f = "" + a;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
          b = /* @__PURE__ */ __name(function(a2) {
            var b2 = e.refs;
            b2 === jh && (b2 = e.refs = {});
            null === a2 ? delete b2[f] : b2[f] = a2;
          }, "b");
          b._stringRef = f;
          return b;
        }
        if ("string" !== typeof a) throw Error(p(284));
        if (!c._owner) throw Error(p(290, a));
      }
      return a;
    }
    __name(sh, "sh");
    function th(a, b) {
      a = Object.prototype.toString.call(b);
      throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
    }
    __name(th, "th");
    function uh(a) {
      var b = a._init;
      return b(a._payload);
    }
    __name(uh, "uh");
    function vh(a) {
      function b(b2, c2) {
        if (a) {
          var d3 = b2.deletions;
          null === d3 ? (b2.deletions = [c2], b2.flags |= 16) : d3.push(c2);
        }
      }
      __name(b, "b");
      function c(c2, d3) {
        if (!a) return null;
        for (; null !== d3; ) b(c2, d3), d3 = d3.sibling;
        return null;
      }
      __name(c, "c");
      function d2(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      __name(d2, "d");
      function e(a2, b2) {
        a2 = wh(a2, b2);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      __name(e, "e");
      function f(b2, c2, d3) {
        b2.index = d3;
        if (!a) return b2.flags |= 1048576, c2;
        d3 = b2.alternate;
        if (null !== d3) return d3 = d3.index, d3 < c2 ? (b2.flags |= 2, c2) : d3;
        b2.flags |= 2;
        return c2;
      }
      __name(f, "f");
      function g(b2) {
        a && null === b2.alternate && (b2.flags |= 2);
        return b2;
      }
      __name(g, "g");
      function h(a2, b2, c2, d3) {
        if (null === b2 || 6 !== b2.tag) return b2 = xh(c2, a2.mode, d3), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      __name(h, "h");
      function k(a2, b2, c2, d3) {
        var f2 = c2.type;
        if (f2 === ya) return m(a2, b2, c2.props.children, d3, c2.key);
        if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && uh(f2) === b2.type)) return d3 = e(b2, c2.props), d3.ref = sh(a2, b2, c2), d3.return = a2, d3;
        d3 = yh(c2.type, c2.key, c2.props, null, a2.mode, d3);
        d3.ref = sh(a2, b2, c2);
        d3.return = a2;
        return d3;
      }
      __name(k, "k");
      function l(a2, b2, c2, d3) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = zh(c2, a2.mode, d3), b2.return = a2, b2;
        b2 = e(b2, c2.children || []);
        b2.return = a2;
        return b2;
      }
      __name(l, "l");
      function m(a2, b2, c2, d3, f2) {
        if (null === b2 || 7 !== b2.tag) return b2 = Ah(c2, a2.mode, d3, f2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      __name(m, "m");
      function q(a2, b2, c2) {
        if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = xh("" + b2, a2.mode, c2), b2.return = a2, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case va:
              return c2 = yh(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = sh(a2, null, b2), c2.return = a2, c2;
            case wa:
              return b2 = zh(b2, a2.mode, c2), b2.return = a2, b2;
            case Ha:
              var d3 = b2._init;
              return q(a2, d3(b2._payload), c2);
          }
          if (eb(b2) || Ka(b2)) return b2 = Ah(b2, a2.mode, c2, null), b2.return = a2, b2;
          th(a2, b2);
        }
        return null;
      }
      __name(q, "q");
      function r(a2, b2, c2, d3) {
        var e2 = null !== b2 ? b2.key : null;
        if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d3);
        if ("object" === typeof c2 && null !== c2) {
          switch (c2.$$typeof) {
            case va:
              return c2.key === e2 ? k(a2, b2, c2, d3) : null;
            case wa:
              return c2.key === e2 ? l(a2, b2, c2, d3) : null;
            case Ha:
              return e2 = c2._init, r(
                a2,
                b2,
                e2(c2._payload),
                d3
              );
          }
          if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d3, null);
          th(a2, c2);
        }
        return null;
      }
      __name(r, "r");
      function y(a2, b2, c2, d3, e2) {
        if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a2 = a2.get(c2) || null, h(b2, a2, "" + d3, e2);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case va:
              return a2 = a2.get(null === d3.key ? c2 : d3.key) || null, k(b2, a2, d3, e2);
            case wa:
              return a2 = a2.get(null === d3.key ? c2 : d3.key) || null, l(b2, a2, d3, e2);
            case Ha:
              var f2 = d3._init;
              return y(a2, b2, c2, f2(d3._payload), e2);
          }
          if (eb(d3) || Ka(d3)) return a2 = a2.get(c2) || null, m(b2, a2, d3, e2, null);
          th(b2, d3);
        }
        return null;
      }
      __name(y, "y");
      function n(e2, g2, h2, k2) {
        for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
          u.index > w ? (x = u, u = null) : x = u.sibling;
          var n2 = r(e2, u, h2[w], k2);
          if (null === n2) {
            null === u && (u = x);
            break;
          }
          a && u && null === n2.alternate && b(e2, u);
          g2 = f(n2, g2, w);
          null === m2 ? l2 = n2 : m2.sibling = n2;
          m2 = n2;
          u = x;
        }
        if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
        if (null === u) {
          for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
          I && tg(e2, w);
          return l2;
        }
        for (u = d2(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
        a && u.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      __name(n, "n");
      function t(e2, g2, h2, k2) {
        var l2 = Ka(h2);
        if ("function" !== typeof l2) throw Error(p(150));
        h2 = l2.call(h2);
        if (null == h2) throw Error(p(151));
        for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
          m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
          var t2 = r(e2, m2, n2.value, k2);
          if (null === t2) {
            null === m2 && (m2 = x);
            break;
          }
          a && m2 && null === t2.alternate && b(e2, m2);
          g2 = f(t2, g2, w);
          null === u ? l2 = t2 : u.sibling = t2;
          u = t2;
          m2 = x;
        }
        if (n2.done) return c(
          e2,
          m2
        ), I && tg(e2, w), l2;
        if (null === m2) {
          for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          I && tg(e2, w);
          return l2;
        }
        for (m2 = d2(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        a && m2.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      __name(t, "t");
      function J(a2, d3, f2, h2) {
        "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
        if ("object" === typeof f2 && null !== f2) {
          switch (f2.$$typeof) {
            case va:
              a: {
                for (var k2 = f2.key, l2 = d3; null !== l2; ) {
                  if (l2.key === k2) {
                    k2 = f2.type;
                    if (k2 === ya) {
                      if (7 === l2.tag) {
                        c(a2, l2.sibling);
                        d3 = e(l2, f2.props.children);
                        d3.return = a2;
                        a2 = d3;
                        break a;
                      }
                    } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && uh(k2) === l2.type) {
                      c(a2, l2.sibling);
                      d3 = e(l2, f2.props);
                      d3.ref = sh(a2, l2, f2);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                    c(a2, l2);
                    break;
                  } else b(a2, l2);
                  l2 = l2.sibling;
                }
                f2.type === ya ? (d3 = Ah(f2.props.children, a2.mode, h2, f2.key), d3.return = a2, a2 = d3) : (h2 = yh(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = sh(a2, d3, f2), h2.return = a2, a2 = h2);
              }
              return g(a2);
            case wa:
              a: {
                for (l2 = f2.key; null !== d3; ) {
                  if (d3.key === l2) if (4 === d3.tag && d3.stateNode.containerInfo === f2.containerInfo && d3.stateNode.implementation === f2.implementation) {
                    c(a2, d3.sibling);
                    d3 = e(d3, f2.children || []);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  } else {
                    c(a2, d3);
                    break;
                  }
                  else b(a2, d3);
                  d3 = d3.sibling;
                }
                d3 = zh(f2, a2.mode, h2);
                d3.return = a2;
                a2 = d3;
              }
              return g(a2);
            case Ha:
              return l2 = f2._init, J(a2, d3, l2(f2._payload), h2);
          }
          if (eb(f2)) return n(a2, d3, f2, h2);
          if (Ka(f2)) return t(a2, d3, f2, h2);
          th(a2, f2);
        }
        return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d3 && 6 === d3.tag ? (c(a2, d3.sibling), d3 = e(d3, f2), d3.return = a2, a2 = d3) : (c(a2, d3), d3 = xh(f2, a2.mode, h2), d3.return = a2, a2 = d3), g(a2)) : c(a2, d3);
      }
      __name(J, "J");
      return J;
    }
    __name(vh, "vh");
    var Bh = vh(true);
    var Ch = vh(false);
    var Dh = {};
    var Eh = Uf(Dh);
    var Fh = Uf(Dh);
    var Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh) throw Error(p(174));
      return a;
    }
    __name(Hh, "Hh");
    function Ih(a, b) {
      G(Gh, b);
      G(Fh, a);
      G(Eh, Dh);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
      }
      E(Eh);
      G(Eh, b);
    }
    __name(Ih, "Ih");
    function Jh() {
      E(Eh);
      E(Fh);
      E(Gh);
    }
    __name(Jh, "Jh");
    function Kh(a) {
      Hh(Gh.current);
      var b = Hh(Eh.current);
      var c = lb(b, a.type);
      b !== c && (G(Fh, a), G(Eh, c));
    }
    __name(Kh, "Kh");
    function Lh(a) {
      Fh.current === a && (E(Eh), E(Fh));
    }
    __name(Lh, "Lh");
    var M = Uf(0);
    function Mh(a) {
      for (var b = a; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128)) return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    __name(Mh, "Mh");
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++) Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    __name(Oh, "Oh");
    var Ph = ua.ReactCurrentDispatcher;
    var Qh = ua.ReactCurrentBatchConfig;
    var Rh = 0;
    var N = null;
    var O = null;
    var P = null;
    var Sh = false;
    var Th = false;
    var Uh = 0;
    var Vh = 0;
    function Q() {
      throw Error(p(321));
    }
    __name(Q, "Q");
    function Wh(a, b) {
      if (null === b) return false;
      for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
      return true;
    }
    __name(Wh, "Wh");
    function Xh(a, b, c, d2, e, f) {
      Rh = f;
      N = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c(d2, e);
      if (Th) {
        f = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f) throw Error(p(301));
          f += 1;
          P = O = null;
          b.updateQueue = null;
          Ph.current = $h;
          a = c(d2, e);
        } while (Th);
      }
      Ph.current = ai;
      b = null !== O && null !== O.next;
      Rh = 0;
      P = O = N = null;
      Sh = false;
      if (b) throw Error(p(300));
      return a;
    }
    __name(Xh, "Xh");
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    __name(bi, "bi");
    function ci() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N.memoizedState = P = a : P = P.next = a;
      return P;
    }
    __name(ci, "ci");
    function di() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else a = O.next;
      var b = null === P ? N.memoizedState : P.next;
      if (null !== b) P = b, O = a;
      else {
        if (null === a) throw Error(p(310));
        O = a;
        a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    __name(di, "di");
    function ei(a, b) {
      return "function" === typeof b ? b(a) : b;
    }
    __name(ei, "ei");
    function fi(a) {
      var b = di(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d2 = O, e = d2.baseQueue, f = c.pending;
      if (null !== f) {
        if (null !== e) {
          var g = e.next;
          e.next = f.next;
          f.next = g;
        }
        d2.baseQueue = e = f;
        c.pending = null;
      }
      if (null !== e) {
        f = e.next;
        d2 = d2.baseState;
        var h = g = null, k = null, l = f;
        do {
          var m = l.lane;
          if ((Rh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d2 = l.hasEagerState ? l.eagerState : a(d2, l.action);
          else {
            var q = {
              lane: m,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null
            };
            null === k ? (h = k = q, g = d2) : k = k.next = q;
            N.lanes |= m;
            hh |= m;
          }
          l = l.next;
        } while (null !== l && l !== f);
        null === k ? g = d2 : k.next = h;
        He(d2, b.memoizedState) || (Ug = true);
        b.memoizedState = d2;
        b.baseState = g;
        b.baseQueue = k;
        c.lastRenderedState = d2;
      }
      a = c.interleaved;
      if (null !== a) {
        e = a;
        do
          f = e.lane, N.lanes |= f, hh |= f, e = e.next;
        while (e !== a);
      } else null === e && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    __name(fi, "fi");
    function gi(a) {
      var b = di(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d2 = c.dispatch, e = c.pending, f = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g = e = e.next;
        do
          f = a(f, g.action), g = g.next;
        while (g !== e);
        He(f, b.memoizedState) || (Ug = true);
        b.memoizedState = f;
        null === b.baseQueue && (b.baseState = f);
        c.lastRenderedState = f;
      }
      return [f, d2];
    }
    __name(gi, "gi");
    function hi() {
    }
    __name(hi, "hi");
    function ii(a, b) {
      var c = N, d2 = di(), e = b(), f = !He(d2.memoizedState, e);
      f && (d2.memoizedState = e, Ug = true);
      d2 = d2.queue;
      ji(ki.bind(null, c, d2, a), [a]);
      if (d2.getSnapshot !== b || f || null !== P && P.memoizedState.tag & 1) {
        c.flags |= 2048;
        li(9, mi.bind(null, c, d2, e, b), void 0, null);
        if (null === R) throw Error(p(349));
        0 !== (Rh & 30) || ni(c, b, e);
      }
      return e;
    }
    __name(ii, "ii");
    function ni(a, b, c) {
      a.flags |= 16384;
      a = { getSnapshot: b, value: c };
      b = N.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
    }
    __name(ni, "ni");
    function mi(a, b, c, d2) {
      b.value = c;
      b.getSnapshot = d2;
      oi(b) && pi(a);
    }
    __name(mi, "mi");
    function ki(a, b, c) {
      return c(function() {
        oi(b) && pi(a);
      });
    }
    __name(ki, "ki");
    function oi(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He(a, c);
      } catch (d2) {
        return true;
      }
    }
    __name(oi, "oi");
    function pi(a) {
      var b = Zg(a, 1);
      null !== b && mh(b, a, 1, -1);
    }
    __name(pi, "pi");
    function qi(a) {
      var b = ci();
      "function" === typeof a && (a = a());
      b.memoizedState = b.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
      b.queue = a;
      a = a.dispatch = ri.bind(null, N, a);
      return [b.memoizedState, a];
    }
    __name(qi, "qi");
    function li(a, b, c, d2) {
      a = { tag: a, create: b, destroy: c, deps: d2, next: null };
      b = N.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d2 = c.next, c.next = a, a.next = d2, b.lastEffect = a));
      return a;
    }
    __name(li, "li");
    function si() {
      return di().memoizedState;
    }
    __name(si, "si");
    function ti(a, b, c, d2) {
      var e = ci();
      N.flags |= a;
      e.memoizedState = li(1 | b, c, void 0, void 0 === d2 ? null : d2);
    }
    __name(ti, "ti");
    function ui(a, b, c, d2) {
      var e = di();
      d2 = void 0 === d2 ? null : d2;
      var f = void 0;
      if (null !== O) {
        var g = O.memoizedState;
        f = g.destroy;
        if (null !== d2 && Wh(d2, g.deps)) {
          e.memoizedState = li(b, c, f, d2);
          return;
        }
      }
      N.flags |= a;
      e.memoizedState = li(1 | b, c, f, d2);
    }
    __name(ui, "ui");
    function vi(a, b) {
      return ti(8390656, 8, a, b);
    }
    __name(vi, "vi");
    function ji(a, b) {
      return ui(2048, 8, a, b);
    }
    __name(ji, "ji");
    function wi(a, b) {
      return ui(4, 2, a, b);
    }
    __name(wi, "wi");
    function xi(a, b) {
      return ui(4, 4, a, b);
    }
    __name(xi, "xi");
    function yi(a, b) {
      if ("function" === typeof b) return a = a(), b(a), function() {
        b(null);
      };
      if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
        b.current = null;
      };
    }
    __name(yi, "yi");
    function zi(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ui(4, 4, yi.bind(null, b, a), c);
    }
    __name(zi, "zi");
    function Ai() {
    }
    __name(Ai, "Ai");
    function Bi(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d2 = c.memoizedState;
      if (null !== d2 && null !== b && Wh(b, d2[1])) return d2[0];
      c.memoizedState = [a, b];
      return a;
    }
    __name(Bi, "Bi");
    function Ci(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d2 = c.memoizedState;
      if (null !== d2 && null !== b && Wh(b, d2[1])) return d2[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    __name(Ci, "Ci");
    function Di(a, b, c) {
      if (0 === (Rh & 21)) return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c;
      He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = true);
      return b;
    }
    __name(Di, "Di");
    function Ei(a, b) {
      var c = C;
      C = 0 !== c && 4 > c ? c : 4;
      a(true);
      var d2 = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b();
      } finally {
        C = c, Qh.transition = d2;
      }
    }
    __name(Ei, "Ei");
    function Fi() {
      return di().memoizedState;
    }
    __name(Fi, "Fi");
    function Gi(a, b, c) {
      var d2 = lh(a);
      c = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a)) Ii(b, c);
      else if (c = Yg(a, b, c, d2), null !== c) {
        var e = L();
        mh(c, a, d2, e);
        Ji(c, b, d2);
      }
    }
    __name(Gi, "Gi");
    function ri(a, b, c) {
      var d2 = lh(a), e = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a)) Ii(b, e);
      else {
        var f = a.alternate;
        if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
          var g = b.lastRenderedState, h = f(g, c);
          e.hasEagerState = true;
          e.eagerState = h;
          if (He(h, g)) {
            var k = b.interleaved;
            null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e);
            b.interleaved = e;
            return;
          }
        } catch (l) {
        } finally {
        }
        c = Yg(a, b, e, d2);
        null !== c && (e = L(), mh(c, a, d2, e), Ji(c, b, d2));
      }
    }
    __name(ri, "ri");
    function Hi(a) {
      var b = a.alternate;
      return a === N || null !== b && b === N;
    }
    __name(Hi, "Hi");
    function Ii(a, b) {
      Th = Sh = true;
      var c = a.pending;
      null === c ? b.next = b : (b.next = c.next, c.next = b);
      a.pending = b;
    }
    __name(Ii, "Ii");
    function Ji(a, b, c) {
      if (0 !== (c & 4194240)) {
        var d2 = b.lanes;
        d2 &= a.pendingLanes;
        c |= d2;
        b.lanes = c;
        Cc(a, c);
      }
    }
    __name(Ji, "Ji");
    var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false };
    var Yh = { readContext: Vg, useCallback: /* @__PURE__ */ __name(function(a, b) {
      ci().memoizedState = [a, void 0 === b ? null : b];
      return a;
    }, "useCallback"), useContext: Vg, useEffect: vi, useImperativeHandle: /* @__PURE__ */ __name(function(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b, a),
        c
      );
    }, "useImperativeHandle"), useLayoutEffect: /* @__PURE__ */ __name(function(a, b) {
      return ti(4194308, 4, a, b);
    }, "useLayoutEffect"), useInsertionEffect: /* @__PURE__ */ __name(function(a, b) {
      return ti(4, 2, a, b);
    }, "useInsertionEffect"), useMemo: /* @__PURE__ */ __name(function(a, b) {
      var c = ci();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    }, "useMemo"), useReducer: /* @__PURE__ */ __name(function(a, b, c) {
      var d2 = ci();
      b = void 0 !== c ? c(b) : b;
      d2.memoizedState = d2.baseState = b;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
      d2.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d2.memoizedState, a];
    }, "useReducer"), useRef: /* @__PURE__ */ __name(function(a) {
      var b = ci();
      a = { current: a };
      return b.memoizedState = a;
    }, "useRef"), useState: qi, useDebugValue: Ai, useDeferredValue: /* @__PURE__ */ __name(function(a) {
      return ci().memoizedState = a;
    }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
      var a = qi(false), b = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b, a];
    }, "useTransition"), useMutableSource: /* @__PURE__ */ __name(function() {
    }, "useMutableSource"), useSyncExternalStore: /* @__PURE__ */ __name(function(a, b, c) {
      var d2 = N, e = ci();
      if (I) {
        if (void 0 === c) throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === R) throw Error(p(349));
        0 !== (Rh & 30) || ni(d2, b, c);
      }
      e.memoizedState = c;
      var f = { value: c, getSnapshot: b };
      e.queue = f;
      vi(ki.bind(
        null,
        d2,
        f,
        a
      ), [a]);
      d2.flags |= 2048;
      li(9, mi.bind(null, d2, f, c, b), void 0, null);
      return c;
    }, "useSyncExternalStore"), useId: /* @__PURE__ */ __name(function() {
      var a = ci(), b = R.identifierPrefix;
      if (I) {
        var c = sg;
        var d2 = rg;
        c = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Uh++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    }, "useId"), unstable_isNewReconciler: false };
    var Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: /* @__PURE__ */ __name(function() {
        return fi(ei);
      }, "useState"),
      useDebugValue: Ai,
      useDeferredValue: /* @__PURE__ */ __name(function(a) {
        var b = di();
        return Di(b, O.memoizedState, a);
      }, "useDeferredValue"),
      useTransition: /* @__PURE__ */ __name(function() {
        var a = fi(ei)[0], b = di().memoizedState;
        return [a, b];
      }, "useTransition"),
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    };
    var $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: /* @__PURE__ */ __name(function() {
      return gi(ei);
    }, "useState"), useDebugValue: Ai, useDeferredValue: /* @__PURE__ */ __name(function(a) {
      var b = di();
      return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
    }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
      var a = gi(ei)[0], b = di().memoizedState;
      return [a, b];
    }, "useTransition"), useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a, b) {
      try {
        var c = "", d2 = b;
        do
          c += Pa(d2), d2 = d2.return;
        while (d2);
        var e = c;
      } catch (f) {
        e = "\nError generating stack: " + f.message + "\n" + f.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    __name(Ki, "Ki");
    function Li(a, b, c) {
      return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
    }
    __name(Li, "Li");
    function Mi(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    __name(Mi, "Mi");
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      c.payload = { element: null };
      var d2 = b.value;
      c.callback = function() {
        Pi || (Pi = true, Qi = d2);
        Mi(a, b);
      };
      return c;
    }
    __name(Oi, "Oi");
    function Ri(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      var d2 = a.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e = b.value;
        c.payload = function() {
          return d2(e);
        };
        c.callback = function() {
          Mi(a, b);
        };
      }
      var f = a.stateNode;
      null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
        Mi(a, b);
        "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
      });
      return c;
    }
    __name(Ri, "Ri");
    function Ti(a, b, c) {
      var d2 = a.pingCache;
      if (null === d2) {
        d2 = a.pingCache = new Ni();
        var e = /* @__PURE__ */ new Set();
        d2.set(b, e);
      } else e = d2.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d2.set(b, e));
      e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
    }
    __name(Ti, "Ti");
    function Vi(a) {
      do {
        var b;
        if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
        if (b) return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    __name(Vi, "Vi");
    function Wi(a, b, c, d2, e) {
      if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e;
      return a;
    }
    __name(Wi, "Wi");
    var Xi = ua.ReactCurrentOwner;
    var Ug = false;
    function Yi(a, b, c, d2) {
      b.child = null === a ? Ch(b, null, c, d2) : Bh(b, a.child, c, d2);
    }
    __name(Yi, "Yi");
    function Zi(a, b, c, d2, e) {
      c = c.render;
      var f = b.ref;
      Tg(b, e);
      d2 = Xh(a, b, c, d2, f, e);
      c = bi();
      if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
      I && c && vg(b);
      b.flags |= 1;
      Yi(a, b, d2, e);
      return b.child;
    }
    __name(Zi, "Zi");
    function aj(a, b, c, d2, e) {
      if (null === a) {
        var f = c.type;
        if ("function" === typeof f && !bj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, cj(a, b, f, d2, e);
        a = yh(c.type, null, d2, b, b.mode, e);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      f = a.child;
      if (0 === (a.lanes & e)) {
        var g = f.memoizedProps;
        c = c.compare;
        c = null !== c ? c : Ie;
        if (c(g, d2) && a.ref === b.ref) return $i(a, b, e);
      }
      b.flags |= 1;
      a = wh(f, d2);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    __name(aj, "aj");
    function cj(a, b, c, d2, e) {
      if (null !== a) {
        var f = a.memoizedProps;
        if (Ie(f, d2) && a.ref === b.ref) if (Ug = false, b.pendingProps = d2 = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (Ug = true);
        else return b.lanes = a.lanes, $i(a, b, e);
      }
      return dj(a, b, c, d2, e);
    }
    __name(cj, "cj");
    function ej(a, b, c) {
      var d2 = b.pendingProps, e = d2.children, f = null !== a ? a.memoizedState : null;
      if ("hidden" === d2.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c;
      else {
        if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(fj, gj), gj |= a, null;
        b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
        d2 = null !== f ? f.baseLanes : c;
        G(fj, gj);
        gj |= d2;
      }
      else null !== f ? (d2 = f.baseLanes | c, b.memoizedState = null) : d2 = c, G(fj, gj), gj |= d2;
      Yi(a, b, e, c);
      return b.child;
    }
    __name(ej, "ej");
    function hj(a, b) {
      var c = b.ref;
      if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
    }
    __name(hj, "hj");
    function dj(a, b, c, d2, e) {
      var f = Zf(c) ? Xf : H.current;
      f = Yf(b, f);
      Tg(b, e);
      c = Xh(a, b, c, d2, f, e);
      d2 = bi();
      if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
      I && d2 && vg(b);
      b.flags |= 1;
      Yi(a, b, c, e);
      return b.child;
    }
    __name(dj, "dj");
    function ij(a, b, c, d2, e) {
      if (Zf(c)) {
        var f = true;
        cg(b);
      } else f = false;
      Tg(b, e);
      if (null === b.stateNode) jj(a, b), ph(b, c, d2), rh(b, c, d2, e), d2 = true;
      else if (null === a) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k = g.context, l = c.contextType;
        "object" === typeof l && null !== l ? l = Vg(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
        var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
        q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d2 || k !== l) && qh(b, g, d2, l);
        $g = false;
        var r = b.memoizedState;
        g.state = r;
        gh(b, d2, g, e);
        k = b.memoizedState;
        h !== d2 || r !== k || Wf.current || $g ? ("function" === typeof m && (kh(b, c, m, d2), k = b.memoizedState), (h = $g || oh(b, c, h, d2, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d2, b.memoizedState = k), g.props = d2, g.state = k, g.context = l, d2 = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d2 = false);
      } else {
        g = b.stateNode;
        bh(a, b);
        h = b.memoizedProps;
        l = b.type === b.elementType ? h : Lg(b.type, h);
        g.props = l;
        q = b.pendingProps;
        r = g.context;
        k = c.contextType;
        "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
        var y = c.getDerivedStateFromProps;
        (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d2, k);
        $g = false;
        r = b.memoizedState;
        g.state = r;
        gh(b, d2, g, e);
        var n = b.memoizedState;
        h !== q || r !== n || Wf.current || $g ? ("function" === typeof y && (kh(b, c, y, d2), n = b.memoizedState), (l = $g || oh(b, c, l, d2, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d2, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d2, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d2, b.memoizedState = n), g.props = d2, g.state = n, g.context = k, d2 = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d2 = false);
      }
      return kj(a, b, c, d2, f, e);
    }
    __name(ij, "ij");
    function kj(a, b, c, d2, e, f) {
      hj(a, b);
      var g = 0 !== (b.flags & 128);
      if (!d2 && !g) return e && dg(b, c, false), $i(a, b, f);
      d2 = b.stateNode;
      Xi.current = b;
      var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d2.render();
      b.flags |= 1;
      null !== a && g ? (b.child = Bh(b, a.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a, b, h, f);
      b.memoizedState = d2.state;
      e && dg(b, c, true);
      return b.child;
    }
    __name(kj, "kj");
    function lj(a) {
      var b = a.stateNode;
      b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
      Ih(a, b.containerInfo);
    }
    __name(lj, "lj");
    function mj(a, b, c, d2, e) {
      Ig();
      Jg(e);
      b.flags |= 256;
      Yi(a, b, c, d2);
      return b.child;
    }
    __name(mj, "mj");
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    __name(oj, "oj");
    function pj(a, b, c) {
      var d2 = b.pendingProps, e = M.current, f = false, g = 0 !== (b.flags & 128), h;
      (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
      if (h) f = true, b.flags &= -129;
      else if (null === a || null !== a.memoizedState) e |= 1;
      G(M, e & 1);
      if (null === a) {
        Eg(b);
        a = b.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
        g = d2.children;
        a = d2.fallback;
        return f ? (d2 = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d2 & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = qj(g, d2, 0, null), a = Ah(a, d2, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
      }
      e = a.memoizedState;
      if (null !== e && (h = e.dehydrated, null !== h)) return sj(a, b, g, d2, h, e, c);
      if (f) {
        f = d2.fallback;
        g = b.mode;
        e = a.child;
        h = e.sibling;
        var k = { mode: "hidden", children: d2.children };
        0 === (g & 1) && b.child !== e ? (d2 = b.child, d2.childLanes = 0, d2.pendingProps = k, b.deletions = null) : (d2 = wh(e, k), d2.subtreeFlags = e.subtreeFlags & 14680064);
        null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null), f.flags |= 2);
        f.return = b;
        d2.return = b;
        d2.sibling = f;
        b.child = d2;
        d2 = f;
        f = b.child;
        g = a.child.memoizedState;
        g = null === g ? oj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
        f.memoizedState = g;
        f.childLanes = a.childLanes & ~c;
        b.memoizedState = nj;
        return d2;
      }
      f = a.child;
      a = f.sibling;
      d2 = wh(f, { mode: "visible", children: d2.children });
      0 === (b.mode & 1) && (d2.lanes = c);
      d2.return = b;
      d2.sibling = null;
      null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
      b.child = d2;
      b.memoizedState = null;
      return d2;
    }
    __name(pj, "pj");
    function rj(a, b) {
      b = qj({ mode: "visible", children: b }, a.mode, 0, null);
      b.return = a;
      return a.child = b;
    }
    __name(rj, "rj");
    function tj(a, b, c, d2) {
      null !== d2 && Jg(d2);
      Bh(b, a.child, null, c);
      a = rj(b, b.pendingProps.children);
      a.flags |= 2;
      b.memoizedState = null;
      return a;
    }
    __name(tj, "tj");
    function sj(a, b, c, d2, e, f, g) {
      if (c) {
        if (b.flags & 256) return b.flags &= -257, d2 = Li(Error(p(422))), tj(a, b, g, d2);
        if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
        f = d2.fallback;
        e = b.mode;
        d2 = qj({ mode: "visible", children: d2.children }, e, 0, null);
        f = Ah(f, e, g, null);
        f.flags |= 2;
        d2.return = b;
        f.return = b;
        d2.sibling = f;
        b.child = d2;
        0 !== (b.mode & 1) && Bh(b, a.child, null, g);
        b.child.memoizedState = oj(g);
        b.memoizedState = nj;
        return f;
      }
      if (0 === (b.mode & 1)) return tj(a, b, g, null);
      if ("$!" === e.data) {
        d2 = e.nextSibling && e.nextSibling.dataset;
        if (d2) var h = d2.dgst;
        d2 = h;
        f = Error(p(419));
        d2 = Li(f, d2, void 0);
        return tj(a, b, g, d2);
      }
      h = 0 !== (g & a.childLanes);
      if (Ug || h) {
        d2 = R;
        if (null !== d2) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = 0 !== (e & (d2.suspendedLanes | g)) ? 0 : e;
          0 !== e && e !== f.retryLane && (f.retryLane = e, Zg(a, e), mh(d2, a, e, -1));
        }
        uj();
        d2 = Li(Error(p(421)));
        return tj(a, b, g, d2);
      }
      if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
      a = f.treeContext;
      yg = Lf(e.nextSibling);
      xg = b;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
      b = rj(b, d2.children);
      b.flags |= 4096;
      return b;
    }
    __name(sj, "sj");
    function wj(a, b, c) {
      a.lanes |= b;
      var d2 = a.alternate;
      null !== d2 && (d2.lanes |= b);
      Sg(a.return, b, c);
    }
    __name(wj, "wj");
    function xj(a, b, c, d2, e) {
      var f = a.memoizedState;
      null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d2, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d2, f.tail = c, f.tailMode = e);
    }
    __name(xj, "xj");
    function yj(a, b, c) {
      var d2 = b.pendingProps, e = d2.revealOrder, f = d2.tail;
      Yi(a, b, d2.children, c);
      d2 = M.current;
      if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
          if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);
          else if (19 === a.tag) wj(a, c, b);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b) break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b) break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
        d2 &= 1;
      }
      G(M, d2);
      if (0 === (b.mode & 1)) b.memoizedState = null;
      else switch (e) {
        case "forwards":
          c = b.child;
          for (e = null; null !== c; ) a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
          c = e;
          null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
          xj(b, false, e, c, f);
          break;
        case "backwards":
          c = null;
          e = b.child;
          for (b.child = null; null !== e; ) {
            a = e.alternate;
            if (null !== a && null === Mh(a)) {
              b.child = e;
              break;
            }
            a = e.sibling;
            e.sibling = c;
            c = e;
            e = a;
          }
          xj(b, true, c, null, f);
          break;
        case "together":
          xj(b, false, null, null, void 0);
          break;
        default:
          b.memoizedState = null;
      }
      return b.child;
    }
    __name(yj, "yj");
    function jj(a, b) {
      0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
    }
    __name(jj, "jj");
    function $i(a, b, c) {
      null !== a && (b.dependencies = a.dependencies);
      hh |= b.lanes;
      if (0 === (c & b.childLanes)) return null;
      if (null !== a && b.child !== a.child) throw Error(p(153));
      if (null !== b.child) {
        a = b.child;
        c = wh(a, a.pendingProps);
        b.child = c;
        for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    __name($i, "$i");
    function zj(a, b, c) {
      switch (b.tag) {
        case 3:
          lj(b);
          Ig();
          break;
        case 5:
          Kh(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          Ih(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d2 = b.type._context, e = b.memoizedProps.value;
          G(Mg, d2._currentValue);
          d2._currentValue = e;
          break;
        case 13:
          d2 = b.memoizedState;
          if (null !== d2) {
            if (null !== d2.dehydrated) return G(M, M.current & 1), b.flags |= 128, null;
            if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
            G(M, M.current & 1);
            a = $i(a, b, c);
            return null !== a ? a.sibling : null;
          }
          G(M, M.current & 1);
          break;
        case 19:
          d2 = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d2) return yj(a, b, c);
            b.flags |= 128;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          G(M, M.current);
          if (d2) break;
          else return null;
        case 22:
        case 23:
          return b.lanes = 0, ej(a, b, c);
      }
      return $i(a, b, c);
    }
    __name(zj, "zj");
    var Aj;
    var Bj;
    var Cj;
    var Dj;
    Aj = /* @__PURE__ */ __name(function(a, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b) break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b) return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    }, "Aj");
    Bj = /* @__PURE__ */ __name(function() {
    }, "Bj");
    Cj = /* @__PURE__ */ __name(function(a, b, c, d2) {
      var e = a.memoizedProps;
      if (e !== d2) {
        a = b.stateNode;
        Hh(Eh.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya(a, e);
            d2 = Ya(a, d2);
            f = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 });
            d2 = A({}, d2, { value: void 0 });
            f = [];
            break;
          case "textarea":
            e = gb(a, e);
            d2 = gb(a, d2);
            f = [];
            break;
          default:
            "function" !== typeof e.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
        }
        ub(c, d2);
        var g;
        c = null;
        for (l in e) if (!d2.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
          var h = e[l];
          for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
        for (l in d2) {
          var k = d2[l];
          h = null != e ? e[l] : void 0;
          if (d2.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
            for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else c || (f || (f = []), f.push(
            l,
            c
          )), c = k;
          else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        if (b.updateQueue = l) b.flags |= 4;
      }
    }, "Cj");
    Dj = /* @__PURE__ */ __name(function(a, b, c, d2) {
      c !== d2 && (b.flags |= 4);
    }, "Dj");
    function Ej(a, b) {
      if (!I) switch (a.tailMode) {
        case "hidden":
          b = a.tail;
          for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
          null === c ? a.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = a.tail;
          for (var d2 = null; null !== c; ) null !== c.alternate && (d2 = c), c = c.sibling;
          null === d2 ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
      }
    }
    __name(Ej, "Ej");
    function S(a) {
      var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d2 = 0;
      if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d2 |= e.subtreeFlags & 14680064, d2 |= e.flags & 14680064, e.return = a, e = e.sibling;
      else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d2 |= e.subtreeFlags, d2 |= e.flags, e.return = a, e = e.sibling;
      a.subtreeFlags |= d2;
      a.childLanes = c;
      return b;
    }
    __name(S, "S");
    function Fj(a, b, c) {
      var d2 = b.pendingProps;
      wg(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          d2 = b.stateNode;
          Jh();
          E(Wf);
          E(H);
          Oh();
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a, b);
          S(b);
          return null;
        case 5:
          Lh(b);
          var e = Hh(Gh.current);
          c = b.type;
          if (null !== a && null != b.stateNode) Cj(a, b, c, d2, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d2) {
              if (null === b.stateNode) throw Error(p(166));
              S(b);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b)) {
              d2 = b.stateNode;
              c = b.type;
              var f = b.memoizedProps;
              d2[Of] = b;
              d2[Pf] = f;
              a = 0 !== (b.mode & 1);
              switch (c) {
                case "dialog":
                  D("cancel", d2);
                  D("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d2);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], d2);
                  break;
                case "source":
                  D("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d2
                  );
                  D("load", d2);
                  break;
                case "details":
                  D("toggle", d2);
                  break;
                case "input":
                  Za(d2, f);
                  D("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f.multiple };
                  D("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f), D("invalid", d2);
              }
              ub(c, f);
              e = null;
              for (var g in f) if (f.hasOwnProperty(g)) {
                var h = f[g];
                "children" === g ? "string" === typeof h ? d2.textContent !== h && (true !== f.suppressHydrationWarning && Af(d2.textContent, h, a), e = ["children", h]) : "number" === typeof h && d2.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                  d2.textContent,
                  h,
                  a
                ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d2);
              }
              switch (c) {
                case "input":
                  Va(d2);
                  db(d2, f, true);
                  break;
                case "textarea":
                  Va(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f.onClick && (d2.onclick = Bf);
              }
              d2 = e;
              b.updateQueue = d2;
              null !== d2 && (b.flags |= 4);
            } else {
              g = 9 === e.nodeType ? e : e.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g.createElement(c, { is: d2.is }) : (a = g.createElement(c), "select" === c && (g = a, d2.multiple ? g.multiple = true : d2.size && (g.size = d2.size))) : a = g.createElementNS(a, c);
              a[Of] = b;
              a[Pf] = d2;
              Aj(a, b, false, false);
              b.stateNode = a;
              a: {
                g = vb(c, d2);
                switch (c) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e = d2;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e = d2;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], a);
                    e = d2;
                    break;
                  case "source":
                    D("error", a);
                    e = d2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e = d2;
                    break;
                  case "details":
                    D("toggle", a);
                    e = d2;
                    break;
                  case "input":
                    Za(a, d2);
                    e = Ya(a, d2);
                    D("invalid", a);
                    break;
                  case "option":
                    e = d2;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d2.multiple };
                    e = A({}, d2, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d2);
                    e = gb(a, d2);
                    D("invalid", a);
                    break;
                  default:
                    e = d2;
                }
                ub(c, e);
                h = e;
                for (f in h) if (h.hasOwnProperty(f)) {
                  var k = h[f];
                  "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                }
                switch (c) {
                  case "input":
                    Va(a);
                    db(a, d2, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                    break;
                  case "select":
                    a.multiple = !!d2.multiple;
                    f = d2.value;
                    null != f ? fb(a, !!d2.multiple, f, false) : null != d2.defaultValue && fb(
                      a,
                      !!d2.multiple,
                      d2.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = Bf);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d2 = !!d2.autoFocus;
                    break a;
                  case "img":
                    d2 = true;
                    break a;
                  default:
                    d2 = false;
                }
              }
              d2 && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          }
          S(b);
          return null;
        case 6:
          if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b.stateNode) throw Error(p(166));
            c = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b)) {
              d2 = b.stateNode;
              c = b.memoizedProps;
              d2[Of] = b;
              if (f = d2.nodeValue !== c) {
                if (a = xg, null !== a) switch (a.tag) {
                  case 3:
                    Af(d2.nodeValue, c, 0 !== (a.mode & 1));
                    break;
                  case 5:
                    true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c, 0 !== (a.mode & 1));
                }
              }
              f && (b.flags |= 4);
            } else d2 = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d2), d2[Of] = b, b.stateNode = d2;
          }
          S(b);
          return null;
        case 13:
          E(M);
          d2 = b.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
            else if (f = Gg(b), null !== d2 && null !== d2.dehydrated) {
              if (null === a) {
                if (!f) throw Error(p(318));
                f = b.memoizedState;
                f = null !== f ? f.dehydrated : null;
                if (!f) throw Error(p(317));
                f[Of] = b;
              } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b);
              f = false;
            } else null !== zg && (Gj(zg), zg = null), f = true;
            if (!f) return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128)) return b.lanes = c, b;
          d2 = null !== d2;
          d2 !== (null !== a && null !== a.memoizedState) && d2 && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return Rg(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          E(M);
          f = b.memoizedState;
          if (null === f) return S(b), null;
          d2 = 0 !== (b.flags & 128);
          g = f.rendering;
          if (null === g) if (d2) Ej(f, false);
          else {
            if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
              g = Mh(a);
              if (null !== g) {
                b.flags |= 128;
                Ej(f, false);
                d2 = g.updateQueue;
                null !== d2 && (b.updateQueue = d2, b.flags |= 4);
                b.subtreeFlags = 0;
                d2 = c;
                for (c = b.child; null !== c; ) f = c, a = d2, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G(M, M.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
            null !== f.tail && B() > Hj && (b.flags |= 128, d2 = true, Ej(f, false), b.lanes = 4194304);
          }
          else {
            if (!d2) if (a = Mh(g), null !== a) {
              if (b.flags |= 128, d2 = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
            } else 2 * B() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d2 = true, Ej(f, false), b.lanes = 4194304);
            f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
          }
          if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d2 ? c & 1 | 2 : c & 1), b;
          S(b);
          return null;
        case 22:
        case 23:
          return Ij(), d2 = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b.flags |= 8192), d2 && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    __name(Fj, "Fj");
    function Jj(a, b) {
      wg(b);
      switch (b.tag) {
        case 1:
          return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 3:
          return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
        case 5:
          return Lh(b), null;
        case 13:
          E(M);
          a = b.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b.alternate) throw Error(p(340));
            Ig();
          }
          a = b.flags;
          return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 19:
          return E(M), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    __name(Jj, "Jj");
    var Kj = false;
    var U = false;
    var Lj = "function" === typeof WeakSet ? WeakSet : Set;
    var V = null;
    function Mj(a, b) {
      var c = a.ref;
      if (null !== c) if ("function" === typeof c) try {
        c(null);
      } catch (d2) {
        W(a, b, d2);
      }
      else c.current = null;
    }
    __name(Mj, "Mj");
    function Nj(a, b, c) {
      try {
        c();
      } catch (d2) {
        W(a, b, d2);
      }
    }
    __name(Nj, "Nj");
    var Oj = false;
    function Pj(a, b) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
        else a: {
          c = (c = a.ownerDocument) && c.defaultView || window;
          var d2 = c.getSelection && c.getSelection();
          if (d2 && 0 !== d2.rangeCount) {
            c = d2.anchorNode;
            var e = d2.anchorOffset, f = d2.focusNode;
            d2 = d2.focusOffset;
            try {
              c.nodeType, f.nodeType;
            } catch (F) {
              c = null;
              break a;
            }
            var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
            b: for (; ; ) {
              for (var y; ; ) {
                q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                q !== f || 0 !== d2 && 3 !== q.nodeType || (k = g + d2);
                3 === q.nodeType && (g += q.nodeValue.length);
                if (null === (y = q.firstChild)) break;
                r = q;
                q = y;
              }
              for (; ; ) {
                if (q === a) break b;
                r === c && ++l === e && (h = g);
                r === f && ++m === d2 && (k = g);
                if (null !== (y = q.nextSibling)) break;
                q = r;
                r = q.parentNode;
              }
              q = y;
            }
            c = -1 === h || -1 === k ? null : { start: h, end: k };
          } else c = null;
        }
        c = c || { start: 0, end: 0 };
      } else c = null;
      Df = { focusedElem: a, selectionRange: c };
      dd = false;
      for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
      else for (; null !== V; ) {
        b = V;
        try {
          var n = b.alternate;
          if (0 !== (b.flags & 1024)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (null !== n) {
                var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Lg(b.type, t), J);
                x.__reactInternalSnapshotBeforeUpdate = w;
              }
              break;
            case 3:
              var u = b.stateNode.containerInfo;
              1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(p(163));
          }
        } catch (F) {
          W(b, b.return, F);
        }
        a = b.sibling;
        if (null !== a) {
          a.return = b.return;
          V = a;
          break;
        }
        V = b.return;
      }
      n = Oj;
      Oj = false;
      return n;
    }
    __name(Pj, "Pj");
    function Qj(a, b, c) {
      var d2 = b.updateQueue;
      d2 = null !== d2 ? d2.lastEffect : null;
      if (null !== d2) {
        var e = d2 = d2.next;
        do {
          if ((e.tag & a) === a) {
            var f = e.destroy;
            e.destroy = void 0;
            void 0 !== f && Nj(b, c, f);
          }
          e = e.next;
        } while (e !== d2);
      }
    }
    __name(Qj, "Qj");
    function Rj(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d2 = c.create;
            c.destroy = d2();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    __name(Rj, "Rj");
    function Sj(a) {
      var b = a.ref;
      if (null !== b) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        "function" === typeof b ? b(a) : b.current = a;
      }
    }
    __name(Sj, "Sj");
    function Tj(a) {
      var b = a.alternate;
      null !== b && (a.alternate = null, Tj(b));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    __name(Tj, "Tj");
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    __name(Uj, "Uj");
    function Vj(a) {
      a: for (; ; ) {
        for (; null === a.sibling; ) {
          if (null === a.return || Uj(a.return)) return null;
          a = a.return;
        }
        a.sibling.return = a.return;
        for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
          if (a.flags & 2) continue a;
          if (null === a.child || 4 === a.tag) continue a;
          else a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2)) return a.stateNode;
      }
    }
    __name(Vj, "Vj");
    function Wj(a, b, c) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
      else if (4 !== d2 && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
    }
    __name(Wj, "Wj");
    function Xj(a, b, c) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (4 !== d2 && (a = a.child, null !== a)) for (Xj(a, b, c), a = a.sibling; null !== a; ) Xj(a, b, c), a = a.sibling;
    }
    __name(Xj, "Xj");
    var X = null;
    var Yj = false;
    function Zj(a, b, c) {
      for (c = c.child; null !== c; ) ak(a, b, c), c = c.sibling;
    }
    __name(Zj, "Zj");
    function ak(a, b, c) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
        lc.onCommitFiberUnmount(kc, c);
      } catch (h) {
      }
      switch (c.tag) {
        case 5:
          U || Mj(c, b);
        case 6:
          var d2 = X, e = Yj;
          X = null;
          Zj(a, b, c);
          X = d2;
          Yj = e;
          null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
          break;
        case 18:
          null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
          break;
        case 4:
          d2 = X;
          e = Yj;
          X = c.stateNode.containerInfo;
          Yj = true;
          Zj(a, b, c);
          X = d2;
          Yj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d2 = c.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
            e = d2 = d2.next;
            do {
              var f = e, g = f.destroy;
              f = f.tag;
              void 0 !== g && (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
              e = e.next;
            } while (e !== d2);
          }
          Zj(a, b, c);
          break;
        case 1:
          if (!U && (Mj(c, b), d2 = c.stateNode, "function" === typeof d2.componentWillUnmount)) try {
            d2.props = c.memoizedProps, d2.state = c.memoizedState, d2.componentWillUnmount();
          } catch (h) {
            W(c, b, h);
          }
          Zj(a, b, c);
          break;
        case 21:
          Zj(a, b, c);
          break;
        case 22:
          c.mode & 1 ? (U = (d2 = U) || null !== c.memoizedState, Zj(a, b, c), U = d2) : Zj(a, b, c);
          break;
        default:
          Zj(a, b, c);
      }
    }
    __name(ak, "ak");
    function bk(a) {
      var b = a.updateQueue;
      if (null !== b) {
        a.updateQueue = null;
        var c = a.stateNode;
        null === c && (c = a.stateNode = new Lj());
        b.forEach(function(b2) {
          var d2 = ck.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d2, d2));
        });
      }
    }
    __name(bk, "bk");
    function dk(a, b) {
      var c = b.deletions;
      if (null !== c) for (var d2 = 0; d2 < c.length; d2++) {
        var e = c[d2];
        try {
          var f = a, g = b, h = g;
          a: for (; null !== h; ) {
            switch (h.tag) {
              case 5:
                X = h.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h = h.return;
          }
          if (null === X) throw Error(p(160));
          ak(f, g, e);
          X = null;
          Yj = false;
          var k = e.alternate;
          null !== k && (k.return = null);
          e.return = null;
        } catch (l) {
          W(e, b, l);
        }
      }
      if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) ek(b, a), b = b.sibling;
    }
    __name(dk, "dk");
    function ek(a, b) {
      var c = a.alternate, d2 = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b, a);
          fk(a);
          if (d2 & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t) {
              W(a, a.return, t);
            }
            try {
              Qj(5, a, a.return);
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 1:
          dk(b, a);
          fk(a);
          d2 & 512 && null !== c && Mj(c, c.return);
          break;
        case 5:
          dk(b, a);
          fk(a);
          d2 & 512 && null !== c && Mj(c, c.return);
          if (a.flags & 32) {
            var e = a.stateNode;
            try {
              ob(e, "");
            } catch (t) {
              W(a, a.return, t);
            }
          }
          if (d2 & 4 && (e = a.stateNode, null != e)) {
            var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
            a.updateQueue = null;
            if (null !== k) try {
              "input" === h && "radio" === f.type && null != f.name && ab(e, f);
              vb(h, g);
              var l = vb(h, f);
              for (g = 0; g < k.length; g += 2) {
                var m = k[g], q = k[g + 1];
                "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
              }
              switch (h) {
                case "input":
                  bb(e, f);
                  break;
                case "textarea":
                  ib(e, f);
                  break;
                case "select":
                  var r = e._wrapperState.wasMultiple;
                  e._wrapperState.wasMultiple = !!f.multiple;
                  var y = f.value;
                  null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                    e,
                    !!f.multiple,
                    f.defaultValue,
                    true
                  ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
              }
              e[Pf] = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 6:
          dk(b, a);
          fk(a);
          if (d2 & 4) {
            if (null === a.stateNode) throw Error(p(162));
            e = a.stateNode;
            f = a.memoizedProps;
            try {
              e.nodeValue = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 3:
          dk(b, a);
          fk(a);
          if (d2 & 4 && null !== c && c.memoizedState.isDehydrated) try {
            bd(b.containerInfo);
          } catch (t) {
            W(a, a.return, t);
          }
          break;
        case 4:
          dk(b, a);
          fk(a);
          break;
        case 13:
          dk(b, a);
          fk(a);
          e = a.child;
          e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
          d2 & 4 && bk(a);
          break;
        case 22:
          m = null !== c && null !== c.memoizedState;
          a.mode & 1 ? (U = (l = U) || m, dk(b, a), U = l) : dk(b, a);
          fk(a);
          if (d2 & 8192) {
            l = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
              for (q = V = m; null !== V; ) {
                r = V;
                y = r.child;
                switch (r.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Qj(4, r, r.return);
                    break;
                  case 1:
                    Mj(r, r.return);
                    var n = r.stateNode;
                    if ("function" === typeof n.componentWillUnmount) {
                      d2 = r;
                      c = r.return;
                      try {
                        b = d2, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                      } catch (t) {
                        W(d2, c, t);
                      }
                    }
                    break;
                  case 5:
                    Mj(r, r.return);
                    break;
                  case 22:
                    if (null !== r.memoizedState) {
                      hk(q);
                      continue;
                    }
                }
                null !== y ? (y.return = r, V = y) : hk(q);
              }
              m = m.sibling;
            }
            a: for (m = null, q = a; ; ) {
              if (5 === q.tag) {
                if (null === m) {
                  m = q;
                  try {
                    e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
              } else if (6 === q.tag) {
                if (null === m) try {
                  q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                } catch (t) {
                  W(a, a.return, t);
                }
              } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                q.child.return = q;
                q = q.child;
                continue;
              }
              if (q === a) break a;
              for (; null === q.sibling; ) {
                if (null === q.return || q.return === a) break a;
                m === q && (m = null);
                q = q.return;
              }
              m === q && (m = null);
              q.sibling.return = q.return;
              q = q.sibling;
            }
          }
          break;
        case 19:
          dk(b, a);
          fk(a);
          d2 & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(
            b,
            a
          ), fk(a);
      }
    }
    __name(ek, "ek");
    function fk(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; null !== c; ) {
              if (Uj(c)) {
                var d2 = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d2.tag) {
            case 5:
              var e = d2.stateNode;
              d2.flags & 32 && (ob(e, ""), d2.flags &= -33);
              var f = Vj(a);
              Xj(a, f, e);
              break;
            case 3:
            case 4:
              var g = d2.stateNode.containerInfo, h = Vj(a);
              Wj(a, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k) {
          W(a, a.return, k);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    __name(fk, "fk");
    function ik(a, b, c) {
      V = a;
      jk(a, b, c);
    }
    __name(ik, "ik");
    function jk(a, b, c) {
      for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
        var e = V, f = e.child;
        if (22 === e.tag && d2) {
          var g = null !== e.memoizedState || Kj;
          if (!g) {
            var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
            h = Kj;
            var l = U;
            Kj = g;
            if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
            for (; null !== f; ) V = f, jk(f, b, c), f = f.sibling;
            V = e;
            Kj = h;
            U = l;
          }
          lk(a, b, c);
        } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : lk(a, b, c);
      }
    }
    __name(jk, "jk");
    function lk(a) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c = b.alternate;
          try {
            if (0 !== (b.flags & 8772)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                U || Rj(5, b);
                break;
              case 1:
                var d2 = b.stateNode;
                if (b.flags & 4 && !U) if (null === c) d2.componentDidMount();
                else {
                  var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                  d2.componentDidUpdate(e, c.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
                var f = b.updateQueue;
                null !== f && ih(b, f, d2);
                break;
              case 3:
                var g = b.updateQueue;
                if (null !== g) {
                  c = null;
                  if (null !== b.child) switch (b.child.tag) {
                    case 5:
                      c = b.child.stateNode;
                      break;
                    case 1:
                      c = b.child.stateNode;
                  }
                  ih(b, g, c);
                }
                break;
              case 5:
                var h = b.stateNode;
                if (null === c && b.flags & 4) {
                  c = h;
                  var k = b.memoizedProps;
                  switch (b.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      k.autoFocus && c.focus();
                      break;
                    case "img":
                      k.src && (c.src = k.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (null === b.memoizedState) {
                  var l = b.alternate;
                  if (null !== l) {
                    var m = l.memoizedState;
                    if (null !== m) {
                      var q = m.dehydrated;
                      null !== q && bd(q);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(p(163));
            }
            U || b.flags & 512 && Sj(b);
          } catch (r) {
            W(b, b.return, r);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    __name(lk, "lk");
    function hk(a) {
      for (; null !== V; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    __name(hk, "hk");
    function kk(a) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Rj(4, b);
              } catch (k) {
                W(b, c, k);
              }
              break;
            case 1:
              var d2 = b.stateNode;
              if ("function" === typeof d2.componentDidMount) {
                var e = b.return;
                try {
                  d2.componentDidMount();
                } catch (k) {
                  W(b, e, k);
                }
              }
              var f = b.return;
              try {
                Sj(b);
              } catch (k) {
                W(b, f, k);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Sj(b);
              } catch (k) {
                W(b, g, k);
              }
          }
        } catch (k) {
          W(b, b.return, k);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (null !== h) {
          h.return = b.return;
          V = h;
          break;
        }
        V = b.return;
      }
    }
    __name(kk, "kk");
    var mk = Math.ceil;
    var nk = ua.ReactCurrentDispatcher;
    var ok = ua.ReactCurrentOwner;
    var pk = ua.ReactCurrentBatchConfig;
    var K = 0;
    var R = null;
    var Y = null;
    var Z = 0;
    var gj = 0;
    var fj = Uf(0);
    var T = 0;
    var qk = null;
    var hh = 0;
    var rk = 0;
    var sk = 0;
    var tk = null;
    var uk = null;
    var gk = 0;
    var Hj = Infinity;
    var vk = null;
    var Pi = false;
    var Qi = null;
    var Si = null;
    var wk = false;
    var xk = null;
    var yk = 0;
    var zk = 0;
    var Ak = null;
    var Bk = -1;
    var Ck = 0;
    function L() {
      return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
    }
    __name(L, "L");
    function lh(a) {
      if (0 === (a.mode & 1)) return 1;
      if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
      if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
      a = C;
      if (0 !== a) return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    __name(lh, "lh");
    function mh(a, b, c, d2) {
      if (50 < zk) throw zk = 0, Ak = null, Error(p(185));
      Ac(a, c, d2);
      if (0 === (K & 2) || a !== R) a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d2), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
    }
    __name(mh, "mh");
    function Ek(a, b) {
      var c = a.callbackNode;
      wc(a, b);
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
      else if (b = d2 & -d2, a.callbackPriority !== b) {
        null != c && bc(c);
        if (1 === b) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
          0 === (K & 6) && jg();
        }), c = null;
        else {
          switch (Dc(d2)) {
            case 1:
              c = fc;
              break;
            case 4:
              c = gc;
              break;
            case 16:
              c = hc;
              break;
            case 536870912:
              c = jc;
              break;
            default:
              c = hc;
          }
          c = Gk(c, Hk.bind(null, a));
        }
        a.callbackPriority = b;
        a.callbackNode = c;
      }
    }
    __name(Ek, "Ek");
    function Hk(a, b) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6)) throw Error(p(327));
      var c = a.callbackNode;
      if (Ik() && a.callbackNode !== c) return null;
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2) return null;
      if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b) b = Jk(a, d2);
      else {
        b = d2;
        var e = K;
        K |= 2;
        var f = Kk();
        if (R !== a || Z !== b) vk = null, Hj = B() + 500, Lk(a, b);
        do
          try {
            Mk();
            break;
          } catch (h) {
            Nk(a, h);
          }
        while (1);
        Qg();
        nk.current = f;
        K = e;
        null !== Y ? b = 0 : (R = null, Z = 0, b = T);
      }
      if (0 !== b) {
        2 === b && (e = xc(a), 0 !== e && (d2 = e, b = Ok(a, e)));
        if (1 === b) throw c = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c;
        if (6 === b) Dk(a, d2);
        else {
          e = a.current.alternate;
          if (0 === (d2 & 30) && !Pk(e) && (b = Jk(a, d2), 2 === b && (f = xc(a), 0 !== f && (d2 = f, b = Ok(a, f))), 1 === b)) throw c = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c;
          a.finishedWork = e;
          a.finishedLanes = d2;
          switch (b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d2);
              if ((d2 & 130023424) === d2 && (b = gk + 500 - B(), 10 < b)) {
                if (0 !== uc(a, 0)) break;
                e = a.suspendedLanes;
                if ((e & d2) !== d2) {
                  L();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d2);
              if ((d2 & 4194240) === d2) break;
              b = a.eventTimes;
              for (e = -1; 0 < d2; ) {
                var g = 31 - oc(d2);
                f = 1 << g;
                g = b[g];
                g > e && (e = g);
                d2 &= ~f;
              }
              d2 = e;
              d2 = B() - d2;
              d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
              if (10 < d2) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      Ek(a, B());
      return a.callbackNode === c ? Hk.bind(null, a) : null;
    }
    __name(Hk, "Hk");
    function Ok(a, b) {
      var c = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
      a = Jk(a, b);
      2 !== a && (b = uk, uk = c, null !== b && Gj(b));
      return a;
    }
    __name(Ok, "Ok");
    function Gj(a) {
      null === uk ? uk = a : uk.push.apply(uk, a);
    }
    __name(Gj, "Gj");
    function Pk(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (null !== c && (c = c.stores, null !== c)) for (var d2 = 0; d2 < c.length; d2++) {
            var e = c[d2], f = e.getSnapshot;
            e = e.value;
            try {
              if (!He(f(), e)) return false;
            } catch (g) {
              return false;
            }
          }
        }
        c = b.child;
        if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
        else {
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    __name(Pk, "Pk");
    function Dk(a, b) {
      b &= ~sk;
      b &= ~rk;
      a.suspendedLanes |= b;
      a.pingedLanes &= ~b;
      for (a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc(b), d2 = 1 << c;
        a[c] = -1;
        b &= ~d2;
      }
    }
    __name(Dk, "Dk");
    function Fk(a) {
      if (0 !== (K & 6)) throw Error(p(327));
      Ik();
      var b = uc(a, 0);
      if (0 === (b & 1)) return Ek(a, B()), null;
      var c = Jk(a, b);
      if (0 !== a.tag && 2 === c) {
        var d2 = xc(a);
        0 !== d2 && (b = d2, c = Ok(a, d2));
      }
      if (1 === c) throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
      if (6 === c) throw Error(p(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b;
      Qk(a, uk, vk);
      Ek(a, B());
      return null;
    }
    __name(Fk, "Fk");
    function Rk(a, b) {
      var c = K;
      K |= 1;
      try {
        return a(b);
      } finally {
        K = c, 0 === K && (Hj = B() + 500, fg && jg());
      }
    }
    __name(Rk, "Rk");
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b = K;
      K |= 1;
      var c = pk.transition, d2 = C;
      try {
        if (pk.transition = null, C = 1, a) return a();
      } finally {
        C = d2, pk.transition = c, K = b, 0 === (K & 6) && jg();
      }
    }
    __name(Sk, "Sk");
    function Ij() {
      gj = fj.current;
      E(fj);
    }
    __name(Ij, "Ij");
    function Lk(a, b) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c = a.timeoutHandle;
      -1 !== c && (a.timeoutHandle = -1, Gf(c));
      if (null !== Y) for (c = Y.return; null !== c; ) {
        var d2 = c;
        wg(d2);
        switch (d2.tag) {
          case 1:
            d2 = d2.type.childContextTypes;
            null !== d2 && void 0 !== d2 && $f();
            break;
          case 3:
            Jh();
            E(Wf);
            E(H);
            Oh();
            break;
          case 5:
            Lh(d2);
            break;
          case 4:
            Jh();
            break;
          case 13:
            E(M);
            break;
          case 19:
            E(M);
            break;
          case 10:
            Rg(d2.type._context);
            break;
          case 22:
          case 23:
            Ij();
        }
        c = c.return;
      }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b = 0; b < Wg.length; b++) if (c = Wg[b], d2 = c.interleaved, null !== d2) {
          c.interleaved = null;
          var e = d2.next, f = c.pending;
          if (null !== f) {
            var g = f.next;
            f.next = e;
            d2.next = g;
          }
          c.pending = d2;
        }
        Wg = null;
      }
      return a;
    }
    __name(Lk, "Lk");
    function Nk(a, b) {
      do {
        var c = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d2 = N.memoizedState; null !== d2; ) {
              var e = d2.queue;
              null !== e && (e.pending = null);
              d2 = d2.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O = N = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c || null === c.return) {
            T = 1;
            qk = b;
            Y = null;
            break;
          }
          a: {
            var f = a, g = c.return, h = c, k = b;
            b = Z;
            h.flags |= 32768;
            if (null !== k && "object" === typeof k && "function" === typeof k.then) {
              var l = k, m = h, q = m.tag;
              if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                var r = m.alternate;
                r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
              }
              var y = Vi(g);
              if (null !== y) {
                y.flags &= -257;
                Wi(y, g, h, f, b);
                y.mode & 1 && Ti(f, l, b);
                b = y;
                k = l;
                var n = b.updateQueue;
                if (null === n) {
                  var t = /* @__PURE__ */ new Set();
                  t.add(k);
                  b.updateQueue = t;
                } else n.add(k);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Ti(f, l, b);
                  uj();
                  break a;
                }
                k = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J = Vi(g);
              if (null !== J) {
                0 === (J.flags & 65536) && (J.flags |= 256);
                Wi(J, g, h, f, b);
                Jg(Ki(k, h));
                break a;
              }
            }
            f = k = Ki(k, h);
            4 !== T && (T = 2);
            null === tk ? tk = [f] : tk.push(f);
            f = g;
            do {
              switch (f.tag) {
                case 3:
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var x = Oi(f, k, b);
                  fh(f, x);
                  break a;
                case 1:
                  h = k;
                  var w = f.type, u = f.stateNode;
                  if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Si || !Si.has(u)))) {
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var F = Ri(f, h, b);
                    fh(f, F);
                    break a;
                  }
              }
              f = f.return;
            } while (null !== f);
          }
          Tk(c);
        } catch (na) {
          b = na;
          Y === c && null !== c && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    __name(Nk, "Nk");
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    __name(Kk, "Kk");
    function uj() {
      if (0 === T || 3 === T || 2 === T) T = 4;
      null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
    }
    __name(uj, "uj");
    function Jk(a, b) {
      var c = K;
      K |= 2;
      var d2 = Kk();
      if (R !== a || Z !== b) vk = null, Lk(a, b);
      do
        try {
          Uk();
          break;
        } catch (e) {
          Nk(a, e);
        }
      while (1);
      Qg();
      K = c;
      nk.current = d2;
      if (null !== Y) throw Error(p(261));
      R = null;
      Z = 0;
      return T;
    }
    __name(Jk, "Jk");
    function Uk() {
      for (; null !== Y; ) Vk(Y);
    }
    __name(Uk, "Uk");
    function Mk() {
      for (; null !== Y && !cc(); ) Vk(Y);
    }
    __name(Mk, "Mk");
    function Vk(a) {
      var b = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b ? Tk(a) : Y = b;
      ok.current = null;
    }
    __name(Vk, "Vk");
    function Tk(a) {
      var b = a;
      do {
        var c = b.alternate;
        a = b.return;
        if (0 === (b.flags & 32768)) {
          if (c = Fj(c, b, gj), null !== c) {
            Y = c;
            return;
          }
        } else {
          c = Jj(c, b);
          if (null !== c) {
            c.flags &= 32767;
            Y = c;
            return;
          }
          if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (null !== b);
      0 === T && (T = 5);
    }
    __name(Tk, "Tk");
    function Qk(a, b, c) {
      var d2 = C, e = pk.transition;
      try {
        pk.transition = null, C = 1, Xk(a, b, c, d2);
      } finally {
        pk.transition = e, C = d2;
      }
      return null;
    }
    __name(Qk, "Qk");
    function Xk(a, b, c, d2) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6)) throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (null === c) return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c === a.current) throw Error(p(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f = c.lanes | c.childLanes;
      Bc(a, f);
      a === R && (Y = R = null, Z = 0);
      0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f = 0 !== (c.flags & 15990);
      if (0 !== (c.subtreeFlags & 15990) || f) {
        f = pk.transition;
        pk.transition = null;
        var g = C;
        C = 1;
        var h = K;
        K |= 4;
        ok.current = null;
        Pj(a, c);
        ek(c, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c;
        ik(c, a, e);
        dc();
        K = h;
        C = g;
        pk.transition = f;
      } else a.current = c;
      wk && (wk = false, xk = a, yk = e);
      f = a.pendingLanes;
      0 === f && (Si = null);
      mc(c.stateNode, d2);
      Ek(a, B());
      if (null !== b) for (d2 = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d2(e.value, { componentStack: e.stack, digest: e.digest });
      if (Pi) throw Pi = false, a = Qi, Qi = null, a;
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f = a.pendingLanes;
      0 !== (f & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
      jg();
      return null;
    }
    __name(Xk, "Xk");
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk), b = pk.transition, c = C;
        try {
          pk.transition = null;
          C = 16 > a ? 16 : a;
          if (null === xk) var d2 = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6)) throw Error(p(331));
            var e = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f = V, g = f.child;
              if (0 !== (V.flags & 16)) {
                var h = f.deletions;
                if (null !== h) {
                  for (var k = 0; k < h.length; k++) {
                    var l = h[k];
                    for (V = l; null !== V; ) {
                      var m = V;
                      switch (m.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m, f);
                      }
                      var q = m.child;
                      if (null !== q) q.return = m, V = q;
                      else for (; null !== V; ) {
                        m = V;
                        var r = m.sibling, y = m.return;
                        Tj(m);
                        if (m === l) {
                          V = null;
                          break;
                        }
                        if (null !== r) {
                          r.return = y;
                          V = r;
                          break;
                        }
                        V = y;
                      }
                    }
                  }
                  var n = f.alternate;
                  if (null !== n) {
                    var t = n.child;
                    if (null !== t) {
                      n.child = null;
                      do {
                        var J = t.sibling;
                        t.sibling = null;
                        t = J;
                      } while (null !== t);
                    }
                  }
                  V = f;
                }
              }
              if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
              else b: for (; null !== V; ) {
                f = V;
                if (0 !== (f.flags & 2048)) switch (f.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, f, f.return);
                }
                var x = f.sibling;
                if (null !== x) {
                  x.return = f.return;
                  V = x;
                  break b;
                }
                V = f.return;
              }
            }
            var w = a.current;
            for (V = w; null !== V; ) {
              g = V;
              var u = g.child;
              if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
              else b: for (g = w; null !== V; ) {
                h = V;
                if (0 !== (h.flags & 2048)) try {
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Rj(9, h);
                  }
                } catch (na) {
                  W(h, h.return, na);
                }
                if (h === g) {
                  V = null;
                  break b;
                }
                var F = h.sibling;
                if (null !== F) {
                  F.return = h.return;
                  V = F;
                  break b;
                }
                V = h.return;
              }
            }
            K = e;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
              lc.onPostCommitFiberRoot(kc, a);
            } catch (na) {
            }
            d2 = true;
          }
          return d2;
        } finally {
          C = c, pk.transition = b;
        }
      }
      return false;
    }
    __name(Ik, "Ik");
    function Yk(a, b, c) {
      b = Ki(c, b);
      b = Oi(a, b, 1);
      a = dh(a, b, 1);
      b = L();
      null !== a && (Ac(a, 1, b), Ek(a, b));
    }
    __name(Yk, "Yk");
    function W(a, b, c) {
      if (3 === a.tag) Yk(a, a, c);
      else for (; null !== b; ) {
        if (3 === b.tag) {
          Yk(b, a, c);
          break;
        } else if (1 === b.tag) {
          var d2 = b.stateNode;
          if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
            a = Ki(c, a);
            a = Ri(b, a, 1);
            b = dh(b, a, 1);
            a = L();
            null !== b && (Ac(b, 1, a), Ek(b, a));
            break;
          }
        }
        b = b.return;
      }
    }
    __name(W, "W");
    function Ui(a, b, c) {
      var d2 = a.pingCache;
      null !== d2 && d2.delete(b);
      b = L();
      a.pingedLanes |= a.suspendedLanes & c;
      R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
      Ek(a, b);
    }
    __name(Ui, "Ui");
    function Zk(a, b) {
      0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c = L();
      a = Zg(a, b);
      null !== a && (Ac(a, b, c), Ek(a, c));
    }
    __name(Zk, "Zk");
    function vj(a) {
      var b = a.memoizedState, c = 0;
      null !== b && (c = b.retryLane);
      Zk(a, c);
    }
    __name(vj, "vj");
    function ck(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d2 = a.stateNode;
          var e = a.memoizedState;
          null !== e && (c = e.retryLane);
          break;
        case 19:
          d2 = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      null !== d2 && d2.delete(b);
      Zk(a, c);
    }
    __name(ck, "ck");
    var Wk;
    Wk = /* @__PURE__ */ __name(function(a, b, c) {
      if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = true;
      else {
        if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return Ug = false, zj(a, b, c);
        Ug = 0 !== (a.flags & 131072) ? true : false;
      }
      else Ug = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d2 = b.type;
          jj(a, b);
          a = b.pendingProps;
          var e = Yf(b, H.current);
          Tg(b, c);
          e = Xh(null, b, d2, a, e, c);
          var f = bi();
          b.flags |= 1;
          "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d2) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d2, a, c), b = kj(null, b, d2, true, f, c)) : (b.tag = 0, I && f && vg(b), Yi(null, b, e, c), b = b.child);
          return b;
        case 16:
          d2 = b.elementType;
          a: {
            jj(a, b);
            a = b.pendingProps;
            e = d2._init;
            d2 = e(d2._payload);
            b.type = d2;
            e = b.tag = $k(d2);
            a = Lg(d2, a);
            switch (e) {
              case 0:
                b = dj(null, b, d2, a, c);
                break a;
              case 1:
                b = ij(null, b, d2, a, c);
                break a;
              case 11:
                b = Zi(null, b, d2, a, c);
                break a;
              case 14:
                b = aj(null, b, d2, Lg(d2.type, a), c);
                break a;
            }
            throw Error(p(
              306,
              d2,
              ""
            ));
          }
          return b;
        case 0:
          return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Lg(d2, e), dj(a, b, d2, e, c);
        case 1:
          return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Lg(d2, e), ij(a, b, d2, e, c);
        case 3:
          a: {
            lj(b);
            if (null === a) throw Error(p(387));
            d2 = b.pendingProps;
            f = b.memoizedState;
            e = f.element;
            bh(a, b);
            gh(b, d2, null, c);
            var g = b.memoizedState;
            d2 = g.element;
            if (f.isDehydrated) if (f = { element: d2, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
              e = Ki(Error(p(423)), b);
              b = mj(a, b, d2, c, e);
              break a;
            } else if (d2 !== e) {
              e = Ki(Error(p(424)), b);
              b = mj(a, b, d2, c, e);
              break a;
            } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Ch(b, null, d2, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
            else {
              Ig();
              if (d2 === e) {
                b = $i(a, b, c);
                break a;
              }
              Yi(a, b, d2, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Kh(b), null === a && Eg(b), d2 = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d2, e) ? g = null : null !== f && Ef(d2, f) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
        case 6:
          return null === a && Eg(b), null;
        case 13:
          return pj(a, b, c);
        case 4:
          return Ih(b, b.stateNode.containerInfo), d2 = b.pendingProps, null === a ? b.child = Bh(b, null, d2, c) : Yi(a, b, d2, c), b.child;
        case 11:
          return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Lg(d2, e), Zi(a, b, d2, e, c);
        case 7:
          return Yi(a, b, b.pendingProps, c), b.child;
        case 8:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d2 = b.type._context;
            e = b.pendingProps;
            f = b.memoizedProps;
            g = e.value;
            G(Mg, d2._currentValue);
            d2._currentValue = g;
            if (null !== f) if (He(f.value, g)) {
              if (f.children === e.children && !Wf.current) {
                b = $i(a, b, c);
                break a;
              }
            } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
              var h = f.dependencies;
              if (null !== h) {
                g = f.child;
                for (var k = h.firstContext; null !== k; ) {
                  if (k.context === d2) {
                    if (1 === f.tag) {
                      k = ch(-1, c & -c);
                      k.tag = 2;
                      var l = f.updateQueue;
                      if (null !== l) {
                        l = l.shared;
                        var m = l.pending;
                        null === m ? k.next = k : (k.next = m.next, m.next = k);
                        l.pending = k;
                      }
                    }
                    f.lanes |= c;
                    k = f.alternate;
                    null !== k && (k.lanes |= c);
                    Sg(
                      f.return,
                      c,
                      b
                    );
                    h.lanes |= c;
                    break;
                  }
                  k = k.next;
                }
              } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
              else if (18 === f.tag) {
                g = f.return;
                if (null === g) throw Error(p(341));
                g.lanes |= c;
                h = g.alternate;
                null !== h && (h.lanes |= c);
                Sg(g, c, b);
                g = f.sibling;
              } else g = f.child;
              if (null !== g) g.return = f;
              else for (g = f; null !== g; ) {
                if (g === b) {
                  g = null;
                  break;
                }
                f = g.sibling;
                if (null !== f) {
                  f.return = g.return;
                  g = f;
                  break;
                }
                g = g.return;
              }
              f = g;
            }
            Yi(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d2 = b.pendingProps.children, Tg(b, c), e = Vg(e), d2 = d2(e), b.flags |= 1, Yi(a, b, d2, c), b.child;
        case 14:
          return d2 = b.type, e = Lg(d2, b.pendingProps), e = Lg(d2.type, e), aj(a, b, d2, e, c);
        case 15:
          return cj(a, b, b.type, b.pendingProps, c);
        case 17:
          return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Lg(d2, e), jj(a, b), b.tag = 1, Zf(d2) ? (a = true, cg(b)) : a = false, Tg(b, c), ph(b, d2, e), rh(b, d2, e, c), kj(null, b, d2, true, a, c);
        case 19:
          return yj(a, b, c);
        case 22:
          return ej(a, b, c);
      }
      throw Error(p(156, b.tag));
    }, "Wk");
    function Gk(a, b) {
      return ac(a, b);
    }
    __name(Gk, "Gk");
    function al(a, b, c, d2) {
      this.tag = a;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    __name(al, "al");
    function Bg(a, b, c, d2) {
      return new al(a, b, c, d2);
    }
    __name(Bg, "Bg");
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    __name(bj, "bj");
    function $k(a) {
      if ("function" === typeof a) return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da) return 11;
        if (a === Ga) return 14;
      }
      return 2;
    }
    __name($k, "$k");
    function wh(a, b) {
      var c = a.alternate;
      null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
      c.flags = a.flags & 14680064;
      c.childLanes = a.childLanes;
      c.lanes = a.lanes;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    __name(wh, "wh");
    function yh(a, b, c, d2, e, f) {
      var g = 2;
      d2 = a;
      if ("function" === typeof a) bj(a) && (g = 1);
      else if ("string" === typeof a) g = 5;
      else a: switch (a) {
        case ya:
          return Ah(c.children, e, f, b);
        case za:
          g = 8;
          e |= 8;
          break;
        case Aa:
          return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
        case Ea:
          return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
        case Fa:
          return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
        case Ia:
          return qj(c, e, f, b);
        default:
          if ("object" === typeof a && null !== a) switch (a.$$typeof) {
            case Ba:
              g = 10;
              break a;
            case Ca:
              g = 9;
              break a;
            case Da:
              g = 11;
              break a;
            case Ga:
              g = 14;
              break a;
            case Ha:
              g = 16;
              d2 = null;
              break a;
          }
          throw Error(p(130, null == a ? a : typeof a, ""));
      }
      b = Bg(g, c, b, e);
      b.elementType = a;
      b.type = d2;
      b.lanes = f;
      return b;
    }
    __name(yh, "yh");
    function Ah(a, b, c, d2) {
      a = Bg(7, a, d2, b);
      a.lanes = c;
      return a;
    }
    __name(Ah, "Ah");
    function qj(a, b, c, d2) {
      a = Bg(22, a, d2, b);
      a.elementType = Ia;
      a.lanes = c;
      a.stateNode = { isHidden: false };
      return a;
    }
    __name(qj, "qj");
    function xh(a, b, c) {
      a = Bg(6, a, null, b);
      a.lanes = c;
      return a;
    }
    __name(xh, "xh");
    function zh(a, b, c) {
      b = Bg(4, null !== a.children ? a.children : [], a.key, b);
      b.lanes = c;
      b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b;
    }
    __name(zh, "zh");
    function bl(a, b, c, d2, e) {
      this.tag = b;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d2;
      this.onRecoverableError = e;
      this.mutableSourceEagerHydrationData = null;
    }
    __name(bl, "bl");
    function cl(a, b, c, d2, e, f, g, h, k) {
      a = new bl(a, b, c, h, k);
      1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
      f = Bg(3, null, null, b);
      a.current = f;
      f.stateNode = a;
      f.memoizedState = { element: d2, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f);
      return a;
    }
    __name(cl, "cl");
    function dl(a, b, c) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b, implementation: c };
    }
    __name(dl, "dl");
    function el(a) {
      if (!a) return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p(171));
      }
      if (1 === a.tag) {
        var c = a.type;
        if (Zf(c)) return bg(a, c, b);
      }
      return b;
    }
    __name(el, "el");
    function fl(a, b, c, d2, e, f, g, h, k) {
      a = cl(c, d2, true, a, e, f, g, h, k);
      a.context = el(null);
      c = a.current;
      d2 = L();
      e = lh(c);
      f = ch(d2, e);
      f.callback = void 0 !== b && null !== b ? b : null;
      dh(c, f, e);
      a.current.lanes = e;
      Ac(a, e, d2);
      Ek(a, d2);
      return a;
    }
    __name(fl, "fl");
    function gl(a, b, c, d2) {
      var e = b.current, f = L(), g = lh(e);
      c = el(c);
      null === b.context ? b.context = c : b.pendingContext = c;
      b = ch(f, g);
      b.payload = { element: a };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b.callback = d2);
      a = dh(e, b, g);
      null !== a && (mh(a, e, g, f), eh(a, e, g));
      return g;
    }
    __name(gl, "gl");
    function hl(a) {
      a = a.current;
      if (!a.child) return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    __name(hl, "hl");
    function il(a, b) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c = a.retryLane;
        a.retryLane = 0 !== c && c < b ? c : b;
      }
    }
    __name(il, "il");
    function jl(a, b) {
      il(a, b);
      (a = a.alternate) && il(a, b);
    }
    __name(jl, "jl");
    function kl() {
      return null;
    }
    __name(kl, "kl");
    var ll = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ml(a) {
      this._internalRoot = a;
    }
    __name(ml, "ml");
    nl.prototype.render = ml.prototype.render = function(a) {
      var b = this._internalRoot;
      if (null === b) throw Error(p(409));
      gl(a, b, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Sk(function() {
          gl(null, a, null, null);
        });
        b[uf] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    __name(nl, "nl");
    nl.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b = Hc();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
        Qc.splice(c, 0, a);
        0 === c && Vc(a);
      }
    };
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    __name(ol, "ol");
    function pl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    __name(pl, "pl");
    function ql() {
    }
    __name(ql, "ql");
    function rl(a, b, c, d2, e) {
      if (e) {
        if ("function" === typeof d2) {
          var f = d2;
          d2 = /* @__PURE__ */ __name(function() {
            var a2 = hl(g);
            f.call(a2);
          }, "d");
        }
        var g = fl(b, d2, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g;
        a[uf] = g.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g;
      }
      for (; e = a.lastChild; ) a.removeChild(e);
      if ("function" === typeof d2) {
        var h = d2;
        d2 = /* @__PURE__ */ __name(function() {
          var a2 = hl(k);
          h.call(a2);
        }, "d");
      }
      var k = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k;
      a[uf] = k.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function() {
        gl(b, k, c, d2);
      });
      return k;
    }
    __name(rl, "rl");
    function sl(a, b, c, d2, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f;
        if ("function" === typeof e) {
          var h = e;
          e = /* @__PURE__ */ __name(function() {
            var a2 = hl(g);
            h.call(a2);
          }, "e");
        }
        gl(b, g, a, e);
      } else g = rl(c, b, a, e, d2);
      return hl(g);
    }
    __name(sl, "sl");
    Ec = /* @__PURE__ */ __name(function(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc(b.pendingLanes);
            0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b2 = Zg(a, 1);
            if (null !== b2) {
              var c2 = L();
              mh(b2, a, 1, c2);
            }
          }), jl(a, 1);
      }
    }, "Ec");
    Fc = /* @__PURE__ */ __name(function(a) {
      if (13 === a.tag) {
        var b = Zg(a, 134217728);
        if (null !== b) {
          var c = L();
          mh(b, a, 134217728, c);
        }
        jl(a, 134217728);
      }
    }, "Fc");
    Gc = /* @__PURE__ */ __name(function(a) {
      if (13 === a.tag) {
        var b = lh(a), c = Zg(a, b);
        if (null !== c) {
          var d2 = L();
          mh(c, a, b, d2);
        }
        jl(a, b);
      }
    }, "Gc");
    Hc = /* @__PURE__ */ __name(function() {
      return C;
    }, "Hc");
    Ic = /* @__PURE__ */ __name(function(a, b) {
      var c = C;
      try {
        return C = a, b();
      } finally {
        C = c;
      }
    }, "Ic");
    yb = /* @__PURE__ */ __name(function(a, b, c) {
      switch (b) {
        case "input":
          bb(a, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a; c.parentNode; ) c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d2 = c[b];
              if (d2 !== a && d2.form === a.form) {
                var e = Db(d2);
                if (!e) throw Error(p(90));
                Wa(d2);
                bb(d2, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          b = c.value, null != b && fb(a, !!c.multiple, b, false);
      }
    }, "yb");
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] };
    var ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: /* @__PURE__ */ __name(function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, "findHostInstanceByFiber"), findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber) try {
        kc = wl.inject(vl), lc = wl;
      } catch (a) {
      }
    }
    var wl;
    exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    exports2.createPortal = function(a, b) {
      var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b)) throw Error(p(200));
      return dl(a, b, null, c);
    };
    exports2.createRoot = function(a, b) {
      if (!ol(a)) throw Error(p(299));
      var c = false, d2 = "", e = ll;
      null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d2 = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
      b = cl(a, 1, false, null, null, c, false, d2, e);
      a[uf] = b.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b);
    };
    exports2.findDOMNode = function(a) {
      if (null == a) return null;
      if (1 === a.nodeType) return a;
      var b = a._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a.render) throw Error(p(188));
        a = Object.keys(a).join(",");
        throw Error(p(268, a));
      }
      a = Zb(b);
      a = null === a ? null : a.stateNode;
      return a;
    };
    exports2.flushSync = function(a) {
      return Sk(a);
    };
    exports2.hydrate = function(a, b, c) {
      if (!pl(b)) throw Error(p(200));
      return sl(null, a, b, true, c);
    };
    exports2.hydrateRoot = function(a, b, c) {
      if (!ol(a)) throw Error(p(405));
      var d2 = null != c && c.hydratedSources || null, e = false, f = "", g = ll;
      null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
      b = fl(b, null, a, 1, null != c ? c : null, e, false, f, g);
      a[uf] = b.current;
      sf(a);
      if (d2) for (a = 0; a < d2.length; a++) c = d2[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
        c,
        e
      );
      return new nl(b);
    };
    exports2.render = function(a, b, c) {
      if (!pl(b)) throw Error(p(200));
      return sl(null, a, b, false, c);
    };
    exports2.unmountComponentAtNode = function(a) {
      if (!pl(a)) throw Error(p(40));
      return a._reactRootContainer ? (Sk(function() {
        sl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    exports2.unstable_batchedUpdates = Rk;
    exports2.unstable_renderSubtreeIntoContainer = function(a, b, c, d2) {
      if (!pl(c)) throw Error(p(200));
      if (null == a || void 0 === a._reactInternals) throw Error(p(38));
      return sl(a, b, c, false, d2);
    };
    exports2.version = "18.2.0-next-9e3b772b8-20220608";
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    __name(checkDCE, "checkDCE");
    if (true) {
      checkDCE();
      module2.exports = require_react_dom_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports2) {
    "use strict";
    init_process_shim();
    var m = require_react_dom();
    if (true) {
      exports2.createRoot = m.createRoot;
      exports2.hydrateRoot = m.hydrateRoot;
    } else {
      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports2.createRoot = function(c, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.createRoot(c, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
      exports2.hydrateRoot = function(c, h, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.hydrateRoot(c, h, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
    }
    var i;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports2, module2) {
    init_process_shim();
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      var nativeCodeString = "[native code]";
      function classNames4() {
        var classes = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg) continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames4.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      __name(classNames4, "classNames");
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames4.default = classNames4;
        module2.exports = classNames4;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames4;
        });
      } else {
        window.classNames = classNames4;
      }
    })();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
init_process_shim();

// src/ScreenGardenPlugin.ts
init_process_shim();

// src/db/index.ts
init_process_shim();

// src/db/Database.ts
init_process_shim();

// src/services/account/AccountService.ts
init_process_shim();

// src/services/Service.ts
init_process_shim();
var import_obsidian = require("obsidian");
var _Service = class _Service extends import_obsidian.Events {
  constructor(plugin) {
    super();
    this.plugin = plugin;
  }
  get db() {
    return this.plugin.db;
  }
  register(cb) {
    this.plugin.register(cb);
  }
  registerEvent(ref) {
    this.plugin.registerEvent(ref);
  }
  trigger(name, ...data) {
    super.trigger("screengarden:" + name, ...data);
  }
  on(name, callback, ctx) {
    return super.on("screengarden:" + name, callback, ctx);
  }
  async onload() {
  }
  async onLayoutReady() {
  }
  async onunload() {
  }
};
__name(_Service, "Service");
var Service = _Service;

// src/services/account/AccountService.ts
var import_debug = __toESM(require_browser2());

// node_modules/dexie/import-wrapper.mjs
init_process_shim();
var import_dexie = __toESM(require_dexie(), 1);
var DexieSymbol = Symbol.for("Dexie");
var Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = import_dexie.default);
if (import_dexie.default.semVer !== Dexie.semVer) {
  throw new Error(`Two different versions of Dexie loaded in the same app: ${import_dexie.default.semVer} and ${Dexie.semVer}`);
}
var { liveQuery, mergeRanges, rangesOverlap, RangeSet, cmp, Entity, PropModSymbol, PropModification, replacePrefix } = Dexie;
var import_wrapper_default = Dexie;

// node_modules/lodash-es/lodash.js
init_process_shim();

// node_modules/lodash-es/isSymbol.js
init_process_shim();

// node_modules/lodash-es/_baseGetTag.js
init_process_shim();

// node_modules/lodash-es/_Symbol.js
init_process_shim();

// node_modules/lodash-es/_root.js
init_process_shim();

// node_modules/lodash-es/_freeGlobal.js
init_process_shim();
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
init_process_shim();
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
__name(getRawTag, "getRawTag");
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
init_process_shim();
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
__name(objectToString, "objectToString");
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
__name(baseGetTag, "baseGetTag");
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
init_process_shim();
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
__name(isObjectLike, "isObjectLike");
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
__name(isSymbol, "isSymbol");
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_baseToString.js
init_process_shim();

// node_modules/lodash-es/_arrayMap.js
init_process_shim();
function arrayMap(array, iteratee) {
  var index = -1, length3 = array == null ? 0 : array.length, result = Array(length3);
  while (++index < length3) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
__name(arrayMap, "arrayMap");
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
init_process_shim();
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
__name(baseToString, "baseToString");
var baseToString_default = baseToString;

// node_modules/lodash-es/toNumber.js
init_process_shim();

// node_modules/lodash-es/_baseTrim.js
init_process_shim();

// node_modules/lodash-es/_trimmedEndIndex.js
init_process_shim();
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
__name(trimmedEndIndex, "trimmedEndIndex");
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
__name(baseTrim, "baseTrim");
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
init_process_shim();
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
__name(isObject, "isObject");
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
__name(toNumber, "toNumber");
var toNumber_default = toNumber;

// node_modules/lodash-es/identity.js
init_process_shim();
function identity(value) {
  return value;
}
__name(identity, "identity");
var identity_default = identity;

// node_modules/lodash-es/_WeakMap.js
init_process_shim();

// node_modules/lodash-es/_getNative.js
init_process_shim();

// node_modules/lodash-es/_baseIsNative.js
init_process_shim();

// node_modules/lodash-es/isFunction.js
init_process_shim();
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
__name(isFunction, "isFunction");
var isFunction_default = isFunction;

// node_modules/lodash-es/_isMasked.js
init_process_shim();

// node_modules/lodash-es/_coreJsData.js
init_process_shim();
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
__name(isMasked, "isMasked");
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
init_process_shim();
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
__name(toSource, "toSource");
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
__name(baseIsNative, "baseIsNative");
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
init_process_shim();
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
__name(getValue, "getValue");
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
__name(getNative, "getNative");
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_apply.js
init_process_shim();
function apply(func, thisArg, args2) {
  switch (args2.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args2[0]);
    case 2:
      return func.call(thisArg, args2[0], args2[1]);
    case 3:
      return func.call(thisArg, args2[0], args2[1], args2[2]);
  }
  return func.apply(thisArg, args2);
}
__name(apply, "apply");
var apply_default = apply;

// node_modules/lodash-es/noop.js
init_process_shim();
function noop() {
}
__name(noop, "noop");
var noop_default = noop;

// node_modules/lodash-es/_shortOut.js
init_process_shim();
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
__name(shortOut, "shortOut");
var shortOut_default = shortOut;

// node_modules/lodash-es/_setToString.js
init_process_shim();

// node_modules/lodash-es/_baseSetToString.js
init_process_shim();

// node_modules/lodash-es/constant.js
init_process_shim();
function constant(value) {
  return function() {
    return value;
  };
}
__name(constant, "constant");
var constant_default = constant;

// node_modules/lodash-es/_defineProperty.js
init_process_shim();
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayIncludes.js
init_process_shim();

// node_modules/lodash-es/_baseIndexOf.js
init_process_shim();

// node_modules/lodash-es/_baseFindIndex.js
init_process_shim();
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length3 = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length3) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
__name(baseFindIndex, "baseFindIndex");
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
init_process_shim();
function baseIsNaN(value) {
  return value !== value;
}
__name(baseIsNaN, "baseIsNaN");
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
init_process_shim();
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1, length3 = array.length;
  while (++index < length3) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
__name(strictIndexOf, "strictIndexOf");
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
__name(baseIndexOf, "baseIndexOf");
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length3 = array == null ? 0 : array.length;
  return !!length3 && baseIndexOf_default(array, value, 0) > -1;
}
__name(arrayIncludes, "arrayIncludes");
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_isIndex.js
init_process_shim();
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length3) {
  var type = typeof value;
  length3 = length3 == null ? MAX_SAFE_INTEGER : length3;
  return !!length3 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
}
__name(isIndex, "isIndex");
var isIndex_default = isIndex;

// node_modules/lodash-es/eq.js
init_process_shim();
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
__name(eq, "eq");
var eq_default = eq;

// node_modules/lodash-es/_baseRest.js
init_process_shim();

// node_modules/lodash-es/_overRest.js
init_process_shim();
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args2 = arguments, index = -1, length3 = nativeMax(args2.length - start, 0), array = Array(length3);
    while (++index < length3) {
      array[index] = args2[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args2[index];
    }
    otherArgs[start] = transform(array);
    return apply_default(func, this, otherArgs);
  };
}
__name(overRest, "overRest");
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
__name(baseRest, "baseRest");
var baseRest_default = baseRest;

// node_modules/lodash-es/_isIterateeCall.js
init_process_shim();

// node_modules/lodash-es/isArrayLike.js
init_process_shim();

// node_modules/lodash-es/isLength.js
init_process_shim();
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
__name(isLength, "isLength");
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
__name(isArrayLike, "isArrayLike");
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
__name(isIterateeCall, "isIterateeCall");
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_isPrototype.js
init_process_shim();
var objectProto4 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto4;
  return value === proto;
}
__name(isPrototype, "isPrototype");
var isPrototype_default = isPrototype;

// node_modules/lodash-es/keys.js
init_process_shim();

// node_modules/lodash-es/_arrayLikeKeys.js
init_process_shim();

// node_modules/lodash-es/_baseTimes.js
init_process_shim();
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
__name(baseTimes, "baseTimes");
var baseTimes_default = baseTimes;

// node_modules/lodash-es/isArguments.js
init_process_shim();

// node_modules/lodash-es/_baseIsArguments.js
init_process_shim();
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
__name(baseIsArguments, "baseIsArguments");
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto5 = Object.prototype;
var hasOwnProperty3 = objectProto5.hasOwnProperty;
var propertyIsEnumerable = objectProto5.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/isBuffer.js
init_process_shim();

// node_modules/lodash-es/stubFalse.js
init_process_shim();
function stubFalse() {
  return false;
}
__name(stubFalse, "stubFalse");
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/isTypedArray.js
init_process_shim();

// node_modules/lodash-es/_baseIsTypedArray.js
init_process_shim();
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
__name(baseIsTypedArray, "baseIsTypedArray");
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
init_process_shim();
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
__name(baseUnary, "baseUnary");
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
init_process_shim();
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length3 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length3)))) {
      result.push(key);
    }
  }
  return result;
}
__name(arrayLikeKeys, "arrayLikeKeys");
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_baseKeys.js
init_process_shim();

// node_modules/lodash-es/_nativeKeys.js
init_process_shim();

// node_modules/lodash-es/_overArg.js
init_process_shim();
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
__name(overArg, "overArg");
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty5.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
__name(baseKeys, "baseKeys");
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
__name(keys, "keys");
var keys_default = keys;

// node_modules/lodash-es/get.js
init_process_shim();

// node_modules/lodash-es/_baseGet.js
init_process_shim();

// node_modules/lodash-es/_castPath.js
init_process_shim();

// node_modules/lodash-es/_isKey.js
init_process_shim();
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
__name(isKey, "isKey");
var isKey_default = isKey;

// node_modules/lodash-es/_stringToPath.js
init_process_shim();

// node_modules/lodash-es/_memoizeCapped.js
init_process_shim();

// node_modules/lodash-es/memoize.js
init_process_shim();

// node_modules/lodash-es/_MapCache.js
init_process_shim();

// node_modules/lodash-es/_mapCacheClear.js
init_process_shim();

// node_modules/lodash-es/_Hash.js
init_process_shim();

// node_modules/lodash-es/_hashClear.js
init_process_shim();

// node_modules/lodash-es/_nativeCreate.js
init_process_shim();
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
__name(hashClear, "hashClear");
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
init_process_shim();
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
__name(hashDelete, "hashDelete");
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
init_process_shim();
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty6.call(data, key) ? data[key] : void 0;
}
__name(hashGet, "hashGet");
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
init_process_shim();
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty7.call(data, key);
}
__name(hashHas, "hashHas");
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
init_process_shim();
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
__name(hashSet, "hashSet");
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length3) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(Hash, "Hash");
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_ListCache.js
init_process_shim();

// node_modules/lodash-es/_listCacheClear.js
init_process_shim();
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
__name(listCacheClear, "listCacheClear");
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_listCacheDelete.js
init_process_shim();

// node_modules/lodash-es/_assocIndexOf.js
init_process_shim();
function assocIndexOf(array, key) {
  var length3 = array.length;
  while (length3--) {
    if (eq_default(array[length3][0], key)) {
      return length3;
    }
  }
  return -1;
}
__name(assocIndexOf, "assocIndexOf");
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
__name(listCacheDelete, "listCacheDelete");
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
init_process_shim();
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
__name(listCacheGet, "listCacheGet");
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
init_process_shim();
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
__name(listCacheHas, "listCacheHas");
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
init_process_shim();
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
__name(listCacheSet, "listCacheSet");
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length3) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(ListCache, "ListCache");
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
init_process_shim();
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
__name(mapCacheClear, "mapCacheClear");
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_mapCacheDelete.js
init_process_shim();

// node_modules/lodash-es/_getMapData.js
init_process_shim();

// node_modules/lodash-es/_isKeyable.js
init_process_shim();
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
__name(isKeyable, "isKeyable");
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map3, key) {
  var data = map3.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
__name(getMapData, "getMapData");
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
__name(mapCacheDelete, "mapCacheDelete");
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
init_process_shim();
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
__name(mapCacheGet, "mapCacheGet");
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
init_process_shim();
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
__name(mapCacheHas, "mapCacheHas");
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
init_process_shim();
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
__name(mapCacheSet, "mapCacheSet");
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length3) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(MapCache, "MapCache");
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = /* @__PURE__ */ __name(function() {
    var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args2);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  }, "memoized");
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
__name(memoize, "memoize");
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
__name(memoizeCapped, "memoizeCapped");
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
init_process_shim();
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
__name(toString, "toString");
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
__name(castPath, "castPath");
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
init_process_shim();
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
__name(toKey, "toKey");
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length3 = path.length;
  while (object != null && index < length3) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length3 ? object : void 0;
}
__name(baseGet, "baseGet");
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
__name(get, "get");
var get_default = get;

// node_modules/lodash-es/_baseFlatten.js
init_process_shim();

// node_modules/lodash-es/_arrayPush.js
init_process_shim();
function arrayPush(array, values) {
  var index = -1, length3 = values.length, offset = array.length;
  while (++index < length3) {
    array[offset + index] = values[index];
  }
  return array;
}
__name(arrayPush, "arrayPush");
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
init_process_shim();
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
__name(isFlattenable, "isFlattenable");
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1, length3 = array.length;
  predicate || (predicate = isFlattenable_default);
  result || (result = []);
  while (++index < length3) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush_default(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
__name(baseFlatten, "baseFlatten");
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/_Stack.js
init_process_shim();

// node_modules/lodash-es/_stackClear.js
init_process_shim();
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
__name(stackClear, "stackClear");
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
init_process_shim();
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
__name(stackDelete, "stackDelete");
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
init_process_shim();
function stackGet(key) {
  return this.__data__.get(key);
}
__name(stackGet, "stackGet");
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
init_process_shim();
function stackHas(key) {
  return this.__data__.has(key);
}
__name(stackHas, "stackHas");
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
init_process_shim();
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
__name(stackSet, "stackSet");
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
__name(Stack, "Stack");
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_getSymbols.js
init_process_shim();

// node_modules/lodash-es/_arrayFilter.js
init_process_shim();
function arrayFilter(array, predicate) {
  var index = -1, length3 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length3) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
__name(arrayFilter, "arrayFilter");
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
init_process_shim();
function stubArray() {
  return [];
}
__name(stubArray, "stubArray");
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto10 = Object.prototype;
var propertyIsEnumerable2 = objectProto10.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_getAllKeys.js
init_process_shim();

// node_modules/lodash-es/_baseGetAllKeys.js
init_process_shim();
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
__name(baseGetAllKeys, "baseGetAllKeys");
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
__name(getAllKeys, "getAllKeys");
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getTag.js
init_process_shim();

// node_modules/lodash-es/_DataView.js
init_process_shim();
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
init_process_shim();
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
init_process_shim();
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = /* @__PURE__ */ __name(function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  }, "getTag");
}
var getTag_default = getTag;

// node_modules/lodash-es/_Uint8Array.js
init_process_shim();
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_baseIteratee.js
init_process_shim();

// node_modules/lodash-es/_baseMatches.js
init_process_shim();

// node_modules/lodash-es/_baseIsMatch.js
init_process_shim();

// node_modules/lodash-es/_baseIsEqual.js
init_process_shim();

// node_modules/lodash-es/_baseIsEqualDeep.js
init_process_shim();

// node_modules/lodash-es/_equalArrays.js
init_process_shim();

// node_modules/lodash-es/_SetCache.js
init_process_shim();

// node_modules/lodash-es/_setCacheAdd.js
init_process_shim();
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
__name(setCacheAdd, "setCacheAdd");
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
init_process_shim();
function setCacheHas(value) {
  return this.__data__.has(value);
}
__name(setCacheHas, "setCacheHas");
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index = -1, length3 = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index < length3) {
    this.add(values[index]);
  }
}
__name(SetCache, "SetCache");
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
init_process_shim();
function arraySome(array, predicate) {
  var index = -1, length3 = array == null ? 0 : array.length;
  while (++index < length3) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
__name(arraySome, "arraySome");
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
init_process_shim();
function cacheHas(cache, key) {
  return cache.has(key);
}
__name(cacheHas, "cacheHas");
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
__name(equalArrays, "equalArrays");
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_equalByTag.js
init_process_shim();

// node_modules/lodash-es/_mapToArray.js
init_process_shim();
function mapToArray(map3) {
  var index = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
__name(mapToArray, "mapToArray");
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
init_process_shim();
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
__name(setToArray, "setToArray");
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq_default(+object, +other);
    case errorTag2:
      return object.name == other.name && object.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object == other + "";
    case mapTag3:
      var convert = mapToArray_default;
    case setTag3:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag2:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
__name(equalByTag, "equalByTag");
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
init_process_shim();
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto11 = Object.prototype;
var hasOwnProperty8 = objectProto11.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty8.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
__name(equalObjects, "equalObjects");
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag3 = "[object Object]";
var objectProto12 = Object.prototype;
var hasOwnProperty9 = objectProto12.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
  objTag = objTag == argsTag3 ? objectTag3 : objTag;
  othTag = othTag == argsTag3 ? objectTag3 : othTag;
  var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty9.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty9.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
__name(baseIsEqualDeep, "baseIsEqualDeep");
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
__name(baseIsEqual, "baseIsEqual");
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length3 = index, noCustomizer = !customizer;
  if (object == null) {
    return !length3;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length3) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
__name(baseIsMatch, "baseIsMatch");
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_getMatchData.js
init_process_shim();

// node_modules/lodash-es/_isStrictComparable.js
init_process_shim();
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
__name(isStrictComparable, "isStrictComparable");
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length3 = result.length;
  while (length3--) {
    var key = result[length3], value = object[key];
    result[length3] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
__name(getMatchData, "getMatchData");
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
init_process_shim();
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
__name(matchesStrictComparable, "matchesStrictComparable");
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
__name(baseMatches, "baseMatches");
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseMatchesProperty.js
init_process_shim();

// node_modules/lodash-es/hasIn.js
init_process_shim();

// node_modules/lodash-es/_baseHasIn.js
init_process_shim();
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
__name(baseHasIn, "baseHasIn");
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
init_process_shim();
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1, length3 = path.length, result = false;
  while (++index < length3) {
    var key = toKey_default(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length3) {
    return result;
  }
  length3 = object == null ? 0 : object.length;
  return !!length3 && isLength_default(length3) && isIndex_default(key, length3) && (isArray_default(object) || isArguments_default(object));
}
__name(hasPath, "hasPath");
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
__name(hasIn, "hasIn");
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
__name(baseMatchesProperty, "baseMatchesProperty");
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/property.js
init_process_shim();

// node_modules/lodash-es/_baseProperty.js
init_process_shim();
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
__name(baseProperty, "baseProperty");
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
init_process_shim();
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
__name(basePropertyDeep, "basePropertyDeep");
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
__name(property, "property");
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
__name(baseIteratee, "baseIteratee");
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/_baseEach.js
init_process_shim();

// node_modules/lodash-es/_baseForOwn.js
init_process_shim();

// node_modules/lodash-es/_baseFor.js
init_process_shim();

// node_modules/lodash-es/_createBaseFor.js
init_process_shim();
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length3 = props.length;
    while (length3--) {
      var key = props[fromRight ? length3 : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
__name(createBaseFor, "createBaseFor");
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
__name(baseForOwn, "baseForOwn");
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
init_process_shim();
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length3 = collection.length, index = fromRight ? length3 : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length3) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
__name(createBaseEach, "createBaseEach");
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/debounce.js
init_process_shim();

// node_modules/lodash-es/now.js
init_process_shim();
var now = /* @__PURE__ */ __name(function() {
  return root_default.Date.now();
}, "now");
var now_default = now;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax2(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args2 = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args2);
    return result;
  }
  __name(invokeFunc, "invokeFunc");
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  __name(leadingEdge, "leadingEdge");
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  __name(remainingWait, "remainingWait");
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  __name(shouldInvoke, "shouldInvoke");
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  __name(timerExpired, "timerExpired");
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  __name(trailingEdge, "trailingEdge");
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  __name(cancel, "cancel");
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now_default());
  }
  __name(flush, "flush");
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  __name(debounced, "debounced");
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
__name(debounce, "debounce");
var debounce_default = debounce;

// node_modules/lodash-es/_arrayIncludesWith.js
init_process_shim();
function arrayIncludesWith(array, value, comparator) {
  var index = -1, length3 = array == null ? 0 : array.length;
  while (++index < length3) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
__name(arrayIncludesWith, "arrayIncludesWith");
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseMap.js
init_process_shim();
function baseMap(collection, iteratee) {
  var index = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index] = iteratee(value, key, collection2);
  });
  return result;
}
__name(baseMap, "baseMap");
var baseMap_default = baseMap;

// node_modules/lodash-es/isEqual.js
init_process_shim();
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
__name(isEqual, "isEqual");
var isEqual_default = isEqual;

// node_modules/lodash-es/_baseOrderBy.js
init_process_shim();

// node_modules/lodash-es/_baseSortBy.js
init_process_shim();
function baseSortBy(array, comparer) {
  var length3 = array.length;
  array.sort(comparer);
  while (length3--) {
    array[length3] = array[length3].value;
  }
  return array;
}
__name(baseSortBy, "baseSortBy");
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareMultiple.js
init_process_shim();

// node_modules/lodash-es/_compareAscending.js
init_process_shim();
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
__name(compareAscending, "compareAscending");
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length3 = objCriteria.length, ordersLength = orders.length;
  while (++index < length3) {
    var result = compareAscending_default(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
__name(compareMultiple, "compareMultiple");
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee) {
      if (isArray_default(iteratee)) {
        return function(value) {
          return baseGet_default(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity_default];
  }
  var index = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index, "value": value };
  });
  return baseSortBy_default(result, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
__name(baseOrderBy, "baseOrderBy");
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/sortBy.js
init_process_shim();
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length3 = iteratees.length;
  if (length3 > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length3 > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// node_modules/lodash-es/throttle.js
init_process_shim();
var FUNC_ERROR_TEXT3 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
__name(throttle, "throttle");
var throttle_default = throttle;

// node_modules/lodash-es/_baseUniq.js
init_process_shim();

// node_modules/lodash-es/_createSet.js
init_process_shim();
var INFINITY3 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY3) ? noop_default : function(values) {
  return new Set_default(values);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE2 = 200;
function baseUniq(array, iteratee, comparator) {
  var index = -1, includes = arrayIncludes_default, length3 = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith_default;
  } else if (length3 >= LARGE_ARRAY_SIZE2) {
    var set = iteratee ? null : createSet_default(array);
    if (set) {
      return setToArray_default(set);
    }
    isCommon = false;
    includes = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index < length3) {
      var value = array[index], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
__name(baseUniq, "baseUniq");
var baseUniq_default = baseUniq;

// node_modules/lodash-es/uniqBy.js
init_process_shim();
function uniqBy(array, iteratee) {
  return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee, 2)) : [];
}
__name(uniqBy, "uniqBy");
var uniqBy_default = uniqBy;

// src/services/account/AccountService.ts
var import_ms = __toESM(require_ms());
var import_obsidian3 = require("obsidian");

// node_modules/phoenix/priv/static/phoenix.mjs
init_process_shim();
var closure = /* @__PURE__ */ __name((value) => {
  if (typeof value === "function") {
    return value;
  } else {
    let closure2 = /* @__PURE__ */ __name(function() {
      return value;
    }, "closure2");
    return closure2;
  }
}, "closure");
var globalSelf = typeof self !== "undefined" ? self : null;
var phxWindow = typeof window !== "undefined" ? window : null;
var global2 = globalSelf || phxWindow || global2;
var DEFAULT_VSN = "2.0.0";
var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
var DEFAULT_TIMEOUT = 1e4;
var WS_CLOSE_NORMAL = 1e3;
var CHANNEL_STATES = {
  closed: "closed",
  errored: "errored",
  joined: "joined",
  joining: "joining",
  leaving: "leaving"
};
var CHANNEL_EVENTS = {
  close: "phx_close",
  error: "phx_error",
  join: "phx_join",
  reply: "phx_reply",
  leave: "phx_leave"
};
var TRANSPORTS = {
  longpoll: "longpoll",
  websocket: "websocket"
};
var XHR_STATES = {
  complete: 4
};
var _a;
var Push = (_a = class {
  constructor(channel, event, payload, timeout) {
    this.channel = channel;
    this.event = event;
    this.payload = payload || function() {
      return {};
    };
    this.receivedResp = null;
    this.timeout = timeout;
    this.timeoutTimer = null;
    this.recHooks = [];
    this.sent = false;
  }
  resend(timeout) {
    this.timeout = timeout;
    this.reset();
    this.send();
  }
  send() {
    if (this.hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload(),
      ref: this.ref,
      join_ref: this.channel.joinRef()
    });
  }
  receive(status, callback) {
    if (this.hasReceived(status)) {
      callback(this.receivedResp.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  reset() {
    this.cancelRefEvent();
    this.ref = null;
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
  }
  matchReceive({ status, response, _ref }) {
    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
  }
  cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel.off(this.refEvent);
  }
  cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = null;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      this.cancelTimeout();
    }
    this.ref = this.channel.socket.makeRef();
    this.refEvent = this.channel.replyEventName(this.ref);
    this.channel.on(this.refEvent, (payload) => {
      this.cancelRefEvent();
      this.cancelTimeout();
      this.receivedResp = payload;
      this.matchReceive(payload);
    });
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
  trigger(status, response) {
    this.channel.trigger(this.refEvent, { status, response });
  }
}, __name(_a, "Push"), _a);
var _a2;
var Timer = (_a2 = class {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = null;
    this.tries = 0;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
  }
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}, __name(_a2, "Timer"), _a2);
var _a3;
var Channel = (_a3 = class {
  constructor(topic, params2, socket) {
    this.state = CHANNEL_STATES.closed;
    this.topic = topic;
    this.params = closure(params2 || {});
    this.socket = socket;
    this.bindings = [];
    this.bindingRef = 0;
    this.timeout = this.socket.timeout;
    this.joinedOnce = false;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.pushBuffer = [];
    this.stateChangeRefs = [];
    this.rejoinTimer = new Timer(() => {
      if (this.socket.isConnected()) {
        this.rejoin();
      }
    }, this.socket.rejoinAfterMs);
    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
    this.stateChangeRefs.push(this.socket.onOpen(() => {
      this.rejoinTimer.reset();
      if (this.isErrored()) {
        this.rejoin();
      }
    }));
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this.joinPush.receive("error", () => {
      this.state = CHANNEL_STATES.errored;
      if (this.socket.isConnected()) {
        this.rejoinTimer.scheduleTimeout();
      }
    });
    this.onClose(() => {
      this.rejoinTimer.reset();
      if (this.socket.hasLogger())
        this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket.remove(this);
    });
    this.onError((reason) => {
      if (this.socket.hasLogger())
        this.socket.log("channel", `error ${this.topic}`, reason);
      if (this.isJoining()) {
        this.joinPush.reset();
      }
      this.state = CHANNEL_STATES.errored;
      if (this.socket.isConnected()) {
        this.rejoinTimer.scheduleTimeout();
      }
    });
    this.joinPush.receive("timeout", () => {
      if (this.socket.hasLogger())
        this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
      leavePush.send();
      this.state = CHANNEL_STATES.errored;
      this.joinPush.reset();
      if (this.socket.isConnected()) {
        this.rejoinTimer.scheduleTimeout();
      }
    });
    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
      this.trigger(this.replyEventName(ref), payload);
    });
  }
  join(timeout = this.timeout) {
    if (this.joinedOnce) {
      throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
    } else {
      this.timeout = timeout;
      this.joinedOnce = true;
      this.rejoin();
      return this.joinPush;
    }
  }
  onClose(callback) {
    this.on(CHANNEL_EVENTS.close, callback);
  }
  onError(callback) {
    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
  }
  on(event, callback) {
    let ref = this.bindingRef++;
    this.bindings.push({ event, ref, callback });
    return ref;
  }
  off(event, ref) {
    this.bindings = this.bindings.filter((bind3) => {
      return !(bind3.event === event && (typeof ref === "undefined" || ref === bind3.ref));
    });
  }
  canPush() {
    return this.socket.isConnected() && this.isJoined();
  }
  push(event, payload, timeout = this.timeout) {
    payload = payload || {};
    if (!this.joinedOnce) {
      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
    }
    let pushEvent = new Push(this, event, function() {
      return payload;
    }, timeout);
    if (this.canPush()) {
      pushEvent.send();
    } else {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
    }
    return pushEvent;
  }
  leave(timeout = this.timeout) {
    this.rejoinTimer.reset();
    this.joinPush.cancelTimeout();
    this.state = CHANNEL_STATES.leaving;
    let onClose = /* @__PURE__ */ __name(() => {
      if (this.socket.hasLogger())
        this.socket.log("channel", `leave ${this.topic}`);
      this.trigger(CHANNEL_EVENTS.close, "leave");
    }, "onClose");
    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
    leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
    leavePush.send();
    if (!this.canPush()) {
      leavePush.trigger("ok", {});
    }
    return leavePush;
  }
  onMessage(_event, payload, _ref) {
    return payload;
  }
  isMember(topic, event, payload, joinRef) {
    if (this.topic !== topic) {
      return false;
    }
    if (joinRef && joinRef !== this.joinRef()) {
      if (this.socket.hasLogger())
        this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
      return false;
    } else {
      return true;
    }
  }
  joinRef() {
    return this.joinPush.ref;
  }
  rejoin(timeout = this.timeout) {
    if (this.isLeaving()) {
      return;
    }
    this.socket.leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  trigger(event, payload, ref, joinRef) {
    let handledPayload = this.onMessage(event, payload, ref, joinRef);
    if (payload && !handledPayload) {
      throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
    }
    let eventBindings = this.bindings.filter((bind3) => bind3.event === event);
    for (let i = 0; i < eventBindings.length; i++) {
      let bind3 = eventBindings[i];
      bind3.callback(handledPayload, ref, joinRef || this.joinRef());
    }
  }
  replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  isErrored() {
    return this.state === CHANNEL_STATES.errored;
  }
  isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
}, __name(_a3, "Channel"), _a3);
var _a4;
var Ajax = (_a4 = class {
  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
    if (global2.XDomainRequest) {
      let req = new global2.XDomainRequest();
      return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
    } else {
      let req = new global2.XMLHttpRequest();
      return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
    }
  }
  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
    req.timeout = timeout;
    req.open(method, endPoint);
    req.onload = () => {
      let response = this.parseJSON(req.responseText);
      callback && callback(response);
    };
    if (ontimeout) {
      req.ontimeout = ontimeout;
    }
    req.onprogress = () => {
    };
    req.send(body);
    return req;
  }
  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
    req.open(method, endPoint, true);
    req.timeout = timeout;
    req.setRequestHeader("Content-Type", accept);
    req.onerror = () => callback && callback(null);
    req.onreadystatechange = () => {
      if (req.readyState === XHR_STATES.complete && callback) {
        let response = this.parseJSON(req.responseText);
        callback(response);
      }
    };
    if (ontimeout) {
      req.ontimeout = ontimeout;
    }
    req.send(body);
    return req;
  }
  static parseJSON(resp) {
    if (!resp || resp === "") {
      return null;
    }
    try {
      return JSON.parse(resp);
    } catch (e) {
      console && console.log("failed to parse JSON response", resp);
      return null;
    }
  }
  static serialize(obj, parentKey) {
    let queryStr = [];
    for (var key in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, key)) {
        continue;
      }
      let paramKey = parentKey ? `${parentKey}[${key}]` : key;
      let paramVal = obj[key];
      if (typeof paramVal === "object") {
        queryStr.push(this.serialize(paramVal, paramKey));
      } else {
        queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
      }
    }
    return queryStr.join("&");
  }
  static appendParams(url, params2) {
    if (Object.keys(params2).length === 0) {
      return url;
    }
    let prefix = url.match(/\?/) ? "&" : "?";
    return `${url}${prefix}${this.serialize(params2)}`;
  }
}, __name(_a4, "Ajax"), _a4);
var _a5;
var LongPoll = (_a5 = class {
  constructor(endPoint) {
    this.endPoint = null;
    this.token = null;
    this.skipHeartbeat = true;
    this.reqs = /* @__PURE__ */ new Set();
    this.awaitingBatchAck = false;
    this.currentBatch = null;
    this.currentBatchTimer = null;
    this.batchBuffer = [];
    this.onopen = function() {
    };
    this.onerror = function() {
    };
    this.onmessage = function() {
    };
    this.onclose = function() {
    };
    this.pollEndpoint = this.normalizeEndpoint(endPoint);
    this.readyState = SOCKET_STATES.connecting;
    this.poll();
  }
  normalizeEndpoint(endPoint) {
    return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
  }
  endpointURL() {
    return Ajax.appendParams(this.pollEndpoint, { token: this.token });
  }
  closeAndRetry(code, reason, wasClean) {
    this.close(code, reason, wasClean);
    this.readyState = SOCKET_STATES.connecting;
  }
  ontimeout() {
    this.onerror("timeout");
    this.closeAndRetry(1005, "timeout", false);
  }
  isActive() {
    return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
  }
  poll() {
    this.ajax("GET", "application/json", null, () => this.ontimeout(), (resp) => {
      if (resp) {
        var { status, token, messages } = resp;
        this.token = token;
      } else {
        status = 0;
      }
      switch (status) {
        case 200:
          messages.forEach((msg) => {
            setTimeout(() => this.onmessage({ data: msg }), 0);
          });
          this.poll();
          break;
        case 204:
          this.poll();
          break;
        case 410:
          this.readyState = SOCKET_STATES.open;
          this.onopen({});
          this.poll();
          break;
        case 403:
          this.onerror(403);
          this.close(1008, "forbidden", false);
          break;
        case 0:
        case 500:
          this.onerror(500);
          this.closeAndRetry(1011, "internal server error", 500);
          break;
        default:
          throw new Error(`unhandled poll status ${status}`);
      }
    });
  }
  send(body) {
    if (this.currentBatch) {
      this.currentBatch.push(body);
    } else if (this.awaitingBatchAck) {
      this.batchBuffer.push(body);
    } else {
      this.currentBatch = [body];
      this.currentBatchTimer = setTimeout(() => {
        this.batchSend(this.currentBatch);
        this.currentBatch = null;
      }, 0);
    }
  }
  batchSend(messages) {
    this.awaitingBatchAck = true;
    this.ajax("POST", "application/x-ndjson", messages.join("\n"), () => this.onerror("timeout"), (resp) => {
      this.awaitingBatchAck = false;
      if (!resp || resp.status !== 200) {
        this.onerror(resp && resp.status);
        this.closeAndRetry(1011, "internal server error", false);
      } else if (this.batchBuffer.length > 0) {
        this.batchSend(this.batchBuffer);
        this.batchBuffer = [];
      }
    });
  }
  close(code, reason, wasClean) {
    for (let req of this.reqs) {
      req.abort();
    }
    this.readyState = SOCKET_STATES.closed;
    let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
    this.batchBuffer = [];
    clearTimeout(this.currentBatchTimer);
    this.currentBatchTimer = null;
    if (typeof CloseEvent !== "undefined") {
      this.onclose(new CloseEvent("close", opts));
    } else {
      this.onclose(opts);
    }
  }
  ajax(method, contentType, body, onCallerTimeout, callback) {
    let req;
    let ontimeout = /* @__PURE__ */ __name(() => {
      this.reqs.delete(req);
      onCallerTimeout();
    }, "ontimeout");
    req = Ajax.request(method, this.endpointURL(), contentType, body, this.timeout, ontimeout, (resp) => {
      this.reqs.delete(req);
      if (this.isActive()) {
        callback(resp);
      }
    });
    this.reqs.add(req);
  }
}, __name(_a5, "LongPoll"), _a5);
var _a6;
var Presence = (_a6 = class {
  constructor(channel, opts = {}) {
    let events = opts.events || { state: "presence_state", diff: "presence_diff" };
    this.state = {};
    this.pendingDiffs = [];
    this.channel = channel;
    this.joinRef = null;
    this.caller = {
      onJoin: /* @__PURE__ */ __name(function() {
      }, "onJoin"),
      onLeave: /* @__PURE__ */ __name(function() {
      }, "onLeave"),
      onSync: /* @__PURE__ */ __name(function() {
      }, "onSync")
    };
    this.channel.on(events.state, (newState) => {
      let { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel.joinRef();
      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel.on(events.diff, (diff) => {
      let { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
  }
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  onSync(callback) {
    this.caller.onSync = callback;
  }
  list(by) {
    return Presence.list(this.state, by);
  }
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel.joinRef();
  }
  static syncState(currentState, newState, onJoin, onLeave) {
    let state = this.clone(currentState);
    let joins = {};
    let leaves = {};
    this.map(state, (key, presence) => {
      if (!newState[key]) {
        leaves[key] = presence;
      }
    });
    this.map(newState, (key, newPresence) => {
      let currentPresence = state[key];
      if (currentPresence) {
        let newRefs = newPresence.metas.map((m) => m.phx_ref);
        let curRefs = currentPresence.metas.map((m) => m.phx_ref);
        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);
        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);
        if (joinedMetas.length > 0) {
          joins[key] = newPresence;
          joins[key].metas = joinedMetas;
        }
        if (leftMetas.length > 0) {
          leaves[key] = this.clone(currentPresence);
          leaves[key].metas = leftMetas;
        }
      } else {
        joins[key] = newPresence;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  static syncDiff(state, diff, onJoin, onLeave) {
    let { joins, leaves } = this.clone(diff);
    if (!onJoin) {
      onJoin = /* @__PURE__ */ __name(function() {
      }, "onJoin");
    }
    if (!onLeave) {
      onLeave = /* @__PURE__ */ __name(function() {
      }, "onLeave");
    }
    this.map(joins, (key, newPresence) => {
      let currentPresence = state[key];
      state[key] = this.clone(newPresence);
      if (currentPresence) {
        let joinedRefs = state[key].metas.map((m) => m.phx_ref);
        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);
        state[key].metas.unshift(...curMetas);
      }
      onJoin(key, currentPresence, newPresence);
    });
    this.map(leaves, (key, leftPresence) => {
      let currentPresence = state[key];
      if (!currentPresence) {
        return;
      }
      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);
      currentPresence.metas = currentPresence.metas.filter((p) => {
        return refsToRemove.indexOf(p.phx_ref) < 0;
      });
      onLeave(key, currentPresence, leftPresence);
      if (currentPresence.metas.length === 0) {
        delete state[key];
      }
    });
    return state;
  }
  static list(presences, chooser) {
    if (!chooser) {
      chooser = /* @__PURE__ */ __name(function(key, pres) {
        return pres;
      }, "chooser");
    }
    return this.map(presences, (key, presence) => {
      return chooser(key, presence);
    });
  }
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  static clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
}, __name(_a6, "Presence"), _a6);
var serializer_default = {
  HEADER_LENGTH: 1,
  META_LENGTH: 4,
  KINDS: { push: 0, reply: 1, broadcast: 2 },
  encode(msg, callback) {
    if (msg.payload.constructor === ArrayBuffer) {
      return callback(this.binaryEncode(msg));
    } else {
      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
      return callback(JSON.stringify(payload));
    }
  },
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this.binaryDecode(rawPayload));
    } else {
      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
      return callback({ join_ref, ref, topic, event, payload });
    }
  },
  binaryEncode(message) {
    let { join_ref, ref, event, topic, payload } = message;
    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
    let view = new DataView(header);
    let offset = 0;
    view.setUint8(offset++, this.KINDS.push);
    view.setUint8(offset++, join_ref.length);
    view.setUint8(offset++, ref.length);
    view.setUint8(offset++, topic.length);
    view.setUint8(offset++, event.length);
    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    var combined = new Uint8Array(header.byteLength + payload.byteLength);
    combined.set(new Uint8Array(header), 0);
    combined.set(new Uint8Array(payload), header.byteLength);
    return combined.buffer;
  },
  binaryDecode(buffer) {
    let view = new DataView(buffer);
    let kind = view.getUint8(0);
    let decoder = new TextDecoder();
    switch (kind) {
      case this.KINDS.push:
        return this.decodePush(buffer, view, decoder);
      case this.KINDS.reply:
        return this.decodeReply(buffer, view, decoder);
      case this.KINDS.broadcast:
        return this.decodeBroadcast(buffer, view, decoder);
    }
  },
  decodePush(buffer, view, decoder) {
    let joinRefSize = view.getUint8(1);
    let topicSize = view.getUint8(2);
    let eventSize = view.getUint8(3);
    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
    offset = offset + joinRefSize;
    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    let event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    let data = buffer.slice(offset, buffer.byteLength);
    return { join_ref: joinRef, ref: null, topic, event, payload: data };
  },
  decodeReply(buffer, view, decoder) {
    let joinRefSize = view.getUint8(1);
    let refSize = view.getUint8(2);
    let topicSize = view.getUint8(3);
    let eventSize = view.getUint8(4);
    let offset = this.HEADER_LENGTH + this.META_LENGTH;
    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
    offset = offset + joinRefSize;
    let ref = decoder.decode(buffer.slice(offset, offset + refSize));
    offset = offset + refSize;
    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    let event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    let data = buffer.slice(offset, buffer.byteLength);
    let payload = { status: event, response: data };
    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
  },
  decodeBroadcast(buffer, view, decoder) {
    let topicSize = view.getUint8(1);
    let eventSize = view.getUint8(2);
    let offset = this.HEADER_LENGTH + 2;
    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    let event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    let data = buffer.slice(offset, buffer.byteLength);
    return { join_ref: null, ref: null, topic, event, payload: data };
  }
};
var _a7;
var Socket = (_a7 = class {
  constructor(endPoint, opts = {}) {
    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
    this.channels = [];
    this.sendBuffer = [];
    this.ref = 0;
    this.timeout = opts.timeout || DEFAULT_TIMEOUT;
    this.transport = opts.transport || global2.WebSocket || LongPoll;
    this.establishedConnections = 0;
    this.defaultEncoder = serializer_default.encode.bind(serializer_default);
    this.defaultDecoder = serializer_default.decode.bind(serializer_default);
    this.closeWasClean = false;
    this.binaryType = opts.binaryType || "arraybuffer";
    this.connectClock = 1;
    if (this.transport !== LongPoll) {
      this.encode = opts.encode || this.defaultEncoder;
      this.decode = opts.decode || this.defaultDecoder;
    } else {
      this.encode = this.defaultEncoder;
      this.decode = this.defaultDecoder;
    }
    let awaitingConnectionOnPageShow = null;
    if (phxWindow && phxWindow.addEventListener) {
      phxWindow.addEventListener("pagehide", (_e) => {
        if (this.conn) {
          this.disconnect();
          awaitingConnectionOnPageShow = this.connectClock;
        }
      });
      phxWindow.addEventListener("pageshow", (_e) => {
        if (awaitingConnectionOnPageShow === this.connectClock) {
          awaitingConnectionOnPageShow = null;
          this.connect();
        }
      });
    }
    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
    this.rejoinAfterMs = (tries) => {
      if (opts.rejoinAfterMs) {
        return opts.rejoinAfterMs(tries);
      } else {
        return [1e3, 2e3, 5e3][tries - 1] || 1e4;
      }
    };
    this.reconnectAfterMs = (tries) => {
      if (opts.reconnectAfterMs) {
        return opts.reconnectAfterMs(tries);
      } else {
        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
      }
    };
    this.logger = opts.logger || null;
    this.longpollerTimeout = opts.longpollerTimeout || 2e4;
    this.params = closure(opts.params || {});
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.vsn = opts.vsn || DEFAULT_VSN;
    this.heartbeatTimeoutTimer = null;
    this.heartbeatTimer = null;
    this.pendingHeartbeatRef = null;
    this.reconnectTimer = new Timer(() => {
      this.teardown(() => this.connect());
    }, this.reconnectAfterMs);
  }
  getLongPollTransport() {
    return LongPoll;
  }
  replaceTransport(newTransport) {
    this.connectClock++;
    this.closeWasClean = true;
    this.reconnectTimer.reset();
    this.sendBuffer = [];
    if (this.conn) {
      this.conn.close();
      this.conn = null;
    }
    this.transport = newTransport;
  }
  protocol() {
    return location.protocol.match(/^https/) ? "wss" : "ws";
  }
  endPointURL() {
    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });
    if (uri.charAt(0) !== "/") {
      return uri;
    }
    if (uri.charAt(1) === "/") {
      return `${this.protocol()}:${uri}`;
    }
    return `${this.protocol()}://${location.host}${uri}`;
  }
  disconnect(callback, code, reason) {
    this.connectClock++;
    this.closeWasClean = true;
    this.reconnectTimer.reset();
    this.teardown(callback, code, reason);
  }
  connect(params2) {
    if (params2) {
      console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
      this.params = closure(params2);
    }
    if (this.conn) {
      return;
    }
    this.connectClock++;
    this.closeWasClean = false;
    this.conn = new this.transport(this.endPointURL());
    this.conn.binaryType = this.binaryType;
    this.conn.timeout = this.longpollerTimeout;
    this.conn.onopen = () => this.onConnOpen();
    this.conn.onerror = (error) => this.onConnError(error);
    this.conn.onmessage = (event) => this.onConnMessage(event);
    this.conn.onclose = (event) => this.onConnClose(event);
  }
  log(kind, msg, data) {
    this.logger(kind, msg, data);
  }
  hasLogger() {
    return this.logger !== null;
  }
  onOpen(callback) {
    let ref = this.makeRef();
    this.stateChangeCallbacks.open.push([ref, callback]);
    return ref;
  }
  onClose(callback) {
    let ref = this.makeRef();
    this.stateChangeCallbacks.close.push([ref, callback]);
    return ref;
  }
  onError(callback) {
    let ref = this.makeRef();
    this.stateChangeCallbacks.error.push([ref, callback]);
    return ref;
  }
  onMessage(callback) {
    let ref = this.makeRef();
    this.stateChangeCallbacks.message.push([ref, callback]);
    return ref;
  }
  ping(callback) {
    if (!this.isConnected()) {
      return false;
    }
    let ref = this.makeRef();
    let startTime = Date.now();
    this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
    let onMsgRef = this.onMessage((msg) => {
      if (msg.ref === ref) {
        this.off([onMsgRef]);
        callback(Date.now() - startTime);
      }
    });
    return true;
  }
  clearHeartbeats() {
    clearTimeout(this.heartbeatTimer);
    clearTimeout(this.heartbeatTimeoutTimer);
  }
  onConnOpen() {
    if (this.hasLogger())
      this.log("transport", `connected to ${this.endPointURL()}`);
    this.closeWasClean = false;
    this.establishedConnections++;
    this.flushSendBuffer();
    this.reconnectTimer.reset();
    this.resetHeartbeat();
    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
  }
  heartbeatTimeout() {
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      if (this.hasLogger()) {
        this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      }
      this.triggerChanError();
      this.closeWasClean = false;
      this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
    }
  }
  resetHeartbeat() {
    if (this.conn && this.conn.skipHeartbeat) {
      return;
    }
    this.pendingHeartbeatRef = null;
    this.clearHeartbeats();
    this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
  }
  teardown(callback, code, reason) {
    if (!this.conn) {
      return callback && callback();
    }
    this.waitForBufferDone(() => {
      if (this.conn) {
        if (code) {
          this.conn.close(code, reason || "");
        } else {
          this.conn.close();
        }
      }
      this.waitForSocketClosed(() => {
        if (this.conn) {
          this.conn.onopen = function() {
          };
          this.conn.onerror = function() {
          };
          this.conn.onmessage = function() {
          };
          this.conn.onclose = function() {
          };
          this.conn = null;
        }
        callback && callback();
      });
    });
  }
  waitForBufferDone(callback, tries = 1) {
    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
      callback();
      return;
    }
    setTimeout(() => {
      this.waitForBufferDone(callback, tries + 1);
    }, 150 * tries);
  }
  waitForSocketClosed(callback, tries = 1) {
    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
      callback();
      return;
    }
    setTimeout(() => {
      this.waitForSocketClosed(callback, tries + 1);
    }, 150 * tries);
  }
  onConnClose(event) {
    let closeCode = event && event.code;
    if (this.hasLogger())
      this.log("transport", "close", event);
    this.triggerChanError();
    this.clearHeartbeats();
    if (!this.closeWasClean && closeCode !== 1e3) {
      this.reconnectTimer.scheduleTimeout();
    }
    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
  }
  onConnError(error) {
    if (this.hasLogger())
      this.log("transport", error);
    let transportBefore = this.transport;
    let establishedBefore = this.establishedConnections;
    this.stateChangeCallbacks.error.forEach(([, callback]) => {
      callback(error, transportBefore, establishedBefore);
    });
    if (transportBefore === this.transport || establishedBefore > 0) {
      this.triggerChanError();
    }
  }
  triggerChanError() {
    this.channels.forEach((channel) => {
      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
        channel.trigger(CHANNEL_EVENTS.error);
      }
    });
  }
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return "connecting";
      case SOCKET_STATES.open:
        return "open";
      case SOCKET_STATES.closing:
        return "closing";
      default:
        return "closed";
    }
  }
  isConnected() {
    return this.connectionState() === "open";
  }
  remove(channel) {
    this.off(channel.stateChangeRefs);
    this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
  }
  off(refs) {
    for (let key in this.stateChangeCallbacks) {
      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
        return refs.indexOf(ref) === -1;
      });
    }
  }
  channel(topic, chanParams = {}) {
    let chan = new Channel(topic, chanParams, this);
    this.channels.push(chan);
    return chan;
  }
  push(data) {
    if (this.hasLogger()) {
      let { topic, event, payload, ref, join_ref } = data;
      this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
    }
    if (this.isConnected()) {
      this.encode(data, (result) => this.conn.send(result));
    } else {
      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
    }
  }
  makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  sendHeartbeat() {
    if (this.pendingHeartbeatRef && !this.isConnected()) {
      return;
    }
    this.pendingHeartbeatRef = this.makeRef();
    this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
    this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
  }
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      let { topic, event, payload, ref, join_ref } = msg;
      if (ref && ref === this.pendingHeartbeatRef) {
        this.clearHeartbeats();
        this.pendingHeartbeatRef = null;
        this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
      }
      if (this.hasLogger())
        this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
      for (let i = 0; i < this.channels.length; i++) {
        const channel = this.channels[i];
        if (!channel.isMember(topic, event, payload, join_ref)) {
          continue;
        }
        channel.trigger(event, payload, ref, join_ref);
      }
      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
        let [, callback] = this.stateChangeCallbacks.message[i];
        callback(msg);
      }
    });
  }
  leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
    if (dupChannel) {
      if (this.hasLogger())
        this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.leave();
    }
  }
}, __name(_a7, "Socket"), _a7);

// node_modules/rxjs/dist/esm5/index.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/Observable.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
init_process_shim();

// node_modules/tslib/tslib.es6.js
init_process_shim();
var extendStatics = /* @__PURE__ */ __name(function(d2, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
    d3.__proto__ = b2;
  } || function(d3, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d3[p] = b2[p];
  };
  return extendStatics(d2, b);
}, "extendStatics");
function __extends(d2, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d2, b);
  function __() {
    this.constructor = d2;
  }
  __name(__, "__");
  d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
__name(__extends, "__extends");
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
__name(__awaiter, "__awaiter");
function __generator(thisArg, body) {
  var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, "sent"), trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  __name(verb, "verb");
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
  __name(step, "step");
}
__name(__generator, "__generator");
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: /* @__PURE__ */ __name(function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }, "next")
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
__name(__values, "__values");
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
__name(__read, "__read");
function __spreadArray(to, from3, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from3.length, ar; i < l; i++) {
    if (ar || !(i in from3)) {
      if (!ar) ar = Array.prototype.slice.call(from3, 0, i);
      ar[i] = from3[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from3));
}
__name(__spreadArray, "__spreadArray");
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
__name(__await, "__await");
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  __name(verb, "verb");
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle2(q[0][3], e);
    }
  }
  __name(resume, "resume");
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
  }
  __name(step, "step");
  function fulfill(value) {
    resume("next", value);
  }
  __name(fulfill, "fulfill");
  function reject(value) {
    resume("throw", value);
  }
  __name(reject, "reject");
  function settle2(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
  __name(settle2, "settle");
}
__name(__asyncGenerator, "__asyncGenerator");
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle2(resolve, reject, v.done, v.value);
      });
    };
  }
  __name(verb, "verb");
  function settle2(resolve, reject, d2, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d2 });
    }, reject);
  }
  __name(settle2, "settle");
}
__name(__asyncValues, "__asyncValues");

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
init_process_shim();
function isFunction2(value) {
  return typeof value === "function";
}
__name(isFunction2, "isFunction");

// node_modules/rxjs/dist/esm5/internal/Subscription.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
init_process_shim();
function createErrorClass(createImpl) {
  var _super = /* @__PURE__ */ __name(function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  }, "_super");
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
__name(createErrorClass, "createErrorClass");

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name(function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  }, "UnsubscriptionErrorImpl");
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
init_process_shim();
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
__name(arrRemove, "arrRemove");

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription3(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  __name(Subscription3, "Subscription");
  Subscription3.prototype.unsubscribe = function() {
    var e_1, _a8, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a8 = _parentage_1.return)) _a8.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction2(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription3.prototype.add = function(teardown) {
    var _a8;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription3) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a8 = this._finalizers) !== null && _a8 !== void 0 ? _a8 : []).push(teardown);
      }
    }
  };
  Subscription3.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription3.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription3.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription3.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription3) {
      teardown._removeParent(this);
    }
  };
  Subscription3.EMPTY = function() {
    var empty = new Subscription3();
    empty.closed = true;
    return empty;
  }();
  return Subscription3;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction2(value.remove) && isFunction2(value.add) && isFunction2(value.unsubscribe);
}
__name(isSubscription, "isSubscription");
function execFinalizer(finalizer) {
  if (isFunction2(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
__name(execFinalizer, "execFinalizer");

// node_modules/rxjs/dist/esm5/internal/config.js
init_process_shim();
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
init_process_shim();
var timeoutProvider = {
  setTimeout: /* @__PURE__ */ __name(function(handler, timeout) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args2)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args2)));
  }, "setTimeout"),
  clearTimeout: /* @__PURE__ */ __name(function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  }, "clearTimeout"),
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
__name(reportUnhandledError, "reportUnhandledError");

// node_modules/rxjs/dist/esm5/internal/util/noop.js
init_process_shim();
function noop2() {
}
__name(noop2, "noop");

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
init_process_shim();
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
__name(errorNotification, "errorNotification");
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
__name(nextNotification, "nextNotification");
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
__name(createNotification, "createNotification");

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
init_process_shim();
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a8 = context, errorThrown = _a8.errorThrown, error = _a8.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
__name(errorContext, "errorContext");
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}
__name(captureError, "captureError");

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  __name(Subscriber2, "Subscriber");
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
__name(bind, "bind");
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  __name(ConsumerObserver2, "ConsumerObserver");
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction2(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  __name(SafeSubscriber2, "SafeSubscriber");
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
__name(handleUnhandledError, "handleUnhandledError");
function defaultErrorHandler(err) {
  throw err;
}
__name(defaultErrorHandler, "defaultErrorHandler");
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
__name(handleStoppedNotification, "handleStoppedNotification");
var EMPTY_OBSERVER = {
  closed: true,
  next: noop2,
  error: defaultErrorHandler,
  complete: noop2
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
init_process_shim();
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
init_process_shim();
function identity2(x) {
  return x;
}
__name(identity2, "identity");

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity2;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return /* @__PURE__ */ __name(function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  }, "piped");
}
__name(pipeFromArray, "pipeFromArray");

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable8(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  __name(Observable8, "Observable");
  Observable8.prototype.lift = function(operator) {
    var observable2 = new Observable8();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable8.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a8 = _this, operator = _a8.operator, source = _a8.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable8.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable8.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: /* @__PURE__ */ __name(function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        }, "next"),
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable8.prototype._subscribe = function(subscriber) {
    var _a8;
    return (_a8 = this.source) === null || _a8 === void 0 ? void 0 : _a8.subscribe(subscriber);
  };
  Observable8.prototype[observable] = function() {
    return this;
  };
  Observable8.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable8.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable8.create = function(subscribe) {
    return new Observable8(subscribe);
  };
  return Observable8;
}();
function getPromiseCtor(promiseCtor) {
  var _a8;
  return (_a8 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a8 !== void 0 ? _a8 : Promise;
}
__name(getPromiseCtor, "getPromiseCtor");
function isObserver(value) {
  return value && isFunction2(value.next) && isFunction2(value.error) && isFunction2(value.complete);
}
__name(isObserver, "isObserver");
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
__name(isSubscriber, "isSubscriber");

// node_modules/rxjs/dist/esm5/internal/util/lift.js
init_process_shim();
function hasLift(source) {
  return isFunction2(source === null || source === void 0 ? void 0 : source.lift);
}
__name(hasLift, "hasLift");
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
__name(operate, "operate");

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
init_process_shim();
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
__name(createOperatorSubscriber, "createOperatorSubscriber");
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  __name(OperatorSubscriber2, "OperatorSubscriber");
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a8;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a8 = this.onFinalize) === null || _a8 === void 0 ? void 0 : _a8.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/Subject.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
init_process_shim();
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name(function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  }, "ObjectUnsubscribedErrorImpl");
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  __name(Subject2, "Subject");
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a8;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a8 = _b.return)) _a8.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: /* @__PURE__ */ __name(function() {
      var _a8;
      return ((_a8 = this.observers) === null || _a8 === void 0 ? void 0 : _a8.length) > 0;
    }, "get"),
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a8 = this, hasError = _a8.hasError, isStopped = _a8.isStopped, observers = _a8.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a8 = this, hasError = _a8.hasError, thrownError = _a8.thrownError, isStopped = _a8.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  __name(AnonymousSubject2, "AnonymousSubject");
  AnonymousSubject2.prototype.next = function(value) {
    var _a8, _b;
    (_b = (_a8 = this.destination) === null || _a8 === void 0 ? void 0 : _a8.next) === null || _b === void 0 ? void 0 : _b.call(_a8, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a8, _b;
    (_b = (_a8 = this.destination) === null || _a8 === void 0 ? void 0 : _a8.error) === null || _b === void 0 ? void 0 : _b.call(_a8, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a8, _b;
    (_b = (_a8 = this.destination) === null || _a8 === void 0 ? void 0 : _a8.complete) === null || _b === void 0 ? void 0 : _b.call(_a8);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a8, _b;
    return (_b = (_a8 = this.source) === null || _a8 === void 0 ? void 0 : _a8.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
init_process_shim();
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  __name(BehaviorSubject2, "BehaviorSubject");
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: /* @__PURE__ */ __name(function() {
      return this.getValue();
    }, "get"),
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a8 = this, hasError = _a8.hasError, thrownError = _a8.thrownError, _value = _a8._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
init_process_shim();
var dateTimestampProvider = {
  now: /* @__PURE__ */ __name(function() {
    return (dateTimestampProvider.delegate || Date).now();
  }, "now"),
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  __name(ReplaySubject2, "ReplaySubject");
  ReplaySubject2.prototype.next = function(value) {
    var _a8 = this, isStopped = _a8.isStopped, _buffer = _a8._buffer, _infiniteTimeWindow = _a8._infiniteTimeWindow, _timestampProvider = _a8._timestampProvider, _windowTime = _a8._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a8 = this, _infiniteTimeWindow = _a8._infiniteTimeWindow, _buffer = _a8._buffer;
    var copy2 = _buffer.slice();
    for (var i = 0; i < copy2.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy2[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a8 = this, _bufferSize = _a8._bufferSize, _timestampProvider = _a8._timestampProvider, _buffer = _a8._buffer, _infiniteTimeWindow = _a8._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now2; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
init_process_shim();
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  __name(Action2, "Action");
  Action2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
init_process_shim();
var intervalProvider = {
  setInterval: /* @__PURE__ */ __name(function(handler, timeout) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args2)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args2)));
  }, "setInterval"),
  clearInterval: /* @__PURE__ */ __name(function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  }, "clearInterval"),
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  __name(AsyncAction2, "AsyncAction");
  AsyncAction2.prototype.schedule = function(state, delay) {
    var _a8;
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = (_a8 = this.id) !== null && _a8 !== void 0 ? _a8 : this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a8 = this, id = _a8.id, scheduler = _a8.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
init_process_shim();
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  __name(Scheduler2, "Scheduler");
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  __name(AsyncScheduler2, "AsyncScheduler");
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
init_process_shim();
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/util/args.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
init_process_shim();
function isScheduler(value) {
  return value && isFunction2(value.schedule);
}
__name(isScheduler, "isScheduler");

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
__name(last, "last");
function popResultSelector(args2) {
  return isFunction2(last(args2)) ? args2.pop() : void 0;
}
__name(popResultSelector, "popResultSelector");
function popScheduler(args2) {
  return isScheduler(last(args2)) ? args2.pop() : void 0;
}
__name(popScheduler, "popScheduler");

// node_modules/rxjs/dist/esm5/internal/observable/from.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
init_process_shim();
var isArrayLike2 = /* @__PURE__ */ __name(function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
}, "isArrayLike");

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
init_process_shim();
function isPromise(value) {
  return isFunction2(value === null || value === void 0 ? void 0 : value.then);
}
__name(isPromise, "isPromise");

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
init_process_shim();
function isInteropObservable(input) {
  return isFunction2(input[observable]);
}
__name(isInteropObservable, "isInteropObservable");

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
init_process_shim();
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction2(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
__name(isAsyncIterable, "isAsyncIterable");

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
init_process_shim();
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
__name(createInvalidObservableTypeError, "createInvalidObservableTypeError");

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
init_process_shim();
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
__name(getSymbolIterator, "getSymbolIterator");
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction2(input === null || input === void 0 ? void 0 : input[iterator]);
}
__name(isIterable, "isIterable");

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
init_process_shim();
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a8, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a8 = _b.sent(), value = _a8.value, done = _a8.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  }, "readableStreamLikeToAsyncGenerator_1"));
}
__name(readableStreamLikeToAsyncGenerator, "readableStreamLikeToAsyncGenerator");
function isReadableStreamLike(obj) {
  return isFunction2(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
__name(isReadableStreamLike, "isReadableStreamLike");

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike2(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(innerFrom, "innerFrom");
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction2(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
__name(fromInteropObservable, "fromInteropObservable");
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
__name(fromArrayLike, "fromArrayLike");
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
__name(fromPromise, "fromPromise");
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a8;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a8 = iterable_1.return)) _a8.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
__name(fromIterable, "fromIterable");
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
__name(fromAsyncIterable, "fromAsyncIterable");
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
__name(fromReadableStreamLike, "fromReadableStreamLike");
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a8;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a8 = asyncIterable_1.return))) return [3, 8];
          return [4, _a8.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
__name(process2, "process");

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
init_process_shim();
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
__name(executeSchedule, "executeSchedule");

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
__name(observeOn, "observeOn");

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
init_process_shim();
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
__name(subscribeOn, "subscribeOn");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
__name(scheduleObservable, "scheduleObservable");

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
init_process_shim();
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
__name(schedulePromise, "schedulePromise");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
init_process_shim();
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
__name(scheduleArray, "scheduleArray");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
init_process_shim();
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a8;
        var value;
        var done;
        try {
          _a8 = iterator2.next(), value = _a8.value, done = _a8.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction2(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
__name(scheduleIterable, "scheduleIterable");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
init_process_shim();
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
__name(scheduleAsyncIterable, "scheduleAsyncIterable");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
init_process_shim();
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
__name(scheduleReadableStreamLike, "scheduleReadableStreamLike");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike2(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(scheduled, "scheduled");

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
__name(from, "from");

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
init_process_shim();
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
__name(isValidDate, "isValidDate");

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/operators/map.js
init_process_shim();
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
__name(map, "map");

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray2 = Array.isArray;
function callOrApply(fn, args2) {
  return isArray2(args2) ? fn.apply(void 0, __spreadArray([], __read(args2))) : fn(args2);
}
__name(callOrApply, "callOrApply");
function mapOneOrManyArgs(fn) {
  return map(function(args2) {
    return callOrApply(fn, args2);
  });
}
__name(mapOneOrManyArgs, "mapOneOrManyArgs");

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
init_process_shim();
var isArray3 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto13 = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args2) {
  if (args2.length === 1) {
    var first_1 = args2[0];
    if (isArray3(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys3 = getKeys(first_1);
      return {
        args: keys3.map(function(key) {
          return first_1[key];
        }),
        keys: keys3
      };
    }
  }
  return { args: args2, keys: null };
}
__name(argsArgArrayOrObject, "argsArgArrayOrObject");
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto13;
}
__name(isPOJO, "isPOJO");

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
init_process_shim();
function createObject(keys3, values) {
  return keys3.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}
__name(createObject, "createObject");

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args2);
  var resultSelector = popResultSelector(args2);
  var _a8 = argsArgArrayOrObject(args2), observables = _a8.args, keys3 = _a8.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys3 ? function(values) {
    return createObject(keys3, values);
  } : identity2));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
__name(combineLatest, "combineLatest");
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity2;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length3 = observables.length;
      var values = new Array(length3);
      var active = length3;
      var remainingFirstValues = length3;
      var _loop_1 = /* @__PURE__ */ __name(function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      }, "_loop_1");
      for (var i = 0; i < length3; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
__name(combineLatestInit, "combineLatestInit");
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
__name(maybeSchedule, "maybeSchedule");

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
init_process_shim();
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
__name(timer, "timer");

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
init_process_shim();
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}
__name(scanInternals, "scanInternals");

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
init_process_shim();
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity2;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first || !comparator(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
__name(distinctUntilChanged, "distinctUntilChanged");
function defaultCompare(a, b) {
  return a === b;
}
__name(defaultCompare, "defaultCompare");

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
init_process_shim();
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}
__name(scan, "scan");

// node_modules/rxjs/dist/esm5/internal/operators/share.js
init_process_shim();
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a8 = options.connector, connector = _a8 === void 0 ? function() {
    return new Subject();
  } : _a8, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = /* @__PURE__ */ __name(function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    }, "cancelReset");
    var reset = /* @__PURE__ */ __name(function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    }, "reset");
    var resetAndUnsubscribe = /* @__PURE__ */ __name(function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    }, "resetAndUnsubscribe");
    return operate(function(source, subscriber) {
      refCount++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount--;
        if (refCount === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount > 0) {
        connection = new SafeSubscriber({
          next: /* @__PURE__ */ __name(function(value) {
            return dest.next(value);
          }, "next"),
          error: /* @__PURE__ */ __name(function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          }, "error"),
          complete: /* @__PURE__ */ __name(function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }, "complete")
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
__name(share, "share");
function handleReset(reset, on) {
  var args2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args2[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: /* @__PURE__ */ __name(function() {
      onSubscriber.unsubscribe();
      reset();
    }, "next")
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args2)))).subscribe(onSubscriber);
}
__name(handleReset, "handleReset");

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
init_process_shim();
function shareReplay(configOrBufferSize, windowTime, scheduler) {
  var _a8, _b, _c;
  var bufferSize;
  var refCount = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a8 = configOrBufferSize.bufferSize, bufferSize = _a8 === void 0 ? Infinity : _a8, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: /* @__PURE__ */ __name(function() {
      return new ReplaySubject(bufferSize, windowTime, scheduler);
    }, "connector"),
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount
  });
}
__name(shareReplay, "shareReplay");

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
init_process_shim();
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop2));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
__name(takeUntil, "takeUntil");

// src/constants.ts
init_process_shim();
var BASE_HTTP_URL = "https://app.screen.garden";
var baseWsUrl = new URL(BASE_HTTP_URL);
baseWsUrl.protocol = baseWsUrl.protocol.startsWith("https") ? "wss:" : "ws:";
var BASE_WS_URL = baseWsUrl.toString();

// src/intl.ts
init_process_shim();

// src/generated/messages.js
init_process_shim();

// node_modules/@messageformat/runtime/esm/cardinals.js
init_process_shim();

// node_modules/make-plural/cardinals.mjs
init_process_shim();
var d = /* @__PURE__ */ __name((n) => {
  const s = String(n).split("."), v0 = !s[1];
  return n == 1 && v0 ? "one" : "other";
}, "d");
var en = d;

// node_modules/@messageformat/runtime/esm/runtime.js
init_process_shim();
function _nf(lc) {
  return _nf[lc] || (_nf[lc] = new Intl.NumberFormat(lc));
}
__name(_nf, "_nf");
function number(lc, value, offset) {
  return _nf(lc).format(value - offset);
}
__name(number, "number");
function plural(value, offset, lcfunc, data, isOrdinal) {
  if ({}.hasOwnProperty.call(data, value))
    return data[value];
  if (offset)
    value -= offset;
  var key = lcfunc(value, isOrdinal);
  return key in data ? data[key] : data.other;
}
__name(plural, "plural");
function select(value, data) {
  return {}.hasOwnProperty.call(data, value) ? data[value] : data.other;
}
__name(select, "select");

// src/generated/messages.js
var messages_default = {
  en: {
    home: {
      commandName: /* @__PURE__ */ __name(() => "Show Home tab", "commandName"),
      welcome: /* @__PURE__ */ __name(() => "\u{1F44B} screen.garden lets you sync, share, and work with others right in your vault, ", "welcome"),
      welcomeCursors: /* @__PURE__ */ __name(() => "cursors and all.", "welcomeCursors"),
      startPrefix: /* @__PURE__ */ __name(() => "To get started you\u2019ll need to add a ", "startPrefix"),
      collection: /* @__PURE__ */ __name(() => "collection", "collection"),
      startSuffix: /* @__PURE__ */ __name(() => ", a folder to sync. It can be your entire vault or just a folder somewhere inside it.", "startSuffix"),
      addCollection: /* @__PURE__ */ __name(() => "Add collection", "addCollection"),
      collectionsAvailable1: /* @__PURE__ */ __name((d2) => "Good news: it looks like you already have " + plural(d2.collections, 0, en, { one: "a collection", other: "collections" }) + " available from your " + plural(d2.teams, 0, en, { one: "team", other: "teams" }) + ". To sync and collaborate with your team, choose ", "collectionsAvailable1"),
      collectionsAvailable2: /* @__PURE__ */ __name(() => " below and connect an existing collection.", "collectionsAvailable2"),
      collectionsHeader: /* @__PURE__ */ __name(() => "Collections", "collectionsHeader"),
      collectionCard: {
        activeCollaborators: /* @__PURE__ */ __name(() => "Active Notes", "activeCollaborators"),
        editing: /* @__PURE__ */ __name((d2) => d2.name + " (Editing)", "editing"),
        viewing: /* @__PURE__ */ __name((d2) => d2.name + " (Viewing)", "viewing"),
        anonymous: /* @__PURE__ */ __name(() => "No Name Set", "anonymous")
      }
    },
    settingsTab: {
      homeSettingName: /* @__PURE__ */ __name(() => "Home", "homeSettingName"),
      homeSettingDesc: /* @__PURE__ */ __name(() => 'You can always get to the screen.garden Home tab using the "Show Home tab" command.', "homeSettingDesc"),
      showHomeTab: /* @__PURE__ */ __name(() => "Show Home tab", "showHomeTab"),
      accountSettingName: /* @__PURE__ */ __name(() => "Account", "accountSettingName"),
      accountSettingsDesc: /* @__PURE__ */ __name(() => "You are not currently logged into a screen.garden account. screen.garden requires an account to enable realtime, secure collaboration.", "accountSettingsDesc"),
      loginButton: /* @__PURE__ */ __name(() => "Log into screen.garden", "loginButton"),
      createAccountButton: /* @__PURE__ */ __name(() => "Create an account", "createAccountButton"),
      loggedIn: /* @__PURE__ */ __name((d2) => "You are currently logged into your screen.garden account" + select(d2.email, { undefined: ".", other: ": " + d2.email }), "loggedIn"),
      logOutButton: /* @__PURE__ */ __name(() => "Log out", "logOutButton"),
      manageAccountButton: /* @__PURE__ */ __name(() => "Manage account", "manageAccountButton"),
      toggleDebugCommand: /* @__PURE__ */ __name(() => "Toggle debug logging", "toggleDebugCommand"),
      debugToggledNotice: /* @__PURE__ */ __name((d2) => "Debug logging " + d2.state, "debugToggledNotice"),
      authError: /* @__PURE__ */ __name(() => "Error during screen.garden authentication. Please try again.", "authError"),
      loginDetails1: /* @__PURE__ */ __name(() => "Finish connecting to screen.garden in your browser. If a browser did not open,", "loginDetails1"),
      loginDetails2: /* @__PURE__ */ __name(() => "click here.", "loginDetails2"),
      loginDetailsRaw: /* @__PURE__ */ __name((d2) => 'Finish connecting to screen.garden in your browser. If a browser did not open, <a href="' + d2.url + `" target=_'blank'>click here</a>`, "loginDetailsRaw"),
      ui: {
        header: /* @__PURE__ */ __name(() => "UI", "header"),
        folderBorders: {
          name: /* @__PURE__ */ __name(() => "Show collection lines", "name"),
          desc: /* @__PURE__ */ __name(() => "Change the color of the folder indentation lines in the File Explorer for your collections.", "desc")
        },
        folderIcons: {
          name: /* @__PURE__ */ __name(() => "Show folder icons", "name"),
          desc: /* @__PURE__ */ __name(() => "Show icons next to collection folders in the File Explorer.", "desc")
        },
        statusIcon: {
          name: /* @__PURE__ */ __name(() => "Show status item", "name"),
          desc: /* @__PURE__ */ __name(() => "Show an item in the status bar on desktop to indicate when you\u2019re connected to screen.garden servers.", "desc")
        }
      }
    },
    mountModal: {
      contextMenuItem: /* @__PURE__ */ __name(() => "Sync in screen.garden", "contextMenuItem"),
      title: /* @__PURE__ */ __name(() => "Add collection", "title"),
      loadTeamsError: /* @__PURE__ */ __name(() => "No teams loaded; please sign into screen.garden and try again.", "loadTeamsError"),
      nextButton: /* @__PURE__ */ __name(() => "Next", "nextButton"),
      createButton: /* @__PURE__ */ __name(() => "Create", "createButton"),
      connectButton: /* @__PURE__ */ __name(() => "Connect", "connectButton"),
      createErrorNotice: /* @__PURE__ */ __name(() => "Error creating your new collection. Please check dev logs.", "createErrorNotice"),
      successNotice: /* @__PURE__ */ __name(() => "Success! Now syncing, changes will be merged without conflict.", "successNotice"),
      noNestingNotice: /* @__PURE__ */ __name(() => "Cannot put a collection inside another collection", "noNestingNotice"),
      s: {
        team: /* @__PURE__ */ __name(() => "Collections belong to screen.garden teams. Please choose or create a team for this collection.", "team"),
        target1: /* @__PURE__ */ __name(() => "Create a new collection in your ", "target1"),
        target2: /* @__PURE__ */ __name(() => " team or connect an existing collection?", "target2"),
        new1: /* @__PURE__ */ __name(() => "You\u2019re creating ", "new1"),
        new2: /* @__PURE__ */ __name(() => ", a new collection in ", "new2"),
        new3: /* @__PURE__ */ __name(() => ". Where in your vault should it live?", "new3"),
        existing1: /* @__PURE__ */ __name(() => "You\u2019re connecting ", "existing1"),
        existing2: /* @__PURE__ */ __name(() => " in your ", "existing2"),
        existing3: /* @__PURE__ */ __name(() => " team. Where in your vault should it live?", "existing3"),
        noExistingWarning: /* @__PURE__ */ __name(() => "Your folder must be empty to connect it to an existing collection. Please create a new collection or choose an empty folder.", "noExistingWarning")
      },
      t: {
        newTitle: /* @__PURE__ */ __name(() => "New collection", "newTitle"),
        newDesc: /* @__PURE__ */ __name(() => "Create a new collection. Requires internet connection.", "newDesc"),
        existingTitle: /* @__PURE__ */ __name(() => "Connect existing", "existingTitle"),
        existingDesc: /* @__PURE__ */ __name(() => "Sync a collection your team already owns to a folder in your vault.", "existingDesc"),
        chooseDefault: /* @__PURE__ */ __name(() => "Choose a collection\u2026", "chooseDefault")
      },
      w: {
        vaultTitle: /* @__PURE__ */ __name(() => "Entire vault", "vaultTitle"),
        vaultDesc: /* @__PURE__ */ __name(() => "Sync your entire vault with screen.garden.", "vaultDesc"),
        vaultComingSoon: /* @__PURE__ */ __name(() => "Syncing your entire vault as a single collection is coming soon!", "vaultComingSoon"),
        folderTitle: /* @__PURE__ */ __name(() => "A folder", "folderTitle"),
        folderDesc: /* @__PURE__ */ __name(() => "Sync a folder somewhere in your vault with screen.garden.", "folderDesc"),
        folderPrefix: /* @__PURE__ */ __name(() => "Your collection will be synced to ", "folderPrefix"),
        folderSuggestNewPlaceholder: /* @__PURE__ */ __name(() => "An unsynced folder", "folderSuggestNewPlaceholder"),
        folderSuggestExistingPlaceholder: /* @__PURE__ */ __name(() => "An empty, unsynced folder", "folderSuggestExistingPlaceholder"),
        vaultNotAvailableWarning: /* @__PURE__ */ __name(() => "Your vault must be empty to connect it to an existing collection. Please choose an empty folder or create a new collection.", "vaultNotAvailableWarning"),
        externalProviderInfo: /* @__PURE__ */ __name((d2) => "Heads up! You currently have " + d2.providers + " enabled. screen.garden attempts to prevent double-syncs; this is a failsafe, and for best results please manually ensure folders managed by screen.garden are ignored by other sync systems.", "externalProviderInfo")
      }
    },
    unmountModal: {
      contextMenuItem: /* @__PURE__ */ __name(() => "Disconnect from screen.garden", "contextMenuItem"),
      title: /* @__PURE__ */ __name((d2) => 'Disconnect "' + d2.path + '" from screen.garden?', "title"),
      explanation: /* @__PURE__ */ __name(() => "Removing a folder from screen.garden will stop any changes to notes in that folder from syncing with your team.", "explanation"),
      explanation2: /* @__PURE__ */ __name(() => "No notes will be deleted from Obsidian.", "explanation2"),
      cancel: /* @__PURE__ */ __name(() => "Cancel", "cancel"),
      remove: /* @__PURE__ */ __name(() => "Remove", "remove"),
      successNotice: /* @__PURE__ */ __name((d2) => "Disconnected " + d2.path + " from screen.garden", "successNotice")
    },
    folderSuggest: {
      upDownInstruction: /* @__PURE__ */ __name(() => "to navigate", "upDownInstruction"),
      enterInstruction: /* @__PURE__ */ __name(() => "to choose folder", "enterInstruction"),
      escInstruction: /* @__PURE__ */ __name(() => "to dismiss", "escInstruction")
    },
    note: {
      copyCurrentURLCommand: {
        title: /* @__PURE__ */ __name(() => "Copy web URL", "title"),
        error: /* @__PURE__ */ __name(() => "Error getting note data for URL", "error"),
        success: /* @__PURE__ */ __name(() => "URL copied to your clipboard", "success")
      },
      renamedRemotely: /* @__PURE__ */ __name((d2) => "Due to a conflict, " + d2.old + " was renamed to " + d2["new"], "renamedRemotely")
    },
    plurals: {
      two: /* @__PURE__ */ __name((d2) => d2.val1 + " and " + d2.val2, "two"),
      serial: /* @__PURE__ */ __name((d2) => d2.joined + ", and " + d2.last, "serial")
    },
    statusBarItem: {
      connected: /* @__PURE__ */ __name(() => "Connected to screen.garden", "connected"),
      connectedWithContention: /* @__PURE__ */ __name(() => "Connected to screen.garden\nPrioritizing active notes", "connectedWithContention"),
      disconnected: /* @__PURE__ */ __name(() => "Working offline; changes will sync when reconnected", "disconnected")
    },
    viewAction: {
      connected: /* @__PURE__ */ __name(() => "Connected to screen.garden\nClick for options", "connected"),
      disconnected: /* @__PURE__ */ __name(() => "Working offline\nChanges will sync when reconnected\nClick for options", "disconnected"),
      menu: {
        collection: /* @__PURE__ */ __name((d2) => "Collection: " + d2.collection, "collection"),
        team: /* @__PURE__ */ __name((d2) => "Team: " + d2.team, "team"),
        web: /* @__PURE__ */ __name(() => "Open on web", "web"),
        collaboratorCount: /* @__PURE__ */ __name((d2) => d2.count + " " + plural(d2.count, 0, en, { one: "active collaborator", other: "active collaborators" }), "collaboratorCount"),
        collaboratorLabel: /* @__PURE__ */ __name(() => "Jump to collaborator\u2026", "collaboratorLabel"),
        copyURL: /* @__PURE__ */ __name(() => "Copy web URL", "copyURL")
      }
    },
    fileExplorer: {
      withTeam: /* @__PURE__ */ __name((d2) => "Synced with " + d2.collection + "\n" + plural(d2.pending, 0, en, { "0": "", other: number("en", d2.pending, 0) + " pending\n" }) + d2.team + "\u2019s screen.garden", "withTeam"),
      withoutTeam: /* @__PURE__ */ __name((d2) => "Synced with " + d2.collection + "\n" + plural(d2.pending, 0, en, { "0": "", other: number("en", d2.pending, 0) + " pending\n" }) + "screen.garden", "withoutTeam")
    },
    socket: {
      connectCommand: /* @__PURE__ */ __name(() => "Go online", "connectCommand"),
      disconnectCommand: /* @__PURE__ */ __name(() => "Go offline", "disconnectCommand")
    }
  }
};

// src/intl.ts
var intl = messages_default.en;

// src/util/urls.ts
init_process_shim();
var import_obsidian2 = require("obsidian");
function noteURL(team, collection, note) {
  return `${BASE_HTTP_URL}/t/${team.short_id}/c/${collection.short_id}/n/${note.id}`;
}
__name(noteURL, "noteURL");
function copyNoteURLToClipboard(team, collection, note, notifiying = true) {
  const url = noteURL(team, collection, note);
  navigator.clipboard.writeText(url);
  if (notifiying) {
    new import_obsidian2.Notice(intl.note.copyCurrentURLCommand.success());
  }
}
__name(copyNoteURLToClipboard, "copyNoteURLToClipboard");
function openURLExternally(app, url) {
  const plugin = app.internalPlugins.plugins.webviewer;
  if (plugin && plugin.enabled && typeof plugin.instance.openUrlExternally === "function") {
    plugin.instance.openUrlExternally(url);
  } else {
    window.open(url, "_external");
  }
}
__name(openURLExternally, "openURLExternally");

// node_modules/uuid/dist/esm-browser/index.js
init_process_shim();

// node_modules/uuid/dist/esm-browser/stringify.js
init_process_shim();
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
var i;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
__name(unsafeStringify, "unsafeStringify");

// node_modules/uuid/dist/esm-browser/rng.js
init_process_shim();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
__name(rng, "rng");

// node_modules/uuid/dist/esm-browser/v4.js
init_process_shim();

// node_modules/uuid/dist/esm-browser/native.js
init_process_shim();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
__name(v4, "v4");
var v4_default = v4;

// src/services/account/AccountService.ts
var TABLE = ",id,email,name";
var ACCOUNT_ID = "screen.garden:account";
var CACHED_APP_TOKEN = "screengarden:obsidian:app-auth-token";
var log = (0, import_debug.default)("screen.garden:account");
var _AccountService = class _AccountService extends Service {
  constructor(plugin) {
    super(plugin);
    this._account = null;
    this.handleAppAuthenticated = /* @__PURE__ */ __name(async ({ token }) => {
      if (!token) return;
      log("authenticated, setting token");
      await this.plugin.settings.updateConfig({ token });
      this.endAuth();
    }, "handleAppAuthenticated");
    this.observable = liveQuery(
      () => this.db.account.get(ACCOUNT_ID)
    );
    this.subscription = this.observable.subscribe((account) => {
      if (account != null) {
        this._account = account;
      } else {
        this._account = null;
      }
    });
    const poll = timer(0, (0, import_ms.default)("1 hour"));
    this.pollSubscription = combineLatest([
      poll,
      this.plugin.networkStatus.observable,
      this.plugin.api.observable
    ]).subscribe({
      next: /* @__PURE__ */ __name(async ([, networkStatus, api]) => {
        if (api == null) {
          log("clearing stored account");
          await this.db.account.delete(ACCOUNT_ID);
          return;
        }
        if (networkStatus === "online" && api != null) {
          log("fetching account");
          try {
            const { data: fetchedAccount } = await api.get("/me");
            if (!isEqual_default(fetchedAccount, this._account)) {
              await this.db.account.put(fetchedAccount, ACCOUNT_ID);
            }
          } catch (e) {
            log("failed to fetch account");
          }
        }
      }, "next")
    });
  }
  get() {
    return this._account;
  }
  async onunload() {
    this.subscription.unsubscribe();
    this.pollSubscription.unsubscribe();
  }
  // Get or mint and cache a token to identify this obsidian client during an auth poll.
  // Storing it locally handles the case where someone begins browser auth and restarts Obsidian in the meantime.
  getClientToken() {
    const cachedToken = window.localStorage.getItem(CACHED_APP_TOKEN);
    if (cachedToken) return cachedToken;
    const newToken = v4_default();
    window.localStorage.setItem(CACHED_APP_TOKEN, newToken);
    return newToken;
  }
  async startAuth(entrypoint, withURL) {
    this.endAuth();
    log("starting auth");
    const token = this.getClientToken();
    this.authSocket = new Socket(`${BASE_WS_URL}/auth/socket`, {
      params: {
        token,
        app: "obsidian"
      }
    });
    const authURL = this.authURL(entrypoint, token);
    openURLExternally(this.plugin.app, authURL);
    withURL(authURL);
    await new Promise((resolve) => {
      var _a8, _b;
      (_a8 = this.authSocket) == null ? void 0 : _a8.onOpen(resolve);
      (_b = this.authSocket) == null ? void 0 : _b.connect();
    });
    this.authChannel = this.authSocket.channel(`app_auth:${token}`);
    this.authChannel.join().receive("ok", () => {
      var _a8;
      log(`app_auth:${token} joined`);
      (_a8 = this.authChannel) == null ? void 0 : _a8.on("authenticated", this.handleAppAuthenticated);
    }).receive("error", (msg) => {
      log(`app_auth:${token} rejected`, msg);
      new import_obsidian3.Notice(intl.settingsTab.authError());
      this.endAuth();
    });
  }
  endAuth() {
    var _a8, _b;
    log("ending auth");
    (_a8 = this.authChannel) == null ? void 0 : _a8.leave();
    this.authChannel = null;
    (_b = this.authSocket) == null ? void 0 : _b.disconnect();
    this.authSocket = null;
  }
  authURL(entrypoint, token) {
    return entrypoint === "login" ? `${BASE_HTTP_URL}/users/log_in?app=obsidian&token=${token}` : `${BASE_HTTP_URL}/users/register?app=obsidian&token=${token}`;
  }
};
__name(_AccountService, "AccountService");
var AccountService = _AccountService;

// src/services/collections/CollectionsService.ts
init_process_shim();

// src/services/collections/CollectionHandler.ts
init_process_shim();
var import_debug2 = __toESM(require_browser2());
var import_obsidian5 = require("obsidian");

// src/util/path.ts
init_process_shim();
var import_obsidian4 = require("obsidian");
var isPathOrFile = /* @__PURE__ */ __name((test2) => typeof test2 === "string" || typeof test2 === "object" && test2 !== null && "path" in test2, "isPathOrFile");
var getPath = /* @__PURE__ */ __name((pathOrFile) => typeof pathOrFile === "string" ? pathOrFile : pathOrFile.path, "getPath");
var getTitle = /* @__PURE__ */ __name((pathOrFile) => {
  if (pathOrFile instanceof import_obsidian4.TAbstractFile) {
    return pathOrFile.name;
  }
  const lastComponent = getPath(pathOrFile).split("/").last();
  if (!lastComponent) return "Untitled";
  const i = lastComponent.lastIndexOf(".");
  if (i < 0) return lastComponent;
  return lastComponent.slice(0, i);
}, "getTitle");
var pathContains = /* @__PURE__ */ __name((path, subpath) => {
  const p = getPath(subpath);
  return p.startsWith(`${path}/`) || p === path;
}, "pathContains");

// src/services/collections/CollectionHandler.ts
function collectionHandlerReadyEvent(id) {
  return `collections:${id}:ready`;
}
__name(collectionHandlerReadyEvent, "collectionHandlerReadyEvent");
var YMAP_KEY = "s.g:collection:v0";
var PENDING_KEY = "s.g:pending:v0";
var TRASH_KEY = "s.g:trash:v0";
var ADDITIONS_BUFFER_MS = 2e3;
var DELETIONS_BUFFER_MS = 400;
var MOUNT_RENAMES_BUFFER_MS = 2e3;
var COLLECTION_PRESENCE_DEBOUNCE_MS = 3e3;
var EXTERNAL_EDIT_TIMEOUT_MS = 5e3;
function noteIdFor(mapValue) {
  return typeof mapValue == "string" ? mapValue : null;
}
__name(noteIdFor, "noteIdFor");
var _CollectionHandler = class _CollectionHandler {
  constructor(plugin, id, path) {
    this.plugin = plugin;
    this.id = id;
    this.path = path;
    this.loaded = false;
    this.pendingAdditions = [];
    this.deletions = /* @__PURE__ */ new Set();
    this.deletionTimeoutId = -1;
    this.closing = false;
    this.presenceListener = null;
    this.lastPresenceMeta = null;
    this.previousMountPaths = [];
    this.previousMountPathTouches = /* @__PURE__ */ new Map();
    /**
     * Set of paths that are being modified by the plugin itself in the background
     * and thus should not be counted as being externally modified.
     */
    this.controlledModifies = /* @__PURE__ */ new Set();
    this.log = (0, import_debug2.default)(`screen.garden:collection:${id}`);
    this.log("initalizing, path: %s", path);
    this.plugin.externalProviders.ignorePath(this.path);
    this.onload();
    this.observer = this.observer.bind(this);
    this.onPresenceSync = throttle_default(
      this.handlePresenceSync.bind(this),
      COLLECTION_PRESENCE_DEBOUNCE_MS,
      { leading: true, trailing: true }
    );
    this.addPendingAdditions = throttle_default(
      this._addPendingAdditions.bind(this),
      ADDITIONS_BUFFER_MS
    );
  }
  async onload() {
    const lifecycle = {
      onJoin: /* @__PURE__ */ __name((_dc, joinReply) => {
        if (joinReply && "pool_size" in joinReply) {
          this.plugin.notes.poolSize = joinReply["pool_size"];
        }
      }, "onJoin"),
      afterSync: /* @__PURE__ */ __name(async (h) => {
        try {
          const cs = await this.plugin.db.collectionSettings.get(this.id);
          if (!cs) return;
          const noteIDs = await h.push("catchup-collection", {
            since: cs.last_sync.toISOString()
          });
          this.enqueueCatchupHandlers(noteIDs);
          this.plugin.db.collectionSettings.update(this.id, {
            last_sync: /* @__PURE__ */ new Date()
          });
        } catch (e) {
          this.log("catchup failed");
        }
      }, "afterSync")
    };
    this.doc = await this.plugin.docs.getOrCreateAndLoad(
      this.id,
      {
        kind: "collection"
      },
      lifecycle
    );
    this.pushPresence = debounce_default(
      this.doc.channel.pushPresence,
      COLLECTION_PRESENCE_DEBOUNCE_MS
    );
    this.log("loaded doc %s", this.doc.id);
    this.ymap = this.doc.ydoc.getMap(YMAP_KEY);
    this.ymap.observe(this.observer);
    this.pending = this.doc.ydoc.getMap(PENDING_KEY);
    this.trash = this.doc.ydoc.getMap(TRASH_KEY);
    this.plugin.collections.reportSize(this.id, this.ymap.size);
    for (const key of this.ymap.keys()) {
      const id = this.ymap.get(key);
      const path = this.addPathPrefix(key);
      if (id && this.plugin.app.vault.getAbstractFileByPath(path) == null) {
        await this.ensurePath(path);
        try {
          await this.plugin.app.vault.create(path, "");
        } catch (error) {
          this.log(`error creating file at path "${path}"`, error);
        }
        await this.plugin.notes.create([
          {
            path,
            id,
            collectionId: this.id,
            priority: "background"
          }
        ]);
      }
    }
    const orphanedPendingNotes = /* @__PURE__ */ new Map();
    for (const note of await this.plugin.db.pendingNotes.where({ collection_id: this.id }).toArray()) {
      orphanedPendingNotes.set(note.id, note);
    }
    for (const id of this.pending.keys()) {
      const path = this.pending.get(id);
      if (path) {
        orphanedPendingNotes.delete(id);
        const prefixedPath = this.addPathPrefix(path);
        if (this.plugin.app.vault.getAbstractFileByPath(prefixedPath)) {
          await this.plugin.notes.create([
            {
              path: prefixedPath,
              id,
              collectionId: this.id,
              priority: "background"
            }
          ]);
        }
      }
    }
    this.plugin.db.pendingNotes.bulkDelete([...orphanedPendingNotes.keys()]);
    this.plugin.registerEvent(
      this.plugin.app.vault.on("create", this.handleVaultCreate, this)
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("rename", this.handleVaultRename, this)
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("delete", this.handleVaultDelete, this)
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("modify", this.handleVaultModify, this)
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on(
        "active-leaf-change",
        this.activeLeafChange,
        this
      )
    );
    this.presenceListener = this.plugin.docs.on(
      `presence:${this.id}`,
      this.onPresenceSync
    );
    this.loaded = true;
    this.plugin.collections.trigger(collectionHandlerReadyEvent(this.id));
  }
  close() {
    var _a8;
    if (this.closing) return;
    this.closing = true;
    this.log(`closing handler at ${this.path}`);
    (_a8 = this.pushPresence) == null ? void 0 : _a8.cancel();
    this.plugin.app.vault.off("create", this.handleVaultCreate);
    this.plugin.app.vault.off("rename", this.handleVaultRename);
    this.plugin.app.vault.off("delete", this.handleVaultDelete);
    this.plugin.app.workspace.off("active-leaf-change", this.activeLeafChange);
    this.addPendingAdditions.flush();
    this.onPresenceSync.cancel();
    if (this.presenceListener) this.plugin.docs.offref(this.presenceListener);
    this.ymap.unobserve(this.observer);
    this.plugin.docs.unload(this.doc);
    window.clearTimeout(this.deletionTimeoutId);
  }
  async requireNoteHandlerForFile(file) {
    if (!this.loaded) {
      const ref = await new Promise(
        (resolve) => this.plugin.collections.on(
          collectionHandlerReadyEvent(this.id),
          resolve
        )
      );
      this.plugin.collections.offref(ref);
    }
    const membership = await this.membershipByPath(file);
    this.log("membership", membership);
    if (membership == null ? void 0 : membership.noteId) {
      return this.plugin.notes.require(membership.noteId, this.id, file.path);
    }
    return null;
  }
  enqueueCatchupHandlers(noteIDs) {
    if (noteIDs.length === 0) return;
    this.log("enqueueing catchup handlers for %d notes", noteIDs.length);
    const idsToPrefixedPaths = /* @__PURE__ */ new Map();
    for (const [path, id] of this.ymap.entries()) {
      idsToPrefixedPaths.set(id, this.addPathPrefix(path));
    }
    for (const id of noteIDs) {
      const prefixedPath = idsToPrefixedPaths.get(id);
      if (!prefixedPath) continue;
      this.plugin.notes.catchup(id, prefixedPath, this.id);
    }
  }
  async observer(evt, txn) {
    this.plugin.collections.reportSize(this.id, this.ymap.size);
    if (txn.origin === this) return;
    const changes = [...evt.changes.keys.entries()];
    const renamed = [];
    const added = [];
    const deleted = [];
    let change;
    while (change = changes.pop()) {
      const [path, { action, oldValue }] = change;
      if (action === "update") continue;
      const noteId = noteIdFor(oldValue != null ? oldValue : evt.target.get(path));
      if (!noteId) continue;
      const matchingRenameAction = action === "add" ? "delete" : "add";
      const matchIdx = changes.findIndex(
        ([mp, { action: ma, oldValue: mv }]) => {
          return ma === matchingRenameAction && noteIdFor(mv != null ? mv : evt.target.get(mp)) === noteId;
        }
      );
      if (matchIdx >= 0) {
        const [match] = changes.splice(matchIdx, 1);
        renamed.push({
          from: action === "delete" ? change : match,
          to: action === "delete" ? match : change
        });
        continue;
      }
      if (action === "add") {
        added.push(change);
      } else if (action === "delete") {
        deleted.push(change);
      }
    }
    this.log(
      "%d additions, %d deletes, and %d renames",
      added.length,
      deleted.length,
      renamed.length
    );
    for (const {
      from: [fromPath],
      to: [toPath]
    } of renamed) {
      this.log('rename "%s" -> "%s"', fromPath, toPath);
      const noteId = this.ymap.get(toPath);
      if (!noteId) continue;
      const oldPath = this.addPathPrefix(fromPath);
      const curr = this.plugin.app.vault.getAbstractFileByPath(oldPath);
      const dest = this.addPathPrefix(toPath);
      await this.plugin.db.notes.update(noteId, {
        path: dest,
        title: getTitle(toPath)
      });
      if (curr) {
        await this.ensurePath(dest);
        await this.plugin.app.vault.rename(curr, dest);
      }
    }
    for (const [path] of added) {
      const id = this.ymap.get(path);
      if (!id) continue;
      const dest = this.addPathPrefix(path);
      await this.plugin.notes.create([
        {
          path: dest,
          id,
          collectionId: this.id,
          priority: "background"
        }
      ]);
      await this.ensurePath(dest);
      if (!this.plugin.app.vault.getAbstractFileByPath(dest)) {
        await this.plugin.app.vault.create(dest, "");
      }
    }
    for (const [path, { oldValue: noteId }] of deleted) {
      const file = this.plugin.app.vault.getAbstractFileByPath(
        this.addPathPrefix(path)
      );
      if (file) this.plugin.app.vault.delete(file);
      await this.plugin.notes.delete(noteId);
    }
  }
  async handleVaultCreate(file) {
    if (!this.addableFile(file)) return;
    this.log("handleVaultCreate", file);
    this.pendingAdditions.push(file);
    this.addPendingAdditions();
  }
  _addPendingAdditions() {
    const toAdd = [...this.pendingAdditions];
    this.pendingAdditions = [];
    this.addNotes(toAdd);
  }
  /**
   * addNotes add note(s) to the collection, ensuring that they don't enter
   * the base ymap until they've been created on the server by storing them in a
   * dedicated pending ymap.
   * @param files The files to add to the collection.
   */
  async addNotes(files) {
    const toAdd = files.filter((f) => this.addableFile(f)).map((f) => ({
      id: v4_default(),
      path: f.path,
      collection_id: this.id
    }));
    await this.plugin.db.pendingNotes.bulkPut(toAdd);
    this.doc.ydoc.transact(() => {
      toAdd.forEach(({ id, path }) => {
        this.pending.set(id, this.removePathPrefix(path));
      });
    }, this);
    this.plugin.notes.create(
      toAdd.map(({ id, path, collection_id }) => ({
        id,
        path,
        collectionId: collection_id,
        priority: "background"
      }))
    );
  }
  async membershipByPath(pathOrFile) {
    if (!this.inCollection(pathOrFile)) return null;
    const prefixedPath = getPath(pathOrFile);
    const keyPath = this.removePathPrefix(prefixedPath);
    const r = { keyPath, prefixedPath };
    const memberId = this.ymap.get(keyPath);
    if (memberId) return { ...r, noteId: memberId, state: "member" };
    for (const [id, pendingPath] of this.pending.entries()) {
      if (pendingPath === keyPath) {
        const pendingNote = await this.plugin.db.pendingNotes.get(id);
        if ((pendingNote == null ? void 0 : pendingNote.path) === prefixedPath) {
          return { ...r, noteId: id, state: "pending" };
        }
      }
    }
    return null;
  }
  membershipById(id) {
    for (const [memberId, keyPath] of this.ymap.entries()) {
      if (memberId === id) {
        return {
          noteId: id,
          keyPath,
          prefixedPath: this.addPathPrefix(keyPath),
          state: "member"
        };
      }
    }
    const pendingPath = this.pending.get(id);
    if (pendingPath) {
      return {
        noteId: id,
        keyPath: pendingPath,
        prefixedPath: this.addPathPrefix(pendingPath),
        state: "pending"
      };
    }
    return null;
  }
  // A synchronous getter for member-only notes.
  noteIdForMemberPath(pathOrFile) {
    var _a8;
    const path = this.removePathPrefix(getPath(pathOrFile));
    return (_a8 = this.ymap.get(path)) != null ? _a8 : null;
  }
  async handleVaultRename(file, oldPath) {
    if (file instanceof import_obsidian5.TFolder && oldPath === this.path) {
      this.log("renaming mount folder!");
      this.previousMountPaths.push(this.path);
      this.path = file.path;
      this.plugin.externalProviders.ignorePath(this.path);
      this.plugin.db.collectionSettings.update(this.id, {
        mount_path: this.path
      });
      return;
    }
    if (!this.isMarkdown(file) || !this.isMarkdown(oldPath)) return;
    if (!this.inCollection(oldPath) && this.inCollection(file))
      return this.handleVaultCreate(file);
    if (this.inCollection(oldPath) && !this.inCollection(file))
      return this.handleVaultDelete({ path: oldPath });
    if (!this.inCollection(file) && !this.inCollection(oldPath)) return;
    const fromPath = this.removePathPrefix(oldPath);
    const toPath = this.removePathPrefix(file.path);
    const existingNoteId = this.ymap.get(toPath);
    if (existingNoteId) {
      this.log("upstream rename of %s", toPath);
      await this.plugin.db.notes.update(existingNoteId, {
        path: file.path,
        title: getTitle(file.path)
      });
      return;
    }
    this.log("rename %s (in %s)", fromPath, this.path);
    const membership = await this.membershipByPath(oldPath);
    if (!membership) return;
    const { noteId } = membership;
    if (membership.state === "pending") {
      await this.plugin.db.pendingNotes.update(noteId, {
        path: file.path
      });
    }
    await this.plugin.db.notes.update(noteId, {
      path: file.path,
      title: getTitle(file.path)
    });
    if (membership.state === "pending") {
      this.doc.ydoc.transact(() => {
        this.pending.set(noteId, toPath);
      }, this);
    } else {
      this.doc.ydoc.transact(() => {
        this.ymap.set(toPath, noteId);
        this.ymap.delete(fromPath);
      }, this);
    }
    this.log(
      'moved from "%s" to "%s"',
      this.removePathPrefix(oldPath),
      this.removePathPrefix(file.path)
    );
  }
  async handleVaultDelete(file) {
    if (!this.inCollection(file)) return;
    if (this.deletionTimeoutId > 0) {
      window.clearTimeout(this.deletionTimeoutId);
    }
    this.deletions.add(file.path);
    this.deletionTimeoutId = window.setTimeout(
      this.processDeletions.bind(this),
      DELETIONS_BUFFER_MS
    );
  }
  async processDeletions() {
    this.log("processing %d deletions", this.deletions.size);
    const deletedCollection = this.deletions.has(this.path);
    this.deletions.delete(this.path);
    const deletedPaths = [...this.deletions.values()].filter(
      (p) => this.isMarkdown(p)
    );
    this.deletionTimeoutId = -1;
    this.deletions.clear();
    if (deletedCollection) {
      this.close();
      await this.plugin.collections.unmount(this.id);
      return;
    }
    const deletedNoteIds = [];
    const deletedMemberPaths = [];
    const deletedPendingIds = [];
    for (const path of deletedPaths) {
      const membership = await this.membershipByPath(path);
      if ((membership == null ? void 0 : membership.state) === "member") {
        deletedMemberPaths.push(membership.keyPath);
        deletedNoteIds.push(membership.noteId);
      } else if ((membership == null ? void 0 : membership.state) === "pending") {
        const localNote = await this.plugin.db.notes.get(membership.noteId);
        if ((localNote == null ? void 0 : localNote.path) === membership.keyPath) {
          deletedPendingIds.push(membership.noteId);
        }
      }
      if (membership) {
        await this.plugin.notes.delete(membership.noteId);
      }
    }
    this.doc.ydoc.transact(() => {
      for (const keyPath of deletedMemberPaths) {
        this.ymap.delete(keyPath);
      }
      for (const pendingId of deletedPendingIds) {
        this.pending.delete(pendingId);
      }
      deletedNoteIds.forEach(
        (id) => this.trash.set(id, (/* @__PURE__ */ new Date()).toISOString())
      );
    }, this);
  }
  async controlModify(path, fn) {
    try {
      this.controlledModifies.add(path);
      return await fn();
    } finally {
      this.controlledModifies.delete(path);
    }
  }
  handleVaultModify(file) {
    const path = getPath(file);
    if (!(file instanceof import_obsidian5.TFile)) return;
    if (!this.inCollection(file)) return;
    if (!this.isMarkdown(file)) return;
    if (this.controlledModifies.has(path)) return;
    const keyPath = this.removePathPrefix(path);
    const noteId = this.ymap.get(keyPath);
    if (noteId && this.plugin.notes.ytextAcquired(noteId)) return;
    this.handlePossibleModifiy(file);
  }
  async handlePossibleModifiy(file) {
    const path = getPath(file);
    const membership = await this.membershipByPath(path);
    if (!membership) return;
    if (this.plugin.notes.ytextAcquired(membership.noteId)) return;
    let handler = this.plugin.notes.require(membership.noteId, this.id);
    if (!handler) {
      const awaitingId = membership.noteId;
      handler = await Promise.race([
        new Promise(
          (resolve) => setTimeout(() => resolve(null), EXTERNAL_EDIT_TIMEOUT_MS)
        ),
        new Promise((resolve) => {
          const sub = this.plugin.notes.handlerChanges.subscribe({
            next: /* @__PURE__ */ __name(async ({ id: noteId, path: _path, deleted }) => {
              if (noteId !== awaitingId || deleted) return;
              const handler2 = this.plugin.notes.require(noteId, this.id);
              sub.unsubscribe();
              resolve(handler2);
            }, "next")
          });
        })
      ]);
    }
    if (!handler) {
      this.log(`Could not load a handler for ${path} to handle modifiy`);
      return;
    }
    handler.acceptExternalWrite(file);
  }
  activeLeafChange(leaf) {
    var _a8, _b;
    if (!this.pushPresence) return;
    const notes = [];
    this.plugin.app.workspace.getLeavesOfType("markdown").forEach((innerLeaf) => {
      const state = innerLeaf.view.getState();
      if (isPathOrFile(state.file) && this.inCollection(state.file)) {
        const id = this.noteIdForMemberPath(state.file);
        if (!id) return;
        notes.push({
          id,
          active: leaf === innerLeaf
        });
      }
    });
    const meta = {
      user_name: (_b = (_a8 = this.plugin.account.get()) == null ? void 0 : _a8.name) != null ? _b : null,
      notes
    };
    if (!isEqual_default(meta, this.lastPresenceMeta)) {
      this.pushPresence(meta);
      this.lastPresenceMeta = meta;
    }
  }
  presenceMetas() {
    return this.doc.channel.listPresences(
      "user_id"
    );
  }
  handlePresenceSync(id) {
    var _a8, _b;
    if (id !== this.id) return;
    const me = this.plugin.socket.origin;
    const activeNoteIDs = this.presenceMetas().filter((p) => p.origin !== me).flatMap((p) => {
      var _a9, _b2;
      return (_b2 = (_a9 = p.notes) == null ? void 0 : _a9.filter((n) => n.active).map((n) => n.id)) != null ? _b2 : [];
    });
    for (const id2 of activeNoteIDs) {
      if ((_a8 = this.activePresenceNoteIDs) == null ? void 0 : _a8.includes(id2)) continue;
      this.plugin.notes.require(id2, this.id);
    }
    for (const id2 of (_b = this.activePresenceNoteIDs) != null ? _b : []) {
      if (activeNoteIDs.includes(id2)) continue;
      this.plugin.notes.downgrade(id2, "concurrent");
    }
    this.activePresenceNoteIDs = activeNoteIDs;
  }
  addableFile(file) {
    return this.inCollection(file) && this.isMarkdown(file) && file instanceof import_obsidian5.TFile && !this.noteIdForMemberPath(file);
  }
  // This (and removePathPrefix) is special-cased to handle when the collection mount path
  // has been renamed. In that case, both the current and previous mount paths are considered.
  // The current mount path is given priority.
  // If this function references a previous mount path that path is rescheduled for forgetting.
  inCollection(pathOrFile) {
    for (const mountPath of [this.path, ...this.previousMountPaths]) {
      if (!pathContains(mountPath, pathOrFile)) continue;
      if (mountPath !== this.path) {
        this.touchPreviousMountPath(mountPath);
      }
      return true;
    }
    return false;
  }
  addPathPrefix(path) {
    return `${this.path}/${path}`;
  }
  // This (and inCollection) is special-cased to handle when the collection mount path
  // has been renamed. In that case, the first mount path that contains `path` is removed.
  // The current mount path is given priority.
  // If this function references a previous mount path that path is rescheduled for forgetting.
  removePathPrefix(path) {
    for (const mountPath of [this.path, ...this.previousMountPaths]) {
      if (mountPath === "" || !pathContains(mountPath, path)) continue;
      if (mountPath !== this.path) {
        this.touchPreviousMountPath(mountPath);
      }
      const replacing = `${mountPath}/`;
      if (path.startsWith(replacing)) {
        return path.replace(replacing, "");
      }
      return path;
    }
    return path;
  }
  isMarkdown(pathOrFile) {
    if (pathOrFile instanceof import_obsidian5.TFolder) return false;
    if (pathOrFile instanceof import_obsidian5.TFile) return /^md$/.test(pathOrFile.extension);
    const path = typeof pathOrFile === "string" ? pathOrFile : pathOrFile.path;
    return /\.(?:md)$/i.test(path);
  }
  dirname(path) {
    const parts = path.split("/");
    return (this.isMarkdown(parts[parts.length - 1]) ? parts.slice(0, -1) : parts).join("/");
  }
  async ensurePath(path) {
    const parts = this.dirname(path).split("/");
    const acc = [];
    for (const part of parts) {
      const folderPath = (0, import_obsidian5.normalizePath)([...acc, part].join("/"));
      if (!this.plugin.app.vault.getFolderByPath(folderPath)) {
        try {
          await this.plugin.app.vault.createFolder(folderPath);
        } catch (error) {
          this.log(`error creating intermediate folder "${folderPath}"`, error);
        }
      }
      acc.push(part);
    }
  }
  touchPreviousMountPath(mountPath) {
    let timeout = this.previousMountPathTouches.get(mountPath);
    window.clearTimeout(timeout);
    timeout = window.setTimeout(() => {
      this.log("forgetting previous mount path %s", mountPath);
      this.previousMountPaths = this.previousMountPaths.filter(
        (p) => p !== mountPath
      );
      this.previousMountPathTouches.delete(mountPath);
    }, MOUNT_RENAMES_BUFFER_MS);
    this.previousMountPathTouches.set(mountPath, timeout);
  }
};
__name(_CollectionHandler, "CollectionHandler");
var CollectionHandler = _CollectionHandler;

// src/services/collections/CollectionsService.ts
var import_debug3 = __toESM(require_browser2());
var import_obsidian6 = require("obsidian");
var TABLE2 = "id,team_id";
var SETTINGS_TABLE = "collection_id,mount_path";
var log2 = (0, import_debug3.default)("screen.garden:collections");
var _CollectionsService = class _CollectionsService extends Service {
  constructor(plugin) {
    super(plugin);
    this.collectionSettings = [];
    this.handlers = /* @__PURE__ */ new Map();
    this.collectionSize = new Subject();
    this.destroy = new Subject();
    this.collectionsSettingsObservable = liveQuery(
      () => this.db.collectionSettings.toArray()
    );
    this.availableCollectionsObservable = liveQuery(
      () => this.db.collections.toArray()
    );
    this.apiSubscription = this.plugin.api.observable.subscribe({
      next: /* @__PURE__ */ __name(async (api) => {
        if (api == null) return;
        this.getAndStoreCollections(api);
      }, "next")
    });
    this.collectionSettingsSubscription = this.collectionsSettingsObservable.subscribe({
      next: /* @__PURE__ */ __name(async (collectionSettings) => {
        const removed = Array.from(this.handlers.keys()).filter(
          (id) => !collectionSettings.some(
            ({ collection_id }) => collection_id === id
          )
        );
        for (const id of removed) {
          this.deleteHandler(id);
        }
        for (const { collection_id, mount_path } of collectionSettings.filter(
          ({ collection_id: collection_id2 }) => !this.handlers.get(collection_id2)
        )) {
          const collection = await this.db.collections.get(collection_id);
          if (!collection)
            return log2(
              "fatal error: could not find collection for mount point"
            );
          const handler = new CollectionHandler(
            this.plugin,
            collection_id,
            mount_path
          );
          this.setHandler(collection_id, handler);
        }
        this.collectionSettings = collectionSettings;
      }, "next")
    });
    this.collectionSizes = this.collectionSize.pipe(
      scan((acc, next) => ({ ...acc, ...next }), {}),
      takeUntil(this.destroy),
      shareReplay(1)
    );
  }
  async onunload() {
    for (const handler of this.handlers.values()) {
      this.deleteHandler(handler);
    }
    this.apiSubscription.unsubscribe();
    this.collectionSettingsSubscription.unsubscribe();
    this.destroy.next();
    this.destroy.complete();
  }
  async getAndStoreCollections(api) {
    const resp = await api.get("/collections");
    const { data: collections } = resp.data;
    log2("fetched available collections %o", collections);
    this.db.collections.bulkPut(collections);
  }
  setHandler(collectionId, handler) {
    this.handlers.set(collectionId, handler);
  }
  deleteHandler(idOrHandler) {
    const handler = idOrHandler instanceof CollectionHandler ? idOrHandler : this.handlers.get(idOrHandler);
    if (handler) {
      handler.close();
      this.handlers.delete(handler.id);
    } else if (typeof idOrHandler === "string") {
      this.handlers.delete(idOrHandler);
    }
  }
  async requireNoteHandlerForFile(file) {
    const collectionSettings = this.collectionSettings.find(
      ({ mount_path }) => pathContains(mount_path, file)
    );
    if (collectionSettings == null) {
      return null;
    }
    const handler = this.handlers.get(collectionSettings.collection_id);
    if (handler == null) {
      log2("no handler for file %s", file.path);
      return null;
    }
    return handler.requireNoteHandlerForFile(file);
  }
  /**
   * Gets a collection handler if it exists. Does not mount one if it does not exist.
   * Only call this in situations where you are sure the collection exists and is mounted,
   * e.g. within child NoteHandlers.
   */
  getHandler(collectionId) {
    var _a8;
    return (_a8 = this.handlers.get(collectionId)) != null ? _a8 : null;
  }
  async mount(collectionId, mountPath) {
    const collection = await this.db.collections.get(collectionId);
    if (!collection) return log2("no collection with id: %s", collectionId);
    const existingSettings = await this.db.collectionSettings.toArray();
    if (existingSettings.some(
      ({ mount_path: path }) => pathContains(path, mountPath) || pathContains(mountPath, path)
    )) {
      new import_obsidian6.Notice(intl.mountModal.noNestingNotice());
      return;
    }
    const collectionSettings = {
      collection_id: collectionId,
      mount_path: mountPath,
      last_sync: /* @__PURE__ */ new Date()
    };
    await this.db.collectionSettings.put(collectionSettings);
    const folder = this.plugin.app.vault.getFolderByPath(mountPath);
    if (!folder || folder.children.length === 0) {
      return;
    }
    const filesToAdd = [];
    import_obsidian6.Vault.recurseChildren(folder, (abstractFile) => {
      if (abstractFile instanceof import_obsidian6.TFile) {
        filesToAdd.push(abstractFile);
      }
    });
    let handler = this.handlers.get(collectionId);
    if (!handler || !handler.loaded) {
      const ref = await new Promise(
        (resolve) => this.on(collectionHandlerReadyEvent(collectionId), resolve)
      );
      this.offref(ref);
      handler = this.handlers.get(collectionId);
    }
    if (!handler) {
      log2(`unexpected undefined handler reported as ready: ${collectionId}`);
      return;
    }
    return handler.addNotes(filesToAdd);
  }
  async unmount(collectionId) {
    const noteKeys = await this.db.notes.where({
      collection_id: collectionId
    }).primaryKeys();
    await this.db.notes.bulkDelete(noteKeys);
    await Promise.all(noteKeys.map((k) => this.plugin.docs.delete(k)));
    await this.db.collectionSettings.delete(collectionId);
    await this.plugin.docs.delete(collectionId);
  }
  /**
   * Creates a collection and inserts it into LocalStorage.
   * Requires a valid API client and connection to the server;
   * attempts while offline will fail.
   * @param name
   * @param team
   */
  async create(name, team) {
    var _a8;
    const resp = await ((_a8 = this.plugin.api.client) == null ? void 0 : _a8.post(
      "/collections",
      {
        collection: {
          name
        },
        team_id: team.id
      }
    ));
    if (!resp) return null;
    const { data: collection } = resp.data;
    this.db.collections.put(collection);
    return collection;
  }
  collectionContaining(pathOrFile) {
    const p = getPath(pathOrFile);
    return this.collectionSettings.find((s) => pathContains(s.mount_path, p));
  }
  inMountedCollection(pathOrFile) {
    return this.collectionContaining(pathOrFile) !== void 0;
  }
  /**
   * A fast, potentially stale snapshot of collection settings.
   *
   * Use this for things that can tolerate delay but are updated frequently.
   */
  get fastCollectionSettings() {
    return this.collectionSettings;
  }
  async dataForFile(pathOrFile) {
    const cs = this.collectionContaining(pathOrFile);
    if (!cs) {
      return null;
    }
    const collection = await this.db.collections.get(cs.collection_id);
    if (!collection) {
      return null;
    }
    const team = await this.db.teams.get(collection.team_id);
    if (!team) {
      return null;
    }
    const path = getPath(pathOrFile);
    const note = await this.db.notes.where({ path }).first();
    if (!note) {
      return null;
    }
    return {
      team,
      collection,
      note
    };
  }
  presenceForCollection(id) {
    var _a8, _b;
    return (_b = (_a8 = this.handlers.get(id)) == null ? void 0 : _a8.presenceMetas()) != null ? _b : null;
  }
  reportSize(id, size) {
    this.collectionSize.next({ [id]: size });
  }
  addPathPrefixForCollection(id, path) {
    const collection = this.collectionSettings.find(
      (s) => s.collection_id === id
    );
    if (!collection) return null;
    return `${collection.mount_path}/${getPath(path)}`;
  }
};
__name(_CollectionsService, "CollectionsService");
var CollectionsService = _CollectionsService;

// src/services/docs/DocsService.ts
init_process_shim();

// src/services/docs/DocChannel.ts
init_process_shim();

// src/services/docs/UpdateController.ts
init_process_shim();

// node_modules/yjs/dist/yjs.mjs
init_process_shim();

// node_modules/lib0/observable.js
init_process_shim();

// node_modules/lib0/map.js
init_process_shim();
var create = /* @__PURE__ */ __name(() => /* @__PURE__ */ new Map(), "create");
var copy = /* @__PURE__ */ __name((m) => {
  const r = create();
  m.forEach((v, k) => {
    r.set(k, v);
  });
  return r;
}, "copy");
var setIfUndefined = /* @__PURE__ */ __name((map3, key, createT) => {
  let set = map3.get(key);
  if (set === void 0) {
    map3.set(key, set = createT());
  }
  return set;
}, "setIfUndefined");
var map2 = /* @__PURE__ */ __name((m, f) => {
  const res = [];
  for (const [key, value] of m) {
    res.push(f(value, key));
  }
  return res;
}, "map");
var any = /* @__PURE__ */ __name((m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true;
    }
  }
  return false;
}, "any");

// node_modules/lib0/set.js
init_process_shim();
var create2 = /* @__PURE__ */ __name(() => /* @__PURE__ */ new Set(), "create");

// node_modules/lib0/array.js
init_process_shim();
var last2 = /* @__PURE__ */ __name((arr) => arr[arr.length - 1], "last");
var appendTo = /* @__PURE__ */ __name((dest, src) => {
  for (let i = 0; i < src.length; i++) {
    dest.push(src[i]);
  }
}, "appendTo");
var from2 = Array.from;
var isArray4 = Array.isArray;

// node_modules/lib0/observable.js
var _Observable = class _Observable {
  constructor() {
    this._observers = create();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create2).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = /* @__PURE__ */ __name((...args2) => {
      this.off(name, _f);
      f(...args2);
    }, "_f");
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from2((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};
__name(_Observable, "Observable");
var Observable3 = _Observable;

// node_modules/lib0/math.js
init_process_shim();
var floor = Math.floor;
var abs = Math.abs;
var min = /* @__PURE__ */ __name((a, b) => a < b ? a : b, "min");
var max = /* @__PURE__ */ __name((a, b) => a > b ? a : b, "max");
var isNaN2 = Number.isNaN;
var isNegativeZero = /* @__PURE__ */ __name((n) => n !== 0 ? n < 0 : 1 / n < 0, "isNegativeZero");

// node_modules/lib0/encoding.js
init_process_shim();

// node_modules/lib0/buffer.js
init_process_shim();

// node_modules/lib0/string.js
init_process_shim();
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = /* @__PURE__ */ __name((s) => s.toLowerCase(), "toLowerCase");
var trimLeftRegex = /^\s*/g;
var trimLeft = /* @__PURE__ */ __name((s) => s.replace(trimLeftRegex, ""), "trimLeft");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = /* @__PURE__ */ __name((s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`)), "fromCamelCase");
var _encodeUtf8Polyfill = /* @__PURE__ */ __name((str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
}, "_encodeUtf8Polyfill");
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = /* @__PURE__ */ __name((str) => utf8TextEncoder.encode(str), "_encodeUtf8Native");
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// node_modules/lib0/environment.js
init_process_shim();

// node_modules/lib0/conditions.js
init_process_shim();
var undefinedToNull = /* @__PURE__ */ __name((v) => v === void 0 ? null : v, "undefinedToNull");

// node_modules/lib0/storage.js
init_process_shim();
var _VarStoragePolyfill = class _VarStoragePolyfill {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
__name(_VarStoragePolyfill, "VarStoragePolyfill");
var VarStoragePolyfill = _VarStoragePolyfill;
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined") {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
var varStorage = _localStorage;

// node_modules/lib0/function.js
init_process_shim();

// node_modules/lib0/object.js
init_process_shim();
var keys2 = Object.keys;
var length = /* @__PURE__ */ __name((obj) => keys2(obj).length, "length");
var every = /* @__PURE__ */ __name((obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
}, "every");
var hasProperty = /* @__PURE__ */ __name((obj, key) => Object.prototype.hasOwnProperty.call(obj, key), "hasProperty");
var equalFlat = /* @__PURE__ */ __name((a, b) => a === b || length(a) === length(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val), "equalFlat");

// node_modules/lib0/function.js
var callAll = /* @__PURE__ */ __name((fs, args2, i = 0) => {
  try {
    for (; i < fs.length; i++) {
      fs[i](...args2);
    }
  } finally {
    if (i < fs.length) {
      callAll(fs, args2, i + 1);
    }
  }
}, "callAll");
var isOneOf = /* @__PURE__ */ __name((value, options) => options.includes(value), "isOneOf");

// node_modules/lib0/environment.js
var isNode = typeof import_browser.default !== "undefined" && import_browser.default.release && /node|io\.js/.test(import_browser.default.release.name);
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = /* @__PURE__ */ __name(() => {
  if (params === void 0) {
    if (isNode) {
      params = create();
      const pargs = import_browser.default.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
}, "computeParams");
var hasParam = /* @__PURE__ */ __name((name) => computeParams().has(name), "hasParam");
var getVariable = /* @__PURE__ */ __name((name) => isNode ? undefinedToNull(import_browser.default.env[name.toUpperCase()]) : undefinedToNull(varStorage.getItem(name)), "getVariable");
var hasConf = /* @__PURE__ */ __name((name) => hasParam("--" + name) || getVariable(name) !== null, "hasConf");
var production = hasConf("production");
var forceColor = isNode && isOneOf(import_browser.default.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("no-colors") && (!isNode || import_browser.default.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/decoding.js
init_process_shim();

// node_modules/lib0/binary.js
init_process_shim();
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
init_process_shim();
var MAX_SAFE_INTEGER3 = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/error.js
init_process_shim();
var create3 = /* @__PURE__ */ __name((s) => new Error(s), "create");
var methodUnimplemented = /* @__PURE__ */ __name(() => {
  throw create3("Method unimplemented");
}, "methodUnimplemented");
var unexpectedCase = /* @__PURE__ */ __name(() => {
  throw create3("Unexpected case");
}, "unexpectedCase");

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var _Decoder = class _Decoder {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
__name(_Decoder, "Decoder");
var Decoder = _Decoder;
var createDecoder = /* @__PURE__ */ __name((uint8Array) => new Decoder(uint8Array), "createDecoder");
var hasContent = /* @__PURE__ */ __name((decoder) => decoder.pos !== decoder.arr.length, "hasContent");
var readUint8Array = /* @__PURE__ */ __name((decoder, len) => {
  const view = createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
}, "readUint8Array");
var readVarUint8Array = /* @__PURE__ */ __name((decoder) => readUint8Array(decoder, readVarUint(decoder)), "readVarUint8Array");
var readUint8 = /* @__PURE__ */ __name((decoder) => decoder.arr[decoder.pos++], "readUint8");
var readVarUint = /* @__PURE__ */ __name((decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER3) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
}, "readVarUint");
var readVarInt = /* @__PURE__ */ __name((decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER3) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
}, "readVarInt");
var _readVarStringPolyfill = /* @__PURE__ */ __name((decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
}, "_readVarStringPolyfill");
var _readVarStringNative = /* @__PURE__ */ __name((decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
), "_readVarStringNative");
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = /* @__PURE__ */ __name((decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
}, "readFromDataView");
var readFloat32 = /* @__PURE__ */ __name((decoder) => readFromDataView(decoder, 4).getFloat32(0, false), "readFloat32");
var readFloat64 = /* @__PURE__ */ __name((decoder) => readFromDataView(decoder, 8).getFloat64(0, false), "readFloat64");
var readBigInt64 = /* @__PURE__ */ __name((decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
), "readBigInt64");
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i = 0; i < len; i++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i = 0; i < len; i++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = /* @__PURE__ */ __name((decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder), "readAny");
var _RleDecoder = class _RleDecoder extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
__name(_RleDecoder, "RleDecoder");
var RleDecoder = _RleDecoder;
var _UintOptRleDecoder = class _UintOptRleDecoder extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
__name(_UintOptRleDecoder, "UintOptRleDecoder");
var UintOptRleDecoder = _UintOptRleDecoder;
var _IntDiffOptRleDecoder = class _IntDiffOptRleDecoder extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
__name(_IntDiffOptRleDecoder, "IntDiffOptRleDecoder");
var IntDiffOptRleDecoder = _IntDiffOptRleDecoder;
var _StringDecoder = class _StringDecoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};
__name(_StringDecoder, "StringDecoder");
var StringDecoder = _StringDecoder;

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = /* @__PURE__ */ __name((len) => new Uint8Array(len), "createUint8ArrayFromLen");
var createUint8ArrayViewFromArrayBuffer = /* @__PURE__ */ __name((buffer, byteOffset, length3) => new Uint8Array(buffer, byteOffset, length3), "createUint8ArrayViewFromArrayBuffer");
var copyUint8Array = /* @__PURE__ */ __name((uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
}, "copyUint8Array");

// node_modules/lib0/encoding.js
var _Encoder = class _Encoder {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
__name(_Encoder, "Encoder");
var Encoder = _Encoder;
var createEncoder = /* @__PURE__ */ __name(() => new Encoder(), "createEncoder");
var length2 = /* @__PURE__ */ __name((encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
}, "length");
var toUint8Array = /* @__PURE__ */ __name((encoder) => {
  const uint8arr = new Uint8Array(length2(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d2 = encoder.bufs[i];
    uint8arr.set(d2, curPos);
    curPos += d2.length;
  }
  uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
}, "toUint8Array");
var verifyLen = /* @__PURE__ */ __name((encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
}, "verifyLen");
var write = /* @__PURE__ */ __name((encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
}, "write");
var writeUint8 = write;
var writeVarUint = /* @__PURE__ */ __name((encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
}, "writeVarUint");
var writeVarInt = /* @__PURE__ */ __name((encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
}, "writeVarInt");
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = /* @__PURE__ */ __name((encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
}, "_writeVarStringNative");
var _writeVarStringPolyfill = /* @__PURE__ */ __name((encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
}, "_writeVarStringPolyfill");
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = /* @__PURE__ */ __name((encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
}, "writeUint8Array");
var writeVarUint8Array = /* @__PURE__ */ __name((encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
}, "writeVarUint8Array");
var writeOnDataView = /* @__PURE__ */ __name((encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
}, "writeOnDataView");
var writeFloat32 = /* @__PURE__ */ __name((encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false), "writeFloat32");
var writeFloat64 = /* @__PURE__ */ __name((encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false), "writeFloat64");
var writeBigInt64 = /* @__PURE__ */ __name((encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
), "writeBigInt64");
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = /* @__PURE__ */ __name((num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
}, "isFloat32");
var writeAny = /* @__PURE__ */ __name((encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray4(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i = 0; i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys3 = Object.keys(data);
        writeVarUint(encoder, keys3.length);
        for (let i = 0; i < keys3.length; i++) {
          const key = keys3[i];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
}, "writeAny");
var _RleEncoder = class _RleEncoder extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v);
      this.s = v;
    }
  }
};
__name(_RleEncoder, "RleEncoder");
var RleEncoder = _RleEncoder;
var flushUintOptRleEncoder = /* @__PURE__ */ __name((encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
}, "flushUintOptRleEncoder");
var _UintOptRleEncoder = class _UintOptRleEncoder {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v;
    }
  }
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
__name(_UintOptRleEncoder, "UintOptRleEncoder");
var UintOptRleEncoder = _UintOptRleEncoder;
var flushIntDiffOptRleEncoder = /* @__PURE__ */ __name((encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
}, "flushIntDiffOptRleEncoder");
var _IntDiffOptRleEncoder = class _IntDiffOptRleEncoder {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.diff === v - this.s) {
      this.s = v;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v - this.s;
      this.s = v;
    }
  }
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
__name(_IntDiffOptRleEncoder, "IntDiffOptRleEncoder");
var IntDiffOptRleEncoder = _IntDiffOptRleEncoder;
var _StringEncoder = class _StringEncoder {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};
__name(_StringEncoder, "StringEncoder");
var StringEncoder = _StringEncoder;

// node_modules/lib0/random.js
init_process_shim();

// node_modules/lib0/webcrypto.js
init_process_shim();
var subtle = crypto.subtle;
var getRandomValues2 = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var uint32 = /* @__PURE__ */ __name(() => getRandomValues2(new Uint32Array(1))[0], "uint32");
var uuidv4Template = "10000000-1000-4000-8000" + -1e11;
var uuidv4 = /* @__PURE__ */ __name(() => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
), "uuidv4");

// node_modules/lib0/promise.js
init_process_shim();

// node_modules/lib0/time.js
init_process_shim();
var getUnixTime = Date.now;

// node_modules/lib0/promise.js
var create4 = /* @__PURE__ */ __name((f) => (
  /** @type {Promise<T>} */
  new Promise(f)
), "create");
var all = Promise.all.bind(Promise);

// node_modules/lib0/logging.js
init_process_shim();

// node_modules/lib0/pair.js
init_process_shim();
var _Pair = class _Pair {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
__name(_Pair, "Pair");
var Pair = _Pair;
var create5 = /* @__PURE__ */ __name((left, right) => new Pair(left, right), "create");
var forEach = /* @__PURE__ */ __name((arr, f) => arr.forEach((p) => f(p.left, p.right)), "forEach");

// node_modules/lib0/dom.js
init_process_shim();
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var createElement = /* @__PURE__ */ __name((name) => doc.createElement(name), "createElement");
var createDocumentFragment = /* @__PURE__ */ __name(() => doc.createDocumentFragment(), "createDocumentFragment");
var createTextNode = /* @__PURE__ */ __name((text2) => doc.createTextNode(text2), "createTextNode");
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var setAttributes = /* @__PURE__ */ __name((el, attrs) => {
  forEach(attrs, (key, value) => {
    if (value === false) {
      el.removeAttribute(key);
    } else if (value === true) {
      el.setAttribute(key, "");
    } else {
      el.setAttribute(key, value);
    }
  });
  return el;
}, "setAttributes");
var fragment = /* @__PURE__ */ __name((children) => {
  const fragment2 = createDocumentFragment();
  for (let i = 0; i < children.length; i++) {
    appendChild(fragment2, children[i]);
  }
  return fragment2;
}, "fragment");
var append = /* @__PURE__ */ __name((parent, nodes) => {
  appendChild(parent, fragment(nodes));
  return parent;
}, "append");
var element = /* @__PURE__ */ __name((name, attrs = [], children = []) => append(setAttributes(createElement(name), attrs), children), "element");
var text = createTextNode;
var mapToStyleString = /* @__PURE__ */ __name((m) => map2(m, (value, key) => `${key}:${value};`).join(""), "mapToStyleString");
var appendChild = /* @__PURE__ */ __name((parent, child) => parent.appendChild(child), "appendChild");
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/logging.common.js
init_process_shim();

// node_modules/lib0/symbol.js
init_process_shim();
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = /* @__PURE__ */ __name((args2) => {
  const strBuilder = [];
  const logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
}, "computeNoColorLoggingArgs");
var lastLoggingTime = getUnixTime();

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = /* @__PURE__ */ __name((args2) => {
  const strBuilder = [];
  const styles = [];
  const currentStyle = create();
  let logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
}, "computeBrowserLoggingArgs");
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = /* @__PURE__ */ __name((...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
}, "print");
var vconsoles = create2();

// node_modules/lib0/iterator.js
init_process_shim();
var createIterator = /* @__PURE__ */ __name((next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
}), "createIterator");
var iteratorFilter = /* @__PURE__ */ __name((iterator2, filter2) => createIterator(() => {
  let res;
  do {
    res = iterator2.next();
  } while (!res.done && !filter2(res.value));
  return res;
}), "iteratorFilter");
var iteratorMap = /* @__PURE__ */ __name((iterator2, fmap) => createIterator(() => {
  const { done, value } = iterator2.next();
  return { done, value: done ? void 0 : fmap(value) };
}), "iteratorMap");

// node_modules/yjs/dist/yjs.mjs
var _DeleteItem = class _DeleteItem {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
__name(_DeleteItem, "DeleteItem");
var DeleteItem = _DeleteItem;
var _DeleteSet = class _DeleteSet {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
__name(_DeleteSet, "DeleteSet");
var DeleteSet = _DeleteSet;
var iterateDeletedStructs = /* @__PURE__ */ __name((transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i = 0; i < deletes.length; i++) {
    const del2 = deletes[i];
    iterateStructs(transaction, structs, del2.clock, del2.len, f);
  }
}), "iterateDeletedStructs");
var findIndexDS = /* @__PURE__ */ __name((dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
}, "findIndexDS");
var isDeleted = /* @__PURE__ */ __name((ds, id) => {
  const dis = ds.clients.get(id.client);
  return dis !== void 0 && findIndexDS(dis, id.clock) !== null;
}, "isDeleted");
var sortAndMergeDeleteSet = /* @__PURE__ */ __name((ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a, b) => a.clock - b.clock);
    let i, j;
    for (i = 1, j = 1; i < dels.length; i++) {
      const left = dels[j - 1];
      const right = dels[i];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
}, "sortAndMergeDeleteSet");
var mergeDeleteSets = /* @__PURE__ */ __name((dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i = dssI + 1; i < dss.length; i++) {
          appendTo(dels, dss[i].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
}, "mergeDeleteSets");
var addToDeleteSet = /* @__PURE__ */ __name((ds, client, clock, length3) => {
  setIfUndefined(ds.clients, client, () => []).push(new DeleteItem(clock, length3));
}, "addToDeleteSet");
var createDeleteSet = /* @__PURE__ */ __name(() => new DeleteSet(), "createDeleteSet");
var createDeleteSetFromStructStore = /* @__PURE__ */ __name((ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i = 0; i < structs.length; i++) {
      const struct = structs[i];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i + 1 < structs.length) {
          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
}, "createDeleteSetFromStructStore");
var writeDeleteSet = /* @__PURE__ */ __name((encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from2(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i = 0; i < len; i++) {
      const item = dsitems[i];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
}, "writeDeleteSet");
var readDeleteSet = /* @__PURE__ */ __name((decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => []);
      for (let i2 = 0; i2 < numberOfDeletes; i2++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
}, "readDeleteSet");
var readAndApplyDeleteSet = /* @__PURE__ */ __name((decoder, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i2 = 0; i2 < numberOfDeletes; i2++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
}, "readAndApplyDeleteSet");
var generateNewClientId = uint32;
var _Doc = class _Doc extends Observable3 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = /* @__PURE__ */ __name(() => true, "gcFilter"), meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create4((resolve) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve(this);
      });
    });
    const provideSyncedPromise = /* @__PURE__ */ __name(() => create4((resolve) => {
      const eventHandler = /* @__PURE__ */ __name((isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve();
        }
      }, "eventHandler");
      this.on("sync", eventHandler);
    }), "provideSyncedPromise");
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (!this.isLoaded) {
        this.emit("load", []);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from2(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @param {function(Transaction):void} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   *
   * @public
   */
  transact(f, origin2 = null) {
    transact(this, f, origin2);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = AbstractType) {
    const type = setIfUndefined(this.share, name, () => {
      const t = new TypeConstructor();
      t._integrate(this, null);
      return t;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t = new TypeConstructor();
        t._map = type._map;
        type._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t;
            }
          }
        );
        t._start = type._start;
        for (let n = t._start; n !== null; n = n.right) {
          n.parent = t;
        }
        t._length = type._length;
        this.share.set(name, t);
        t._integrate(this, null);
        return t;
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return type;
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return this.get(name, YArray);
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return this.get(name, YMap);
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    from2(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new _Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
  /**
   * @param {string} eventName
   * @param {function(...any):any} f
   */
  on(eventName, f) {
    super.on(eventName, f);
  }
  /**
   * @param {string} eventName
   * @param {function} f
   */
  off(eventName, f) {
    super.off(eventName, f);
  }
};
__name(_Doc, "Doc");
var Doc = _Doc;
var _DSDecoderV1 = class _DSDecoderV1 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
__name(_DSDecoderV1, "DSDecoderV1");
var DSDecoderV1 = _DSDecoderV1;
var _UpdateDecoderV1 = class _UpdateDecoderV1 extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
__name(_UpdateDecoderV1, "UpdateDecoderV1");
var UpdateDecoderV1 = _UpdateDecoderV1;
var _DSDecoderV2 = class _DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
__name(_DSDecoderV2, "DSDecoderV2");
var DSDecoderV2 = _DSDecoderV2;
var _UpdateDecoderV2 = class _UpdateDecoderV2 extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
__name(_UpdateDecoderV2, "UpdateDecoderV2");
var UpdateDecoderV2 = _UpdateDecoderV2;
var _DSEncoderV1 = class _DSEncoderV1 {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
__name(_DSEncoderV1, "DSEncoderV1");
var DSEncoderV1 = _DSEncoderV1;
var _UpdateEncoderV1 = class _UpdateEncoderV1 extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id) {
    writeVarUint(this.restEncoder, id.client);
    writeVarUint(this.restEncoder, id.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id) {
    writeVarUint(this.restEncoder, id.client);
    writeVarUint(this.restEncoder, id.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    writeVarString(this.restEncoder, s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
__name(_UpdateEncoderV1, "UpdateEncoderV1");
var UpdateEncoderV1 = _UpdateEncoderV1;
var _DSEncoderV2 = class _DSEncoderV2 {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
__name(_DSEncoderV2, "DSEncoderV2");
var DSEncoderV2 = _DSEncoderV2;
var _UpdateEncoderV2 = class _UpdateEncoderV2 extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id) {
    this.clientEncoder.write(id.client);
    this.leftClockEncoder.write(id.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id) {
    this.clientEncoder.write(id.client);
    this.rightClockEncoder.write(id.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    this.stringEncoder.write(s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
__name(_UpdateEncoderV2, "UpdateEncoderV2");
var UpdateEncoderV2 = _UpdateEncoderV2;
var writeStructs = /* @__PURE__ */ __name((encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i = startNewStructs + 1; i < structs.length; i++) {
    structs[i].write(encoder, 0);
  }
}, "writeStructs");
var writeClientsStructs = /* @__PURE__ */ __name((encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from2(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeStructs(encoder, store.clients.get(client), client, clock);
  });
}, "writeClientsStructs");
var readClientsStructRefs = /* @__PURE__ */ __name((decoder, doc2) => {
  const clientRefs = create();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i2] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i2] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // leftd
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i2] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
}, "readClientsStructRefs");
var integrateStructs = /* @__PURE__ */ __name((transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a, b) => a - b);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = /* @__PURE__ */ __name(() => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  }, "getNextStructTarget");
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null && stack.length === 0) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = /* @__PURE__ */ __name((client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  }, "updateMissingSv");
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = /* @__PURE__ */ __name(() => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
    }
    stack.length = 0;
  }, "addStackToRestSS");
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
}, "integrateStructs");
var writeStructsFromTransaction = /* @__PURE__ */ __name((encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState), "writeStructsFromTransaction");
var readUpdateV2 = /* @__PURE__ */ __name((decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false), "readUpdateV2");
var applyUpdateV2 = /* @__PURE__ */ __name((ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
}, "applyUpdateV2");
var applyUpdate = /* @__PURE__ */ __name((ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1), "applyUpdate");
var writeStateAsUpdate = /* @__PURE__ */ __name((encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
}, "writeStateAsUpdate");
var encodeStateAsUpdateV2 = /* @__PURE__ */ __name((doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
}, "encodeStateAsUpdateV2");
var encodeStateAsUpdate = /* @__PURE__ */ __name((doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1()), "encodeStateAsUpdate");
var readStateVector = /* @__PURE__ */ __name((decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i = 0; i < ssLength; i++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
}, "readStateVector");
var decodeStateVector = /* @__PURE__ */ __name((decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState))), "decodeStateVector");
var writeStateVector = /* @__PURE__ */ __name((encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from2(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
}, "writeStateVector");
var writeDocumentStateVector = /* @__PURE__ */ __name((encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store)), "writeDocumentStateVector");
var encodeStateVectorV2 = /* @__PURE__ */ __name((doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
}, "encodeStateVectorV2");
var encodeStateVector = /* @__PURE__ */ __name((doc2) => encodeStateVectorV2(doc2, new DSEncoderV1()), "encodeStateVector");
var _EventHandler = class _EventHandler {
  constructor() {
    this.l = [];
  }
};
__name(_EventHandler, "EventHandler");
var EventHandler = _EventHandler;
var createEventHandler = /* @__PURE__ */ __name(() => new EventHandler(), "createEventHandler");
var addEventHandlerListener = /* @__PURE__ */ __name((eventHandler, f) => eventHandler.l.push(f), "addEventHandlerListener");
var removeEventHandlerListener = /* @__PURE__ */ __name((eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
}, "removeEventHandlerListener");
var callEventHandlerListeners = /* @__PURE__ */ __name((eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]), "callEventHandlerListeners");
var _ID = class _ID {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
__name(_ID, "ID");
var ID = _ID;
var compareIDs = /* @__PURE__ */ __name((a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock, "compareIDs");
var createID = /* @__PURE__ */ __name((client, clock) => new ID(client, clock), "createID");
var findRootTypeKey = /* @__PURE__ */ __name((type) => {
  for (const [key, value] of type.doc.share.entries()) {
    if (value === type) {
      return key;
    }
  }
  throw unexpectedCase();
}, "findRootTypeKey");
var _RelativePosition = class _RelativePosition {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type, tname, item, assoc = 0) {
    this.type = type;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
__name(_RelativePosition, "RelativePosition");
var RelativePosition = _RelativePosition;
var _AbsolutePosition = class _AbsolutePosition {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type, index, assoc = 0) {
    this.type = type;
    this.index = index;
    this.assoc = assoc;
  }
};
__name(_AbsolutePosition, "AbsolutePosition");
var AbsolutePosition = _AbsolutePosition;
var createAbsolutePosition = /* @__PURE__ */ __name((type, index, assoc = 0) => new AbsolutePosition(type, index, assoc), "createAbsolutePosition");
var createRelativePosition = /* @__PURE__ */ __name((type, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
}, "createRelativePosition");
var createRelativePositionFromTypeIndex = /* @__PURE__ */ __name((type, index, assoc = 0) => {
  let t = type._start;
  if (assoc < 0) {
    if (index === 0) {
      return createRelativePosition(type, null, assoc);
    }
    index--;
  }
  while (t !== null) {
    if (!t.deleted && t.countable) {
      if (t.length > index) {
        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);
      }
      index -= t.length;
    }
    if (t.right === null && assoc < 0) {
      return createRelativePosition(type, t.lastId, assoc);
    }
    t = t.right;
  }
  return createRelativePosition(type, null, assoc);
}, "createRelativePositionFromTypeIndex");
var createAbsolutePositionFromRelativePosition = /* @__PURE__ */ __name((rpos, doc2) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type = null;
  let index = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followRedone(store, rightID);
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type = /** @type {AbstractType<any>} */
    right.parent;
    if (type._item === null || !type._item.deleted) {
      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n = right.left;
      while (n !== null) {
        if (!n.deleted && n.countable) {
          index += n.length;
        }
        n = n.left;
      }
    }
  } else {
    if (tname !== null) {
      type = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followRedone(store, typeID);
      if (item instanceof Item && item.content instanceof ContentType) {
        type = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index = type._length;
    } else {
      index = 0;
    }
  }
  return createAbsolutePosition(type, index, rpos.assoc);
}, "createAbsolutePositionFromRelativePosition");
var compareRelativePositions = /* @__PURE__ */ __name((a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc, "compareRelativePositions");
var _Snapshot = class _Snapshot {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
__name(_Snapshot, "Snapshot");
var Snapshot = _Snapshot;
var createSnapshot = /* @__PURE__ */ __name((ds, sm) => new Snapshot(ds, sm), "createSnapshot");
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = /* @__PURE__ */ __name((item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id), "isVisible");
var splitSnapshotAffectedStructs = /* @__PURE__ */ __name((transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
  const store = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (item) => {
    });
    meta.add(snapshot);
  }
}, "splitSnapshotAffectedStructs");
var _StructStore = class _StructStore {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
__name(_StructStore, "StructStore");
var StructStore = _StructStore;
var getStateVector = /* @__PURE__ */ __name((store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
}, "getStateVector");
var getState = /* @__PURE__ */ __name((store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
}, "getState");
var addStruct = /* @__PURE__ */ __name((store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
}, "addStruct");
var findIndexSS = /* @__PURE__ */ __name((structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
}, "findIndexSS");
var find = /* @__PURE__ */ __name((store, id) => {
  const structs = store.clients.get(id.client);
  return structs[findIndexSS(structs, id.clock)];
}, "find");
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = /* @__PURE__ */ __name((transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
}, "findIndexCleanStart");
var getItemCleanStart = /* @__PURE__ */ __name((transaction, id) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id.clock)];
}, "getItemCleanStart");
var getItemCleanEnd = /* @__PURE__ */ __name((transaction, store, id) => {
  const structs = store.clients.get(id.client);
  const index = findIndexSS(structs, id.clock);
  const struct = structs[index];
  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));
  }
  return struct;
}, "getItemCleanEnd");
var replaceStruct = /* @__PURE__ */ __name((store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
}, "replaceStruct");
var iterateStructs = /* @__PURE__ */ __name((transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
}, "iterateStructs");
var _Transaction = class _Transaction {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin2, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin2;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
  }
};
__name(_Transaction, "Transaction");
var Transaction = _Transaction;
var writeUpdateMessageFromTransaction = /* @__PURE__ */ __name((encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
}, "writeUpdateMessageFromTransaction");
var addChangedTypeToTransaction = /* @__PURE__ */ __name((transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create2).add(parentSub);
  }
}, "addChangedTypeToTransaction");
var tryToMergeWithLeft = /* @__PURE__ */ __name((structs, pos) => {
  const left = structs[pos - 1];
  const right = structs[pos];
  if (left.deleted === right.deleted && left.constructor === right.constructor) {
    if (left.mergeWith(right)) {
      structs.splice(pos, 1);
      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
      right.parent._map.get(right.parentSub) === right) {
        right.parent._map.set(
          right.parentSub,
          /** @type {Item} */
          left
        );
      }
    }
  }
}, "tryToMergeWithLeft");
var tryGcDeleteSet = /* @__PURE__ */ __name((ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
}, "tryGcDeleteSet");
var tryMergeDeleteSet = /* @__PURE__ */ __name((ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[--si]) {
        tryToMergeWithLeft(structs, si);
      }
    }
  });
}, "tryMergeDeleteSet");
var cleanupTransactions = /* @__PURE__ */ __name((transactionCleanups, i) => {
  if (i < transactionCleanups.length) {
    const transaction = transactionCleanups[i];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach(
          (events, type) => fs.push(() => {
            if (type._item === null || !type._item.deleted) {
              events = events.filter(
                (event) => event.target._item === null || !event.target._item.deleted
              );
              events.forEach((event) => {
                event.currentTarget = type;
              });
              events.sort((event1, event2) => event1.path.length - event2.path.length);
              callEventHandlerListeners(type._dEH, events, transaction);
            }
          })
        );
        fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      });
      callAll(fs, []);
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i2 = structs.length - 1; i2 >= firstChangePos; i2--) {
            tryToMergeWithLeft(structs, i2);
          }
        }
      });
      for (let i2 = 0; i2 < mergeStructs.length; i2++) {
        const { client, clock } = mergeStructs[i2].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          tryToMergeWithLeft(structs, replacedStructPos + 1);
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLeft(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i + 1);
      }
    }
  }
}, "cleanupTransactions");
var transact = /* @__PURE__ */ __name((doc2, f, origin2 = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin2, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
}, "transact");
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
__name(lazyStructReaderGenerator, "lazyStructReaderGenerator");
var _LazyStructReader = class _LazyStructReader {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
__name(_LazyStructReader, "LazyStructReader");
var LazyStructReader = _LazyStructReader;
var _LazyStructWriter = class _LazyStructWriter {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
__name(_LazyStructWriter, "LazyStructWriter");
var LazyStructWriter = _LazyStructWriter;
var mergeUpdates = /* @__PURE__ */ __name((updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1), "mergeUpdates");
var sliceStruct = /* @__PURE__ */ __name((left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
}, "sliceStruct");
var mergeUpdatesV2 = /* @__PURE__ */ __name((updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
}, "mergeUpdatesV2");
var diffUpdateV2 = /* @__PURE__ */ __name((update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
}, "diffUpdateV2");
var flushLazyStructWriter = /* @__PURE__ */ __name((lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
}, "flushLazyStructWriter");
var writeStructToLazyStructWriter = /* @__PURE__ */ __name((lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
}, "writeStructToLazyStructWriter");
var finishLazyStructWriting = /* @__PURE__ */ __name((lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {
    const partStructs = lazyWriter.clientStructs[i];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
}, "finishLazyStructWriting");
var convertUpdateFormat = /* @__PURE__ */ __name((update, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, curr, 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
}, "convertUpdateFormat");
var convertUpdateFormatV2ToV1 = /* @__PURE__ */ __name((update) => convertUpdateFormat(update, UpdateDecoderV2, UpdateEncoderV1), "convertUpdateFormatV2ToV1");
var _YEvent = class _YEvent {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return getPathTo(this.currentTarget, this.target);
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      const keys3 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last2(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last2(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last2(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys3.set(key, { action, oldValue });
        }
      });
      this._keys = keys3;
    }
    return this._keys;
  }
  /**
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      const target = this.target;
      const added = create2();
      const deleted = create2();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = /* @__PURE__ */ __name(() => {
          if (lastOp) {
            delta.push(lastOp);
          }
        }, "packOp");
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
__name(_YEvent, "YEvent");
var YEvent = _YEvent;
var getPathTo = /* @__PURE__ */ __name((parent, child) => {
  const path = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path.unshift(child._item.parentSub);
    } else {
      let i = 0;
      let c = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c !== child._item && c !== null) {
        if (!c.deleted) {
          i++;
        }
        c = c.right;
      }
      path.unshift(i);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path;
}, "getPathTo");
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var _ArraySearchMarker = class _ArraySearchMarker {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
__name(_ArraySearchMarker, "ArraySearchMarker");
var ArraySearchMarker = _ArraySearchMarker;
var refreshMarkerTimestamp = /* @__PURE__ */ __name((marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
}, "refreshMarkerTimestamp");
var overwriteMarker = /* @__PURE__ */ __name((marker, p, index) => {
  marker.p.marker = false;
  marker.p = p;
  p.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
}, "overwriteMarker");
var markPosition = /* @__PURE__ */ __name((searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
    overwriteMarker(marker, p, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
}, "markPosition");
var findMarker = /* @__PURE__ */ __name((yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);
  let p = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
}, "findMarker");
var updateMarkerChanges = /* @__PURE__ */ __name((searchMarker, index, len) => {
  for (let i = searchMarker.length - 1; i >= 0; i--) {
    const m = searchMarker[i];
    if (len > 0) {
      let p = m.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i, 1);
        continue;
      }
      m.p = p;
      p.marker = true;
    }
    if (index < m.index || len > 0 && index === m.index) {
      m.index = max(index, m.index + len);
    }
  }
}, "updateMarkerChanges");
var callTypeObservers = /* @__PURE__ */ __name((type, transaction, event) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = /** @type {AbstractType<any>} */
    type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
}, "callTypeObservers");
var _AbstractType = class _AbstractType {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
__name(_AbstractType, "AbstractType");
var AbstractType = _AbstractType;
var typeListSlice = /* @__PURE__ */ __name((type, start, end) => {
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i = start; i < c.length && len > 0; i++) {
          cs.push(c[i]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
}, "typeListSlice");
var typeListToArray = /* @__PURE__ */ __name((type) => {
  const cs = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        cs.push(c[i]);
      }
    }
    n = n.right;
  }
  return cs;
}, "typeListToArray");
var typeListForEach = /* @__PURE__ */ __name((type, f) => {
  let index = 0;
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        f(c[i], index++, type);
      }
    }
    n = n.right;
  }
}, "typeListForEach");
var typeListMap = /* @__PURE__ */ __name((type, f) => {
  const result = [];
  typeListForEach(type, (c, i) => {
    result.push(f(c, i, type));
  });
  return result;
}, "typeListMap");
var typeListCreateIterator = /* @__PURE__ */ __name((type) => {
  let n = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: /* @__PURE__ */ __name(() => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }, "next")
  };
}, "typeListCreateIterator");
var typeListGet = /* @__PURE__ */ __name((type, index) => {
  const marker = findMarker(type, index);
  let n = type._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
}, "typeListGet");
var typeListInsertGenericsAfter = /* @__PURE__ */ __name((transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = /* @__PURE__ */ __name(() => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  }, "packJsonContent");
  content.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
}, "typeListInsertGenericsAfter");
var lengthExceeded = create3("Length exceeded!");
var typeListInsertGenerics = /* @__PURE__ */ __name((transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded;
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
}, "typeListInsertGenerics");
var typeListPushGenerics = /* @__PURE__ */ __name((transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
}, "typeListPushGenerics");
var typeListDelete = /* @__PURE__ */ __name((transaction, parent, index, length3) => {
  if (length3 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length3;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length3 > 0 && n !== null) {
    if (!n.deleted) {
      if (length3 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length3));
      }
      n.delete(transaction);
      length3 -= n.length;
    }
    n = n.right;
  }
  if (length3 > 0) {
    throw lengthExceeded;
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length3
      /* in case we remove the above exception */
    );
  }
}, "typeListDelete");
var typeMapDelete = /* @__PURE__ */ __name((transaction, parent, key) => {
  const c = parent._map.get(key);
  if (c !== void 0) {
    c.delete(transaction);
  }
}, "typeMapDelete");
var typeMapSet = /* @__PURE__ */ __name((transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
}, "typeMapSet");
var typeMapGet = /* @__PURE__ */ __name((parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
}, "typeMapGet");
var typeMapGetAll = /* @__PURE__ */ __name((parent) => {
  const res = {};
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
}, "typeMapGetAll");
var typeMapHas = /* @__PURE__ */ __name((parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
}, "typeMapHas");
var createMapIterator = /* @__PURE__ */ __name((map3) => iteratorFilter(
  map3.entries(),
  /** @param {any} entry */
  (entry) => !entry[1].deleted
), "createMapIterator");
var _YArrayEvent = class _YArrayEvent extends YEvent {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(yarray, transaction) {
    super(yarray, transaction);
    this._transaction = transaction;
  }
};
__name(_YArrayEvent, "YArrayEvent");
var YArrayEvent = _YArrayEvent;
var _YArray = class _YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a = new _YArray();
    a.push(items);
    return a;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _YArray();
  }
  /**
   * @return {YArray<T>}
   */
  clone() {
    const arr = new _YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length3);
      });
    } else {
      this._prelimContent.splice(index, length3);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f) {
    return typeListMap(
      this,
      /** @type {any} */
      f
    );
  }
  /**
   * Executes a provided function on once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
__name(_YArray, "YArray");
var YArray = _YArray;
var readYArray = /* @__PURE__ */ __name((_decoder) => new YArray(), "readYArray");
var _YMapEvent = class _YMapEvent extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
__name(_YMapEvent, "YMapEvent");
var YMapEvent = _YMapEvent;
var _YMap = class _YMap extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new _YMap();
  }
  /**
   * @return {YMap<MapType>}
   */
  clone() {
    const map3 = new _YMap();
    this.forEach((value, key) => {
      map3.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map3;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const map3 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v = item.content.getContent()[item.length - 1];
        map3[key] = v instanceof AbstractType ? v.toJSON() : v;
      }
    });
    return map3;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<any>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[1].content.getContent()[v[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<any>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => [v[0], v[1].content.getContent()[v[1].length - 1]]
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<any>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {MapType} value The value of the element to add
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map3) {
          typeMapDelete(transaction, map3, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
__name(_YMap, "YMap");
var YMap = _YMap;
var readYMap = /* @__PURE__ */ __name((_decoder) => new YMap(), "readYMap");
var equalAttrs = /* @__PURE__ */ __name((a, b) => a === b || typeof a === "object" && typeof b === "object" && a && b && equalFlat(a, b), "equalAttrs");
var _ItemTextListPosition = class _ItemTextListPosition {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
__name(_ItemTextListPosition, "ItemTextListPosition");
var ItemTextListPosition = _ItemTextListPosition;
var findNextPosition = /* @__PURE__ */ __name((transaction, pos, count2) => {
  while (pos.right !== null && count2 > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count2 < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
          }
          pos.index += pos.right.length;
          count2 -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
}, "findNextPosition");
var findPosition = /* @__PURE__ */ __name((transaction, parent, index) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = findMarker(parent, index);
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
}, "findPosition");
var insertNegatedAttributes = /* @__PURE__ */ __name((transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
}, "insertNegatedAttributes");
var updateCurrentAttributes = /* @__PURE__ */ __name((currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
}, "updateCurrentAttributes");
var minimizeAttributeChanges = /* @__PURE__ */ __name((currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ] || null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    )) ;
    else {
      break;
    }
    currPos.forward();
  }
}, "minimizeAttributeChanges");
var insertAttributes = /* @__PURE__ */ __name((transaction, parent, currPos, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = currPos.currentAttributes.get(key) || null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
}, "insertAttributes");
var insertText = /* @__PURE__ */ __name((transaction, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(
    /** @type {string} */
    text2
  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
}, "insertText");
var formatText = /* @__PURE__ */ __name((transaction, parent, currPos, length3, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop: while (currPos.right !== null && (length3 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
    if (!currPos.right.deleted) {
      switch (currPos.right.content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            currPos.right.content
          );
          const attr = attributes[key];
          if (attr !== void 0) {
            if (equalAttrs(attr, value)) {
              negatedAttributes.delete(key);
            } else {
              if (length3 === 0) {
                break iterationLoop;
              }
              negatedAttributes.set(key, value);
            }
            currPos.right.delete(transaction);
          } else {
            currPos.currentAttributes.set(key, value);
          }
          break;
        }
        default:
          if (length3 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
          }
          length3 -= currPos.right.length;
          break;
      }
    }
    currPos.forward();
  }
  if (length3 > 0) {
    let newlines = "";
    for (; length3 > 0; length3--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
}, "formatText");
var cleanupFormattingGap = /* @__PURE__ */ __name((transaction, start, curr, startAttributes, currAttributes) => {
  let end = start;
  const endFormats = create();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = startAttributes.get(key) || null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
}, "cleanupFormattingGap");
var cleanupContextlessFormattingGap = /* @__PURE__ */ __name((transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
}, "cleanupContextlessFormattingGap");
var cleanupYTextFormatting = /* @__PURE__ */ __name((type) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type._start
      );
      let end = type._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
}, "cleanupYTextFormatting");
var deleteText = /* @__PURE__ */ __name((transaction, currPos, length3) => {
  const startLength = length3;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length3 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length3 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
          }
          length3 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3);
  }
  return currPos;
}, "deleteText");
var _YTextEvent = class _YTextEvent extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y, (transaction) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = /* @__PURE__ */ __name(() => {
          if (action !== null) {
            let op;
            switch (action) {
              case "delete":
                op = { delete: deleteLen };
                deleteLen = 0;
                break;
              case "insert":
                op = { insert };
                if (currentAttributes.size > 0) {
                  op.attributes = {};
                  currentAttributes.forEach((value, key) => {
                    if (value !== null) {
                      op.attributes[key] = value;
                    }
                  });
                }
                insert = "";
                break;
              case "retain":
                op = { retain };
                if (Object.keys(attributes).length > 0) {
                  op.attributes = {};
                  for (const key in attributes) {
                    op.attributes[key] = attributes[key];
                  }
                }
                retain = 0;
                break;
            }
            delta.push(op);
            action = null;
          }
        }, "addOp");
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key) || null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, oldAttributes.get(key) || null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = currentAttributes.get(key) || null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
__name(_YTextEvent, "YTextEvent");
var YTextEvent = _YTextEvent;
var _YText = class _YText extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e) {
      console.error(e);
    }
    this._pending = null;
  }
  _copy() {
    return new _YText();
  }
  /**
   * @return {YText}
   */
  clone() {
    const text2 = new _YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    const doc2 = transaction.doc;
    callTypeObservers(this, transaction, event);
    if (!transaction.local) {
      let foundFormattingItem = false;
      for (const [client, afterClock] of transaction.afterState.entries()) {
        const clock = transaction.beforeState.get(client) || 0;
        if (afterClock === clock) {
          continue;
        }
        iterateStructs(
          transaction,
          /** @type {Array<Item|GC>} */
          doc2.store.clients.get(client),
          clock,
          afterClock,
          (item) => {
            if (!item.deleted && /** @type {Item} */
            item.content.constructor === ContentFormat) {
              foundFormattingItem = true;
            }
          }
        );
        if (foundFormattingItem) {
          break;
        }
      }
      if (!foundFormattingItem) {
        iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
          if (item instanceof GC || foundFormattingItem) {
            return;
          }
          if (item.parent === this && item.content.constructor === ContentFormat) {
            foundFormattingItem = true;
          }
        });
      }
      transact(doc2, (t) => {
        if (foundFormattingItem) {
          cleanupYTextFormatting(this);
        } else {
          iterateDeletedStructs(t, t.deleteSet, (item) => {
            if (item instanceof GC) {
              return;
            }
            if (item.parent === this) {
              cleanupContextlessFormattingGap(t, item);
            }
          });
        }
      });
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i = 0; i < delta.length; i++) {
          const op = delta[i];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    __name(packStr, "packStr");
    transact(doc2, (transaction) => {
      if (snapshot) {
        splitSnapshotAffectedStructs(transaction, snapshot);
      }
      if (prevSnapshot) {
        splitSnapshotAffectedStructs(transaction, prevSnapshot);
      }
      while (n !== null) {
        if (isVisible(n, snapshot) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n, snapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    }, "cleanup");
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v, k) => {
            attributes[k] = v;
          });
        }
        insertText(transaction, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text2, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes = {}) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index);
        insertText(transaction, this, pos, embed, attributes);
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length3) {
    if (length3 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index), length3);
      });
    } else {
      this._pending.push(() => this.delete(index, length3));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length3, attributes) {
    if (length3 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length3, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length3, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
__name(_YText, "YText");
var YText = _YText;
var readYText = /* @__PURE__ */ __name((_decoder) => new YText(), "readYText");
var _YXmlTreeWalker = class _YXmlTreeWalker {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root2, f = () => true) {
    this._filter = f;
    this._root = root2;
    this._currentNode = /** @type {Item} */
    root2._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
      do {
        type = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n = type._start;
        } else {
          while (n !== null) {
            if (n.right !== null) {
              n = n.right;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
};
__name(_YXmlTreeWalker, "YXmlTreeWalker");
var YXmlTreeWalker = _YXmlTreeWalker;
var _YXmlFragment = class _YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new _YXmlFragment();
  }
  /**
   * @return {YXmlFragment}
   */
  clone() {
    const el = new _YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter2) {
    return new YXmlTreeWalker(this, filter2);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator2 = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
    const next = iterator2.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from2(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return transact(
      /** @type {Doc} */
      this.doc,
      () => typeListMap(this, (xml) => xml.toString()).join("")
    );
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment2 = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment2, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment2.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment2;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length3);
      });
    } else {
      this._prelimContent.splice(index, length3);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
__name(_YXmlFragment, "YXmlFragment");
var YXmlFragment = _YXmlFragment;
var readYXmlFragment = /* @__PURE__ */ __name((_decoder) => new YXmlFragment(), "readYXmlFragment");
var _YXmlElement = class _YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new _YXmlElement(this.nodeName);
  }
  /**
   * @return {YXmlElement}
   */
  clone() {
    const el = new _YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      el.setAttribute(key, attrs[key]);
    }
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys3 = [];
    for (const key in attrs) {
      keys3.push(key);
    }
    keys3.sort();
    const keysLen = keys3.length;
    for (let i = 0; i < keysLen; i++) {
      const key = keys3[i];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {String} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {String} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {String} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      dom.setAttribute(key, attrs[key]);
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
__name(_YXmlElement, "YXmlElement");
var YXmlElement = _YXmlElement;
var readYXmlElement = /* @__PURE__ */ __name((decoder) => new YXmlElement(decoder.readKey()), "readYXmlElement");
var _YXmlEvent = class _YXmlEvent extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
__name(_YXmlEvent, "YXmlEvent");
var YXmlEvent = _YXmlEvent;
var _YXmlHook = class _YXmlHook extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new _YXmlHook(this.hookName);
  }
  /**
   * @return {YXmlHook}
   */
  clone() {
    const el = new _YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
__name(_YXmlHook, "YXmlHook");
var YXmlHook = _YXmlHook;
var readYXmlHook = /* @__PURE__ */ __name((decoder) => new YXmlHook(decoder.readKey()), "readYXmlHook");
var _YXmlText = class _YXmlText extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  _copy() {
    return new _YXmlText();
  }
  /**
   * @return {YXmlText}
   */
  clone() {
    const text2 = new _YXmlText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a, b) => a.key < b.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);
      let str = "";
      for (let i = 0; i < nestedNodes.length; i++) {
        const node = nestedNodes[i];
        str += `<${node.nodeName}`;
        for (let j = 0; j < node.attrs.length; j++) {
          const attr = node.attrs[j];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i = nestedNodes.length - 1; i >= 0; i--) {
        str += `</${nestedNodes[i].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
__name(_YXmlText, "YXmlText");
var YXmlText = _YXmlText;
var readYXmlText = /* @__PURE__ */ __name((decoder) => new YXmlText(), "readYXmlText");
var _AbstractStruct = class _AbstractStruct {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id, length3) {
    this.id = id;
    this.length = length3;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
__name(_AbstractStruct, "AbstractStruct");
var AbstractStruct = _AbstractStruct;
var structGCRefNumber = 0;
var _GC = class _GC extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
__name(_GC, "GC");
var GC = _GC;
var _ContentBinary = class _ContentBinary {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new _ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
__name(_ContentBinary, "ContentBinary");
var ContentBinary = _ContentBinary;
var readContentBinary = /* @__PURE__ */ __name((decoder) => new ContentBinary(decoder.readBuf()), "readContentBinary");
var _ContentDeleted = class _ContentDeleted {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new _ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
__name(_ContentDeleted, "ContentDeleted");
var ContentDeleted = _ContentDeleted;
var readContentDeleted = /* @__PURE__ */ __name((decoder) => new ContentDeleted(decoder.readLen()), "readContentDeleted");
var createDocFromOpts = /* @__PURE__ */ __name((guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false }), "createDocFromOpts");
var _ContentDoc = class _ContentDoc {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
__name(_ContentDoc, "ContentDoc");
var ContentDoc = _ContentDoc;
var readContentDoc = /* @__PURE__ */ __name((decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny())), "readContentDoc");
var _ContentEmbed = class _ContentEmbed {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
__name(_ContentEmbed, "ContentEmbed");
var ContentEmbed = _ContentEmbed;
var readContentEmbed = /* @__PURE__ */ __name((decoder) => new ContentEmbed(decoder.readJSON()), "readContentEmbed");
var _ContentFormat = class _ContentFormat {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new _ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} offset
   * @return {ContentFormat}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    item.parent._searchMarker = null;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
__name(_ContentFormat, "ContentFormat");
var ContentFormat = _ContentFormat;
var readContentFormat = /* @__PURE__ */ __name((decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON()), "readContentFormat");
var _ContentJSON = class _ContentJSON {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new _ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new _ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeString(c === void 0 ? "undefined" : JSON.stringify(c));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
__name(_ContentJSON, "ContentJSON");
var ContentJSON = _ContentJSON;
var readContentJSON = /* @__PURE__ */ __name((decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    const c = decoder.readString();
    if (c === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c));
    }
  }
  return new ContentJSON(cs);
}, "readContentJSON");
var _ContentAny = class _ContentAny {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new _ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new _ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeAny(c);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
__name(_ContentAny, "ContentAny");
var ContentAny = _ContentAny;
var readContentAny = /* @__PURE__ */ __name((decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
}, "readContentAny");
var _ContentString = class _ContentString {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new _ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new _ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "\uFFFD";
      right.str = "\uFFFD" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
__name(_ContentString, "ContentString");
var ContentString = _ContentString;
var readContentString = /* @__PURE__ */ __name((decoder) => new ContentString(decoder.readString()), "readContentString");
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var _ContentType = class _ContentType {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new _ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
__name(_ContentType, "ContentType");
var ContentType = _ContentType;
var readContentType = /* @__PURE__ */ __name((decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder)), "readContentType");
var followRedone = /* @__PURE__ */ __name((store, id) => {
  let nextID = id;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
}, "followRedone");
var splitItem = /* @__PURE__ */ __name((transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
}, "splitItem");
var _Item = class _Item extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id, left, origin2, right, rightOrigin, parent, parentSub, content) {
    super(id, content.getLength());
    this.origin = origin2;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    }
    if (!this.parent) {
      if (this.left && this.left.constructor === _Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === _Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin2 = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin2 === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin2 !== null) {
      encoder.writeLeftID(origin2);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin2 === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
__name(_Item, "Item");
var Item = _Item;
var readItemContent = /* @__PURE__ */ __name((decoder, info) => contentRefs[info & BITS5](decoder), "readItemContent");
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var _Skip = class _Skip extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
__name(_Skip, "Skip");
var Skip = _Skip;
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// src/services/docs/UpdateController.ts
var _UpdateController = class _UpdateController {
  constructor(conf) {
    this.conf = conf;
    this.mergedOutgoing = null;
    this.restId = null;
    var _a8;
    const wait = (_a8 = this.conf.sendBufferWait) != null ? _a8 : 0;
    if (wait <= 0) return;
    this.dispatchOutgoing = throttle_default(
      () => {
        if (!this.mergedOutgoing) return;
        const merged = this.mergedOutgoing;
        this.mergedOutgoing = null;
        this.mark();
        this.conf.sendOutgoing(merged);
      },
      wait,
      { trailing: true, leading: false }
    );
  }
  /**
   * Send a ydoc update from this client to the server. May be merged with others and batched.
   * @param update The update to send.
   */
  send(update) {
    if (!this.dispatchOutgoing) {
      this.mark();
      this.conf.sendOutgoing(update);
      return;
    }
    this.mergedOutgoing = this.mergedOutgoing ? mergeUpdates([this.mergedOutgoing, update]) : update;
    this.dispatchOutgoing();
  }
  /**
   * Receive a ydoc update from the server to the client. Passed through to the writeIncoming
   * constructor param.
   * @param update
   */
  receive(update) {
    this.conf.writeIncoming(update);
  }
  /**
   * Send all pending outgoing updates and stop monitoring for rest.
   */
  flush() {
    if (this.restId) window.clearTimeout(this.restId);
    this.restId = null;
    if (!this.dispatchOutgoing) return;
    this.dispatchOutgoing.flush();
  }
  mark() {
    if (!this.conf.onRest || !this.conf.restWait || this.conf.restWait <= 0)
      return;
    if (this.restId) window.clearTimeout(this.restId);
    this.restId = window.setTimeout(() => {
      this.restId = null;
      if (this.conf.onRest) this.conf.onRest();
    }, this.conf.restWait);
  }
};
__name(_UpdateController, "UpdateController");
var UpdateController = _UpdateController;

// src/services/docs/DocChannel.ts
var import_debug4 = __toESM(require_browser2());
var import_obsidian7 = require("obsidian");
var BUFFER_INTERVAL = 500;
var REST_TIMEOUT = 3e4;
var _DocChannel = class _DocChannel {
  constructor(plugin, doc2, context2, lifecycle) {
    this.plugin = plugin;
    this.doc = doc2;
    this.context = context2;
    this.lifecycle = lifecycle;
    this.channel = null;
    this.presence = null;
    this._pendingPresenceUpdate = null;
    this.handleChannelJoin = /* @__PURE__ */ __name((reply) => {
      var _a8, _b;
      if (this.channel == null) return;
      this.log("connected");
      this.doc.ydoc.on("update", this.handleYDocUpdate);
      this.channel.on("update", this.handleChannelUpdate);
      (_b = (_a8 = this.lifecycle).onJoin) == null ? void 0 : _b.call(_a8, this, reply);
      this.sync();
    }, "handleChannelJoin");
    this.handleChannelRejected = /* @__PURE__ */ __name((msg) => {
      this.log("rejected: %o", msg);
    }, "handleChannelRejected");
    // ydoc -> channel updates
    this.handleYDocUpdate = /* @__PURE__ */ __name((update, origin2) => {
      var _a8;
      if (origin2 == this) return;
      (_a8 = this.updates) == null ? void 0 : _a8.send(update);
    }, "handleYDocUpdate");
    this.pushUpdate = /* @__PURE__ */ __name((update) => {
      if (this.channel == null) return;
      this.log("sending update, %d bytes", update.byteLength);
      this.channel.push("update", update.buffer);
    }, "pushUpdate");
    // channel -> ydoc updates
    this.handleChannelUpdate = /* @__PURE__ */ __name((update) => {
      var _a8, _b, _c;
      this.log("received update, %d bytes", update.byteLength);
      (_a8 = this.updates) == null ? void 0 : _a8.receive(update);
      (_c = (_b = this.lifecycle).onUpdate) == null ? void 0 : _c.call(_b, this);
    }, "handleChannelUpdate");
    this.applyUpdate = /* @__PURE__ */ __name((update) => {
      const decoded = update instanceof Uint8Array ? update : new Uint8Array(update);
      applyUpdate(this.doc.ydoc, decoded, this);
    }, "applyUpdate");
    // sync
    this.sync = /* @__PURE__ */ __name(() => {
      if (this.channel == null) return;
      this.log("syncing");
      const sv = encodeStateVector(this.doc.ydoc).buffer;
      this.channel.push("sync", sv).receive("ok", ({ diff_update, state_vector }) => {
        var _a8, _b, _c;
        this.log("sync received diff and sv");
        const sv2 = new Uint8Array((0, import_obsidian7.base64ToArrayBuffer)(state_vector));
        const diff = new Uint8Array((0, import_obsidian7.base64ToArrayBuffer)(diff_update));
        this.log("received sync update, %d bytes", diff.byteLength);
        this.applyUpdate(diff);
        const update = encodeStateAsUpdate(this.doc.ydoc, sv2);
        this.log("sending sync update, %d bytes", update.byteLength);
        (_a8 = this.channel) == null ? void 0 : _a8.push("update", update.buffer);
        this.log("synced");
        (_c = (_b = this.lifecycle).afterSync) == null ? void 0 : _c.call(_b, this);
      }).receive("error", () => {
        this.log("sync failed");
      });
    }, "sync");
    // presence
    this.pushPresence = /* @__PURE__ */ __name((update) => {
      if (this.channel) {
        this.channel.push("update-presence", update);
      } else {
        this._pendingPresenceUpdate = update;
      }
    }, "pushPresence");
    this.listPresences = /* @__PURE__ */ __name((keyName) => {
      var _a8, _b;
      return (_b = (_a8 = this.presence) == null ? void 0 : _a8.list((k, v) => v.metas.map((m) => ({ [keyName]: k, ...m }))).flat()) != null ? _b : [];
    }, "listPresences");
    this.log = (0, import_debug4.default)(`screen.garden:doc:${doc2.id}:${context2.kind}`);
    this.log("init");
    this.updates = new UpdateController({
      sendOutgoing: this.pushUpdate.bind(this),
      sendBufferWait: BUFFER_INTERVAL,
      writeIncoming: this.applyUpdate.bind(this),
      onRest: /* @__PURE__ */ __name(() => {
        this.sync();
      }, "onRest"),
      restWait: REST_TIMEOUT
    });
    this.socketSubscription = this.plugin.socket.observable.subscribe(
      (socket) => {
        if (socket) {
          this.connect(socket);
        } else {
          this.disconnect();
        }
      }
    );
    if (this.plugin.socket.socket) this.connect(this.plugin.socket.socket);
  }
  connect(socket) {
    this.disconnect();
    this.log("connecting");
    const channel = socket.channel(`doc:${this.doc.id}`, this.context);
    channel.join().receive("ok", this.handleChannelJoin).receive("error", this.handleChannelRejected);
    this.channel = channel;
    this.presence = new Presence(this.channel);
    this.presence.onSync(() => {
      if (!this.presence) return;
      this.plugin.docs.trigger(`presence:${this.doc.id}`, this.doc.id);
    });
    if (this._pendingPresenceUpdate) {
      this.pushPresence(this._pendingPresenceUpdate);
      this._pendingPresenceUpdate = null;
    }
  }
  disconnect() {
    var _a8;
    if (this.channel == null) return;
    this.log("disconnecting");
    this.doc.ydoc.off("update", this.handleYDocUpdate);
    (_a8 = this.updates) == null ? void 0 : _a8.flush();
    this.channel.leave();
    this.channel = null;
    if (this.presence) {
      this.presence.onSync = function() {
      };
    }
    this.presence = null;
  }
  unload() {
    this.disconnect();
    this.socketSubscription.unsubscribe();
    this.updates = null;
    this.lifecycle = {};
  }
  push(event, payload) {
    return new Promise((resolve, reject) => {
      if (this.channel == null) {
        reject();
        return;
      }
      this.channel.push(event, payload).receive("ok", (res) => {
        resolve(res);
      }).receive("error", () => {
        this.log(`${event} push failed`);
        reject();
      });
    });
  }
};
__name(_DocChannel, "DocChannel");
var DocChannel = _DocChannel;

// src/services/docs/DocsService.ts
var import_debug5 = __toESM(require_browser2());

// node_modules/y-indexeddb/src/y-indexeddb.js
init_process_shim();

// node_modules/lib0/indexeddb.js
init_process_shim();
var rtop = /* @__PURE__ */ __name((request) => create4((resolve, reject) => {
  request.onerror = (event) => reject(new Error(event.target.error));
  request.onsuccess = (event) => resolve(event.target.result);
}), "rtop");
var openDB = /* @__PURE__ */ __name((name, initDB) => create4((resolve, reject) => {
  const request = indexedDB.open(name);
  request.onupgradeneeded = (event) => initDB(event.target.result);
  request.onerror = (event) => reject(create3(event.target.error));
  request.onsuccess = (event) => {
    const db = event.target.result;
    db.onversionchange = () => {
      db.close();
    };
    if (typeof addEventListener !== "undefined") {
      addEventListener("unload", () => db.close());
    }
    resolve(db);
  };
}), "openDB");
var deleteDB = /* @__PURE__ */ __name((name) => rtop(indexedDB.deleteDatabase(name)), "deleteDB");
var createStores = /* @__PURE__ */ __name((db, definitions) => definitions.forEach(
  (d2) => (
    // @ts-ignore
    db.createObjectStore.apply(db, d2)
  )
), "createStores");
var transact2 = /* @__PURE__ */ __name((db, stores, access = "readwrite") => {
  const transaction = db.transaction(stores, access);
  return stores.map((store) => getStore(transaction, store));
}, "transact");
var count = /* @__PURE__ */ __name((store, range) => rtop(store.count(range)), "count");
var get2 = /* @__PURE__ */ __name((store, key) => rtop(store.get(key)), "get");
var del = /* @__PURE__ */ __name((store, key) => rtop(store.delete(key)), "del");
var put = /* @__PURE__ */ __name((store, item, key) => rtop(store.put(item, key)), "put");
var addAutoKey = /* @__PURE__ */ __name((store, item) => rtop(store.add(item)), "addAutoKey");
var getAll = /* @__PURE__ */ __name((store, range, limit) => rtop(store.getAll(range, limit)), "getAll");
var queryFirst = /* @__PURE__ */ __name((store, query, direction) => {
  let first = null;
  return iterateKeys(store, query, (key) => {
    first = key;
    return false;
  }, direction).then(() => first);
}, "queryFirst");
var getLastKey = /* @__PURE__ */ __name((store, range = null) => queryFirst(store, range, "prev"), "getLastKey");
var iterateOnRequest = /* @__PURE__ */ __name((request, f) => create4((resolve, reject) => {
  request.onerror = reject;
  request.onsuccess = async (event) => {
    const cursor = event.target.result;
    if (cursor === null || await f(cursor) === false) {
      return resolve();
    }
    cursor.continue();
  };
}), "iterateOnRequest");
var iterateKeys = /* @__PURE__ */ __name((store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key)), "iterateKeys");
var getStore = /* @__PURE__ */ __name((t, store) => t.objectStore(store), "getStore");
var createIDBKeyRangeUpperBound = /* @__PURE__ */ __name((upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen), "createIDBKeyRangeUpperBound");
var createIDBKeyRangeLowerBound = /* @__PURE__ */ __name((lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen), "createIDBKeyRangeLowerBound");

// node_modules/lib0/mutex.js
init_process_shim();
var createMutex = /* @__PURE__ */ __name(() => {
  let token = true;
  return (f, g) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g !== void 0) {
      g();
    }
  };
}, "createMutex");

// node_modules/y-indexeddb/src/y-indexeddb.js
var customStoreName = "custom";
var updatesStoreName = "updates";
var PREFERRED_TRIM_SIZE = 500;
var fetchUpdates = /* @__PURE__ */ __name((idbPersistence) => {
  const [updatesStore] = transact2(
    /** @type {IDBDatabase} */
    idbPersistence.db,
    [updatesStoreName]
  );
  return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then(
    (updates) => transact(idbPersistence.doc, () => {
      updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
    }, idbPersistence, false)
  ).then(() => getLastKey(updatesStore).then((lastKey) => {
    idbPersistence._dbref = lastKey + 1;
  })).then(() => count(updatesStore).then((cnt) => {
    idbPersistence._dbsize = cnt;
  })).then(() => updatesStore);
}, "fetchUpdates");
var storeState = /* @__PURE__ */ __name((idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
    addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    }));
  }
}), "storeState");
var clearDocument = /* @__PURE__ */ __name((name) => deleteDB(name), "clearDocument");
var _IndexeddbPersistence = class _IndexeddbPersistence extends Observable3 {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(name, doc2) {
    super();
    this.doc = doc2;
    this.name = name;
    this._mux = createMutex();
    this._dbref = 0;
    this._dbsize = 0;
    this._destroyed = false;
    this.db = null;
    this.synced = false;
    this._db = openDB(
      name,
      (db) => createStores(db, [
        ["updates", { autoIncrement: true }],
        ["custom"]
      ])
    );
    this.whenSynced = this._db.then((db) => {
      this.db = db;
      const currState = encodeStateAsUpdate(doc2);
      return fetchUpdates(this).then((updatesStore) => addAutoKey(updatesStore, currState)).then(() => {
        if (this._destroyed) return this;
        this.emit("synced", [this]);
        this.synced = true;
        return this;
      });
    });
    this._storeTimeout = 1e3;
    this._storeTimeoutId = null;
    this._storeUpdate = (update, origin2) => {
      if (this.db && origin2 !== this) {
        const [updatesStore] = transact2(
          /** @type {IDBDatabase} */
          this.db,
          [updatesStoreName]
        );
        addAutoKey(updatesStore, update);
        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
          if (this._storeTimeoutId !== null) {
            clearTimeout(this._storeTimeoutId);
          }
          this._storeTimeoutId = setTimeout(() => {
            storeState(this, false);
            this._storeTimeoutId = null;
          }, this._storeTimeout);
        }
      }
    };
    doc2.on("update", this._storeUpdate);
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  destroy() {
    if (this._storeTimeoutId) {
      clearTimeout(this._storeTimeoutId);
    }
    this.doc.off("update", this._storeUpdate);
    this.doc.off("destroy", this.destroy);
    this._destroyed = true;
    return this._db.then((db) => {
      db.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      deleteDB(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName], "readonly");
      return get2(custom, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(key, value) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return put(custom, value, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return del(custom, key);
    });
  }
};
__name(_IndexeddbPersistence, "IndexeddbPersistence");
var IndexeddbPersistence = _IndexeddbPersistence;

// src/services/docs/DocsService.ts
var TABLE3 = "id";
var log3 = (0, import_debug5.default)("screen.garden:docs");
var _DocsService = class _DocsService extends Service {
  constructor(plugin) {
    super(plugin);
  }
  async create(id = v4_default()) {
    const doc2 = { id };
    const doc_id = await this.db.docs.put(doc2);
    log3("inserted new doc: %s", doc_id);
    return doc2;
  }
  async get(id) {
    const doc2 = await this.db.docs.get(id);
    return doc2 != null ? doc2 : null;
  }
  async getOrCreateAndLoad(id, context2, lifecycle) {
    var _a8;
    const doc2 = (_a8 = await this.get(id)) != null ? _a8 : await this.create(id);
    return this.load(doc2, context2, lifecycle);
  }
  docName(id) {
    return `screen.garden:doc:${this.plugin.appId}:${id}`;
  }
  persistedDoc(docId, ydoc = new Doc()) {
    return new IndexeddbPersistence(this.docName(docId), ydoc);
  }
  async docIsPersisted(docId) {
    const name = this.docName(docId);
    return (await indexedDB.databases()).some((d2) => d2.name === name);
  }
  load(doc2, context2, lifecycle) {
    log3(`loading ${doc2.id}`);
    const provider = this.persistedDoc(doc2.id);
    return new Promise((resolve) => {
      provider.on("synced", () => {
        const loadedDoc = { ...doc2, ydoc: provider.doc, provider };
        const channel = new DocChannel(
          this.plugin,
          loadedDoc,
          context2,
          lifecycle
        );
        resolve({ ...loadedDoc, channel });
      });
    });
  }
  unload(doc2) {
    if ("channel" in doc2) {
      doc2.channel.disconnect();
      doc2.channel.unload();
    }
  }
  async delete(docOrId) {
    const id = typeof docOrId === "string" ? docOrId : docOrId.id;
    return Promise.all([
      clearDocument(this.docName(id)),
      this.db.docs.delete(id)
    ]);
  }
};
__name(_DocsService, "DocsService");
var DocsService = _DocsService;

// src/services/notes/NoteService.ts
init_process_shim();

// src/services/notes/HandlerPool.ts
init_process_shim();

// src/services/notes/NoteHandler.ts
init_process_shim();

// node_modules/@dmsnell/diff-match-patch/index.js
init_process_shim();
var diff_match_patch = /* @__PURE__ */ __name(function() {
  this.Diff_Timeout = 1;
  this.Diff_EditCost = 4;
  this.Match_Threshold = 0.5;
  this.Match_Distance = 1e3;
  this.Patch_DeleteThreshold = 0.5;
  this.Patch_Margin = 4;
  this.Match_MaxBits = 32;
}, "diff_match_patch");
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
diff_match_patch.Diff = function(op, text2) {
  this[0] = op;
  this[1] = text2;
};
diff_match_patch.Diff.prototype.length = 2;
diff_match_patch.Diff.prototype.toString = function() {
  return this[0] + "," + this[1];
};
diff_match_patch.Diff.prototype[Symbol.iterator] = function* () {
  yield this[0];
  yield this[1];
};
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
  if (typeof opt_deadline == "undefined") {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3;
    }
  }
  var deadline = opt_deadline;
  if (text1 == null || text2 == null) {
    throw new Error("Null input. (diff_main)");
  }
  if (text1 == text2) {
    if (text1) {
      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
    }
    return [];
  }
  if (typeof opt_checklines == "undefined") {
    opt_checklines = true;
  }
  var checklines = opt_checklines;
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);
  if (commonprefix) {
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
  }
  if (commonsuffix) {
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
  var diffs;
  if (!text1) {
    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }
  if (!text2) {
    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    diffs = [
      new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
      new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
      new diff_match_patch.Diff(
        DIFF_INSERT,
        longtext.substring(i + shorttext.length)
      )
    ];
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  if (shorttext.length == 1) {
    return [
      new diff_match_patch.Diff(DIFF_DELETE, text1),
      new diff_match_patch.Diff(DIFF_INSERT, text2)
    ];
  }
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    return diffs_a.concat(
      [new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
      diffs_b
    );
  }
  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }
  return this.diff_bisect_(text1, text2, deadline);
};
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;
  var diffs = this.diff_main(text1, text2, false, deadline);
  this.diff_charsToLines_(diffs, linearray);
  this.diff_cleanupSemantic(diffs);
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = "";
  var text_insert = "";
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (count_delete >= 1 && count_insert >= 1) {
          diffs.splice(
            pointer - count_delete - count_insert,
            count_delete + count_insert
          );
          pointer = pointer - count_delete - count_insert;
          var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = subDiff.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, subDiff[j]);
          }
          pointer = pointer + subDiff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
    pointer++;
  }
  diffs.pop();
  return diffs;
};
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  var front = delta % 2 != 0;
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d2 = 0; d2 < max_d; d2++) {
    if ((/* @__PURE__ */ new Date()).getTime() > deadline) {
      break;
    }
    for (var k1 = -d2 + k1start; k1 <= d2 - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d2 || k1 != d2 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        k1end += 2;
      } else if (y1 > text2_length) {
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
    for (var k2 = -d2 + k2start; k2 <= d2 - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d2 || k2 != d2 && v2[k2_offset - 1] < v2[k2_offset + 1]) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        k2end += 2;
      } else if (y2 > text2_length) {
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          x2 = text1_length - x2;
          if (x1 >= x2) {
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  return [
    new diff_match_patch.Diff(DIFF_DELETE, text1),
    new diff_match_patch.Diff(DIFF_INSERT, text2)
  ];
};
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);
  return diffs.concat(diffsb);
};
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];
  var lineHash = {};
  lineArray[0] = "";
  function diff_linesToCharsMunge_(text3) {
    var chars = "";
    var lineStart = 0;
    var lineEnd = -1;
    var lineArrayLength = lineArray.length;
    while (lineEnd < text3.length - 1) {
      lineEnd = text3.indexOf("\n", lineStart);
      if (lineEnd == -1) {
        lineEnd = text3.length - 1;
      }
      var line = text3.substring(lineStart, lineEnd + 1);
      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength == maxLines) {
          line = text3.substring(lineStart);
          lineEnd = text3.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  __name(diff_linesToCharsMunge_, "diff_linesToCharsMunge_");
  var maxLines = 4e4;
  var chars1 = diff_linesToCharsMunge_(text1);
  maxLines = 65535;
  var chars2 = diff_linesToCharsMunge_(text2);
  return { chars1, chars2, lineArray };
};
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var i = 0; i < diffs.length; i++) {
    var chars = diffs[i][1];
    var text2 = [];
    for (var j = 0; j < chars.length; j++) {
      text2[j] = lineArray[chars.charCodeAt(j)];
    }
    diffs[i][1] = text2.join("");
  }
};
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  var text1_length = text1.length;
  var text2_length = text2.length;
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  if (text1 == text2) {
    return text_length;
  }
  var best = 0;
  var length3 = 1;
  while (true) {
    var pattern = text1.substring(text_length - length3);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length3 += found;
    if (found == 0 || text1.substring(text_length - length3) == text2.substring(0, length3)) {
      best = length3;
      length3++;
    }
  }
};
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;
  }
  var dmp = this;
  function diff_halfMatchI_(longtext2, shorttext2, i) {
    var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
    var j = -1;
    var best_common = "";
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(
        longtext2.substring(i),
        shorttext2.substring(j)
      );
      var suffixLength = dmp.diff_commonSuffix(
        longtext2.substring(0, i),
        shorttext2.substring(0, j)
      );
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
        best_longtext_a = longtext2.substring(0, i - suffixLength);
        best_longtext_b = longtext2.substring(i + prefixLength);
        best_shorttext_a = shorttext2.substring(0, j - suffixLength);
        best_shorttext_b = shorttext2.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext2.length) {
      return [
        best_longtext_a,
        best_longtext_b,
        best_shorttext_a,
        best_shorttext_b,
        best_common
      ];
    } else {
      return null;
    }
  }
  __name(diff_halfMatchI_, "diff_halfMatchI_");
  var hm1 = diff_halfMatchI_(
    longtext,
    shorttext,
    Math.ceil(longtext.length / 4)
  );
  var hm2 = diff_halfMatchI_(
    longtext,
    shorttext,
    Math.ceil(longtext.length / 2)
  );
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];
  var equalitiesLength = 0;
  var lastEquality = null;
  var pointer = 0;
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(
        length_insertions2,
        length_deletions2
      )) {
        diffs.splice(
          equalities[equalitiesLength - 1],
          0,
          new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
        );
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, new diff_match_patch.Diff(
            DIFF_EQUAL,
            insertion.substring(0, overlap_length1)
          ));
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer, 0, new diff_match_patch.Diff(
            DIFF_EQUAL,
            deletion.substring(0, overlap_length2)
          ));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] = deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      return 6;
    }
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  __name(diff_cleanupSemanticScore_, "diff_cleanupSemanticScore_");
  var pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] != bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];
  var equalitiesLength = 0;
  var lastEquality = null;
  var pointer = 0;
  var pre_ins = false;
  var pre_del = false;
  var post_ins = false;
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {
      if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastEquality = diffs[pointer][1];
      } else {
        equalitiesLength = 0;
        lastEquality = null;
      }
      post_ins = post_del = false;
    } else {
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
        diffs.splice(
          equalities[equalitiesLength - 1],
          0,
          new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
        );
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        lastEquality = null;
        if (pre_ins && pre_del) {
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = "";
  var text_insert = "";
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new diff_match_patch.Diff(
                  DIFF_EQUAL,
                  text_insert.substring(0, commonlength)
                ));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(
              pointer,
              0,
              new diff_match_patch.Diff(DIFF_DELETE, text_delete)
            );
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(
              pointer,
              0,
              new diff_match_patch.Diff(DIFF_INSERT, text_insert)
            );
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "") {
    diffs.pop();
  }
  var changes = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};
diff_match_patch.prototype.diff_cleanupSplitSurrogates = function(diffs) {
  var lastEnd;
  for (var x = 0; x < diffs.length; x++) {
    var thisDiff = diffs[x];
    var thisTop = thisDiff[1][0];
    var thisEnd = thisDiff[1][thisDiff[1].length - 1];
    if (0 === thisDiff[1].length) {
      diffs.splice(x--, 1);
      continue;
    }
    if (thisEnd && this.isHighSurrogate(thisEnd)) {
      lastEnd = thisEnd;
      thisDiff[1] = thisDiff[1].slice(0, -1);
    }
    if (lastEnd && thisTop && this.isHighSurrogate(lastEnd) && this.isLowSurrogate(thisTop)) {
      thisDiff[1] = lastEnd + thisDiff[1];
    }
    if (0 === thisDiff[1].length) {
      diffs.splice(x--, 1);
      continue;
    }
  }
  return diffs;
};
diff_match_patch.prototype.isHighSurrogate = function(c) {
  var v = c.charCodeAt(0);
  return v >= 55296 && v <= 56319;
};
diff_match_patch.prototype.isLowSurrogate = function(c) {
  var v = c.charCodeAt(0);
  return v >= 56320 && v <= 57343;
};
diff_match_patch.prototype.digit16 = function(c) {
  switch (c) {
    case "0":
      return 0;
    case "1":
      return 1;
    case "2":
      return 2;
    case "3":
      return 3;
    case "4":
      return 4;
    case "5":
      return 5;
    case "6":
      return 6;
    case "7":
      return 7;
    case "8":
      return 8;
    case "9":
      return 9;
    case "A":
    case "a":
      return 10;
    case "B":
    case "b":
      return 11;
    case "C":
    case "c":
      return 12;
    case "D":
    case "d":
      return 13;
    case "E":
    case "e":
      return 14;
    case "F":
    case "f":
      return 15;
    default:
      throw new Error("Invalid hex-code");
  }
};
diff_match_patch.prototype.decodeURI = function(text2) {
  try {
    return decodeURI(text2);
  } catch (e) {
    var i = 0;
    var decoded = "";
    while (i < text2.length) {
      if (text2[i] !== "%") {
        decoded += text2[i++];
        continue;
      }
      var byte1 = (this.digit16(text2[i + 1]) << 4) + this.digit16(text2[i + 2]);
      if ((byte1 & 128) === 0) {
        decoded += String.fromCharCode(byte1);
        i += 3;
        continue;
      }
      if ("%" !== text2[i + 3]) {
        throw new URIError("URI malformed");
      }
      var byte2 = (this.digit16(text2[i + 4]) << 4) + this.digit16(text2[i + 5]);
      if ((byte2 & 192) !== 128) {
        throw new URIError("URI malformed");
      }
      byte2 = byte2 & 63;
      if ((byte1 & 224) === 192) {
        decoded += String.fromCharCode((byte1 & 31) << 6 | byte2);
        i += 6;
        continue;
      }
      if ("%" !== text2[i + 6]) {
        throw new URIError("URI malformed");
      }
      var byte3 = (this.digit16(text2[i + 7]) << 4) + this.digit16(text2[i + 8]);
      if ((byte3 & 192) !== 128) {
        throw new URIError("URI malformed");
      }
      byte3 = byte3 & 63;
      if ((byte1 & 240) === 224) {
        decoded += String.fromCharCode((byte1 & 15) << 12 | byte2 << 6 | byte3);
        i += 9;
        continue;
      }
      if ("%" !== text2[i + 9]) {
        throw new URIError("URI malformed");
      }
      var byte4 = (this.digit16(text2[i + 10]) << 4) + this.digit16(text2[i + 11]);
      if ((byte4 & 192) !== 128) {
        throw new URIError("URI malformed");
      }
      byte4 = byte4 & 63;
      if ((byte1 & 248) === 240) {
        var codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (codePoint >= 65536 && codePoint <= 1114111) {
          decoded += String.fromCharCode((codePoint & 65535) >>> 10 & 1023 | 55296);
          decoded += String.fromCharCode(56320 | codePoint & 65535 & 1023);
          i += 12;
          continue;
        }
      }
      throw new URIError("URI malformed");
    }
    return decoded;
  }
};
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  return last_chars2 + (loc - last_chars1);
};
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  diffs = this.diff_cleanupSplitSurrogates(diffs);
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    var text2 = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text2 + "</ins>";
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text2 + "</del>";
        break;
      case DIFF_EQUAL:
        html[x] = "<span>" + text2 + "</span>";
        break;
    }
  }
  return html.join("");
};
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text2 = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text2[x] = diffs[x][1];
    }
  }
  return text2.join("");
};
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text2 = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text2[x] = diffs[x][1];
    }
  }
  return text2.join("");
};
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  diffs = this.diff_cleanupSplitSurrogates(diffs);
  var text2 = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text2[x] = "+" + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text2[x] = "-" + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text2[x] = "=" + diffs[x][1].length;
        break;
    }
  }
  return text2.join("	").replace(/%20/g, " ");
};
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;
  var pointer = 0;
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case "+":
        try {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_INSERT, this.decodeURI(param));
        } catch (ex) {
          throw new Error("Illegal escape in diff_fromDelta: " + param);
        }
        break;
      case "-":
      case "=":
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error("Invalid number in diff_fromDelta: " + param);
        }
        var text2 = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == "=") {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text2);
        } else {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text2);
        }
        break;
      default:
        if (tokens[x]) {
          throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
  }
  return diffs;
};
diff_match_patch.prototype.match_main = function(text2, pattern, loc) {
  if (text2 == null || pattern == null || loc == null) {
    throw new Error("Null input. (match_main)");
  }
  loc = Math.max(0, Math.min(loc, text2.length));
  if (text2 == pattern) {
    return 0;
  } else if (!text2.length) {
    return -1;
  } else if (text2.substring(loc, loc + pattern.length) == pattern) {
    return loc;
  } else {
    return this.match_bitap_(text2, pattern, loc);
  }
};
diff_match_patch.prototype.match_bitap_ = function(text2, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error("Pattern too long for this browser.");
  }
  var s = this.match_alphabet_(pattern);
  var dmp = this;
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      return proximity ? 1 : accuracy;
    }
    return accuracy + proximity / dmp.Match_Distance;
  }
  __name(match_bitapScore_, "match_bitapScore_");
  var score_threshold = this.Match_Threshold;
  var best_loc = text2.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    best_loc = text2.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }
  var matchmask = 1 << pattern.length - 1;
  best_loc = -1;
  var bin_min, bin_mid;
  var bin_max = pattern.length + text2.length;
  var last_rd;
  for (var d2 = 0; d2 < pattern.length; d2++) {
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d2, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text2.length) + pattern.length;
    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d2) - 1;
    for (var j = finish; j >= start; j--) {
      var charMatch = s[text2.charAt(j - 1)];
      if (d2 === 0) {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
      } else {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d2, j - 1);
        if (score <= score_threshold) {
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            break;
          }
        }
      }
    }
    if (match_bitapScore_(d2 + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
  }
  return s;
};
diff_match_patch.prototype.patch_addContext_ = function(patch, text2) {
  if (text2.length == 0) {
    return;
  }
  if (patch.start2 === null) {
    throw Error("patch not initialized");
  }
  var pattern = text2.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;
  while (text2.indexOf(pattern) != text2.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text2.substring(
      patch.start2 - padding,
      patch.start2 + patch.length1 + padding
    );
  }
  padding += this.Patch_Margin;
  if (patch.start2 - padding > 0 && diff_match_patch.prototype.isLowSurrogate(text2[patch.start2 - padding])) {
    padding++;
  }
  var prefix = text2.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
  }
  if (patch.start2 + patch.length1 + padding < text2.length && diff_match_patch.prototype.isHighSurrogate(text2[patch.start2 + patch.length1 + padding])) {
    padding++;
  }
  var suffix = text2.substring(
    patch.start2 + patch.length1,
    patch.start2 + patch.length1 + padding
  );
  if (suffix) {
    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
  }
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
    text1 = /** @type {string} */
    a;
    diffs = this.diff_main(
      text1,
      /** @type {string} */
      opt_b,
      true
    );
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
    a;
    text1 = this.diff_text1(diffs);
  } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
    text1 = /** @type {string} */
    a;
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
    opt_b;
  } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
    text1 = /** @type {string} */
    a;
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
    opt_c;
  } else {
    throw new Error("Unknown call format to patch_make.");
  }
  if (diffs.length === 0) {
    return [];
  }
  diffs = this.diff_cleanupSplitSurrogates(diffs);
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;
  var char_count1 = 0;
  var char_count2 = 0;
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];
    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }
    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }
  return patches;
};
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};
diff_match_patch.prototype.patch_apply = function(patches, text2) {
  if (patches.length == 0) {
    return [text2, []];
  }
  patches = this.patch_deepCopy(patches);
  var nullPadding = this.patch_addPadding(patches);
  text2 = nullPadding + text2 + nullPadding;
  this.patch_splitMax(patches);
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      start_loc = this.match_main(
        text2,
        text1.substring(0, this.Match_MaxBits),
        expected_loc
      );
      if (start_loc != -1) {
        end_loc = this.match_main(
          text2,
          text1.substring(text1.length - this.Match_MaxBits),
          expected_loc + text1.length - this.Match_MaxBits
        );
        if (end_loc == -1 || start_loc >= end_loc) {
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text2, text1, expected_loc);
    }
    if (start_loc == -1) {
      results[x] = false;
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      results[x] = true;
      delta = start_loc - expected_loc;
      var text22;
      if (end_loc == -1) {
        text22 = text2.substring(start_loc, start_loc + text1.length);
      } else {
        text22 = text2.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text22) {
        text2 = text2.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text2.substring(start_loc + text1.length);
      } else {
        var diffs = this.diff_main(text1, text22, false);
        if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {
              text2 = text2.substring(0, start_loc + index2) + mod[1] + text2.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {
              text2 = text2.substring(0, start_loc + index2) + text2.substring(start_loc + this.diff_xIndex(
                diffs,
                index1 + mod[1].length
              ));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  text2 = text2.substring(nullPadding.length, text2.length - nullPadding.length);
  return [text2, results];
};
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = "";
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.start1 -= paddingLength;
    patch.start2 -= paddingLength;
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }
  return nullPadding;
};
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = "";
    while (bigpatch.diffs.length !== 0) {
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== "") {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
      }
      while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          bigpatch.diffs.shift();
        } else {
          diff_text = diff_text.substring(
            0,
            patch_size - patch.length1 - this.Patch_Margin
          );
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      precontext = this.diff_text2(patch.diffs);
      precontext = precontext.substring(precontext.length - this.Patch_Margin);
      var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
      if (postcontext !== "") {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};
diff_match_patch.prototype.patch_toText = function(patches) {
  var text2 = [];
  for (var x = 0; x < patches.length; x++) {
    text2[x] = patches[x];
  }
  return text2.join("");
};
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text2 = textline.split("\n");
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text2.length) {
    var m = text2[textPointer].match(patchHeader);
    if (!m) {
      throw new Error("Invalid patch string: " + text2[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === "") {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == "0") {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }
    patch.start2 = parseInt(m[3], 10);
    if (m[4] === "") {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == "0") {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;
    while (textPointer < text2.length) {
      var sign = text2[textPointer].charAt(0);
      try {
        var line = decodeURI(text2[textPointer].substring(1));
      } catch (ex) {
        throw new Error("Illegal escape in patch_fromText: " + line);
      }
      if (sign == "-") {
        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
      } else if (sign == "+") {
        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
      } else if (sign == " ") {
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
      } else if (sign == "@") {
        break;
      } else if (sign === "") {
      } else {
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};
diff_match_patch.patch_obj = function() {
  this.diffs = [];
  this.start1 = null;
  this.start2 = null;
  this.length1 = 0;
  this.length2 = 0;
};
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ",0";
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = this.start1 + 1 + "," + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ",0";
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = this.start2 + 1 + "," + this.length2;
  }
  var text2 = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
  var op;
  diff_match_patch.prototype.diff_cleanupSplitSurrogates(this.diffs);
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = "+";
        break;
      case DIFF_DELETE:
        op = "-";
        break;
      case DIFF_EQUAL:
        op = " ";
        break;
    }
    text2[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
  }
  return text2.join("").replace(/%20/g, " ");
};

// node_modules/async-mutex/index.mjs
init_process_shim();
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _Semaphore = class _Semaphore {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      const task = { resolve, reject, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task);
      } else {
        this._queue.splice(i + 1, 0, task);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter) => waiter.resolve());
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
__name(_Semaphore, "Semaphore");
var Semaphore = _Semaphore;
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
__name(insertSorted, "insertSorted");
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
__name(findIndexFromEnd, "findIndexFromEnd");
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _Mutex = class _Mutex {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};
__name(_Mutex, "Mutex");
var Mutex = _Mutex;
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {
  return {
    acquire: /* @__PURE__ */ __name((weightOrPriority, priority) => {
      let weight;
      if (isSemaphore(sync)) {
        weight = weightOrPriority;
      } else {
        weight = void 0;
        priority = weightOrPriority;
      }
      if (weight !== void 0 && weight <= 0) {
        throw new Error(`invalid weight ${weight}: must be positive`);
      }
      return new Promise((resolve, reject) => __awaiter2(this, void 0, void 0, function* () {
        let isTimeout = false;
        const handle = setTimeout(() => {
          isTimeout = true;
          reject(timeoutError);
        }, timeout);
        try {
          const ticket = yield isSemaphore(sync) ? sync.acquire(weight, priority) : sync.acquire(priority);
          if (isTimeout) {
            const release = Array.isArray(ticket) ? ticket[1] : ticket;
            release();
          } else {
            clearTimeout(handle);
            resolve(ticket);
          }
        } catch (e) {
          if (!isTimeout) {
            clearTimeout(handle);
            reject(e);
          }
        }
      }));
    }, "acquire"),
    runExclusive(callback, weight, priority) {
      return __awaiter2(this, void 0, void 0, function* () {
        let release = /* @__PURE__ */ __name(() => void 0, "release");
        try {
          const ticket = yield this.acquire(weight, priority);
          if (Array.isArray(ticket)) {
            release = ticket[1];
            return yield callback(ticket[0]);
          } else {
            release = ticket;
            return yield callback();
          }
        } finally {
          release();
        }
      });
    },
    release(weight) {
      sync.release(weight);
    },
    cancel() {
      return sync.cancel();
    },
    waitForUnlock: /* @__PURE__ */ __name((weightOrPriority, priority) => {
      let weight;
      if (isSemaphore(sync)) {
        weight = weightOrPriority;
      } else {
        weight = void 0;
        priority = weightOrPriority;
      }
      if (weight !== void 0 && weight <= 0) {
        throw new Error(`invalid weight ${weight}: must be positive`);
      }
      return new Promise((resolve, reject) => {
        const handle = setTimeout(() => reject(timeoutError), timeout);
        (isSemaphore(sync) ? sync.waitForUnlock(weight, priority) : sync.waitForUnlock(priority)).then(() => {
          clearTimeout(handle);
          resolve();
        });
      });
    }, "waitForUnlock"),
    isLocked: /* @__PURE__ */ __name(() => sync.isLocked(), "isLocked"),
    getValue: /* @__PURE__ */ __name(() => sync.getValue(), "getValue"),
    setValue: /* @__PURE__ */ __name((value) => sync.setValue(value), "setValue")
  };
}
__name(withTimeout, "withTimeout");
function isSemaphore(sync) {
  return sync.getValue !== void 0;
}
__name(isSemaphore, "isSemaphore");
function tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {
  return withTimeout(sync, 0, alreadyAcquiredError);
}
__name(tryAcquire, "tryAcquire");

// src/services/notes/NoteHandler.ts
var import_debug6 = __toESM(require_browser2());
var import_obsidian8 = require("obsidian");
var CLOSED_FILE_SYNC_WAIT = 1e4;
var NOTE_YTEXT_NAME = "s.g:note:v0";
var _NoteHandler = class _NoteHandler {
  constructor(plugin, id, collectionId, onLoad, lifecycle) {
    this.plugin = plugin;
    this.id = id;
    this.collectionId = collectionId;
    this.onLoad = onLoad;
    this.log = (0, import_debug6.default)(`screen.garden:note:${id}`);
    this.log("init");
    this.lifecycle = {
      ...lifecycle,
      onJoin: /* @__PURE__ */ __name((_dc, joinReply) => {
        if (lifecycle.onJoin) lifecycle.onJoin(_dc, joinReply);
        this.plugin.db.pendingNotes.delete(this.id);
        if (joinReply && "new_path" in joinReply) {
          this.log(
            "path of %s changed on promotion to %s",
            this.id,
            joinReply.new_path
          );
          const path = this.plugin.collections.addPathPrefixForCollection(
            this.collectionId,
            joinReply.new_path
          );
          if (!path) return;
          const oldPath = this.path;
          this.path = path;
          this.plugin.db.notes.update(this.id, {
            path: this.path,
            title: getTitle(this.path)
          });
          new import_obsidian8.Notice(
            intl.note.renamedRemotely({ old: oldPath, new: this.path }),
            2e3
          );
        }
      }, "onJoin")
    };
    this.mutex = new Mutex();
    this.noteObserver = liveQuery(() => this.plugin.db.notes.get(this.id));
    this.pathSubscription = this.noteObserver.subscribe({
      next: /* @__PURE__ */ __name((note) => {
        if (!note) return;
        this.path = note.path;
      }, "next")
    });
    this.writeFileIfClosed = throttle_default(
      () => this._writeFileIfClosed(),
      CLOSED_FILE_SYNC_WAIT,
      { trailing: true, leading: false }
    );
    this._observer = this._observer.bind(this);
    this.onload();
  }
  async onload() {
    await this.hydrateYDocFromDisk();
    this.doc = await this.plugin.docs.getOrCreateAndLoad(
      this.id,
      {
        kind: "note",
        collection_id: this.collectionId
      },
      this.lifecycle
    );
    this.ytext = this.doc.ydoc.getText(NOTE_YTEXT_NAME);
    this.ytext.observe(this._observer);
    this.log("loaded doc %s", this.doc.id);
    this.onLoad();
  }
  async hydrateYDocFromDisk() {
    const isAlreadyPersisted = await this.plugin.docs.docIsPersisted(this.id);
    if (isAlreadyPersisted) return;
    const pendingNote = await this.plugin.db.pendingNotes.get(this.id);
    if (!pendingNote) return;
    const file = this.plugin.app.vault.getFileByPath(pendingNote.path);
    if (!file) return;
    const contents = await this.plugin.app.vault.read(file);
    const ydoc = new Doc();
    const ytext = ydoc.getText(NOTE_YTEXT_NAME);
    ytext.insert(0, contents);
    const provider = this.plugin.docs.persistedDoc(this.id, ydoc);
    await new Promise((resolve) => {
      provider.on("synced", resolve);
    });
    this.log("hydrated from %s", pendingNote.path);
  }
  async close() {
    this.writeFileIfClosed.flush();
    this.ytext.unobserve(this._observer);
    this.pathSubscription.unsubscribe();
    this.plugin.docs.unload(this.doc);
  }
  async getYTextHandle() {
    try {
      const release = await tryAcquire(this.mutex).acquire();
      return {
        release: /* @__PURE__ */ __name(() => {
          release();
          this.plugin.notes.downgrade(this.id, "concurrent");
        }, "release"),
        ytext: this.ytext
      };
    } catch (e) {
      return null;
    }
  }
  get ytextAcquired() {
    return this.mutex.isLocked();
  }
  /**
   * borrowYText returns the note's Y.Text for read-only purposes.
   * It does not attempt to acquire ownership of the Y.Text,
   * and the returned Y.Text should not be retained by the caller.
   * @returns Y.Text associated with the note's doc.
   */
  borrowYText() {
    return this.ytext;
  }
  updatePresence(meta) {
    this.doc.channel.pushPresence(meta);
  }
  listPresences() {
    return this.doc.channel.listPresences("userID");
  }
  async acceptExternalWrite(file) {
    if (this.mutex.isLocked()) return;
    const handle = await this.getYTextHandle();
    if (!handle) return;
    const ytext = handle.ytext;
    if (!ytext.doc) return;
    const yTextContents = ytext.toString();
    const diskContents = await this.plugin.app.vault.read(file);
    const diffMatchPatch = new diff_match_patch();
    const diffs = diffMatchPatch.diff_main(yTextContents, diskContents);
    diffMatchPatch.diff_cleanupEfficiency(diffs);
    if (diffs.length === 0) {
      this.log("external edit diff returned no changes; exiting.");
      return;
    }
    let position = 0;
    ytext.doc.transact(() => {
      for (const [op, chunk] of diffs) {
        if (op === DIFF_EQUAL) {
          position += chunk.length;
        } else if (op === DIFF_INSERT) {
          ytext.insert(position, chunk);
          position += chunk.length;
        } else if (op === DIFF_DELETE) {
          ytext.delete(position, chunk.length);
        }
      }
    });
    this.log(
      `Updated ${file.path} for external edit with ${diffs.length} diffs`
    );
    handle.release();
  }
  _observer(_event, _txn) {
    if (this.mutex.isLocked()) return;
    this.writeFileIfClosed();
  }
  // Eventually this will be part of a system to shepherd out-of-Obsidian file-side
  // edits into the ytext. For now, the ytext always wins.
  async _writeFileIfClosed() {
    var _a8;
    if (this.mutex.isLocked()) return;
    const file = this.plugin.app.vault.getFileByPath(this.path);
    if (!file) return;
    const fileContents = await this.plugin.app.vault.read(file);
    const yTextContents = this.ytext.toString();
    if (fileContents !== yTextContents) {
      (_a8 = this.plugin.collections.getHandler(this.collectionId)) == null ? void 0 : _a8.controlModify(this.path, async () => {
        await this.plugin.app.vault.modify(file, yTextContents, {
          mtime: (/* @__PURE__ */ new Date()).valueOf()
        });
      });
    }
  }
};
__name(_NoteHandler, "NoteHandler");
var NoteHandler = _NoteHandler;

// src/services/notes/HandlerPool.ts
var import_debug7 = __toESM(require_browser2());

// src/util/OrderedSet.ts
init_process_shim();
var _OrderedSet = class _OrderedSet {
  constructor(iterable) {
    this._set = new Set(iterable);
  }
  push(value) {
    this._set.add(value);
  }
  pop() {
    const v = this._set.values().next().value;
    if (v) {
      this._set.delete(v);
      return v;
    }
    return null;
  }
  get size() {
    return this._set.size;
  }
  clear() {
    this._set.clear();
  }
  delete(value) {
    return this._set.delete(value);
  }
};
__name(_OrderedSet, "OrderedSet");
var OrderedSet = _OrderedSet;

// src/services/notes/HandlerPool.ts
var log4 = (0, import_debug7.default)("screen.garden:notes:pool");
function overrides(left, right) {
  return left === "required" || left === "concurrent" && right === "background";
}
__name(overrides, "overrides");
var DEFAULT_CONCURRENT_TIMEOUT = 3e4;
var _HandlerPool = class _HandlerPool {
  constructor(plugin, _poolSize) {
    this.plugin = plugin;
    this._poolSize = _poolSize;
    /**
     * Emits when a handler is created or deleted.
     */
    this.handlerChanges = new Subject();
    this.queueSize$ = new BehaviorSubject({
      concurrent: 0,
      background: 0
    });
    this.openHandlers$ = new BehaviorSubject({
      required: 0,
      concurrent: 0,
      background: 0
    });
    this.poolSize$ = new BehaviorSubject(0);
    // Simplest just to statically create queues per priority.
    this.backgroundQueue = new OrderedSet();
    this.concurrentQueue = new OrderedSet();
    this.handlerSpecs = /* @__PURE__ */ new Map();
    this.timeouts = /* @__PURE__ */ new Map();
    // Map of note IDs to handlers.
    // Only populated with a handler when it has finished loading its corresponding ydoc.
    this.handlers = /* @__PURE__ */ new Map();
    // A set of note IDs corresponding to handlers that are starting but not yet ready.
    // Used to prevent handler creation races when notes rapidly change such that handlers
    // are created but not yet ready.
    this.startingHandlerIDs = /* @__PURE__ */ new Set();
    this.stats = combineLatest([
      this.openHandlers$.pipe(
        distinctUntilChanged((a, b) => {
          return a.required === b.required && a.concurrent === b.concurrent && a.background === b.background;
        })
      ),
      this.queueSize$.pipe(
        distinctUntilChanged((a, b) => {
          return a.concurrent === b.concurrent && a.background === b.background;
        })
      ),
      this.poolSize$.pipe(distinctUntilChanged())
    ]).pipe(map(([open, pending, size]) => ({ open, pending, size })));
  }
  /**
   * Close all handlers and clear all queues.
   *
   * Does not emit handler or queue change events.
   */
  clear() {
    log4("clear");
    this.backgroundQueue.clear();
    this.concurrentQueue.clear();
    for (const handler of this.handlers.values()) {
      handler.close();
    }
    this.handlers.clear();
    this.startingHandlerIDs.clear();
    this.handlerSpecs.clear();
    for (const timeout of this.timeouts.values()) {
      window.clearTimeout(timeout);
    }
    this.timeouts.clear();
    this.queueSize$.complete();
    this.openHandlers$.complete();
    this.poolSize$.complete();
  }
  /**
   * Requests that a note handler be opened. The handler will be opened according to its priority.
   *
   * Requesting a handler at a higher priority for a note that is already requested will upgrade
   * that note's priority.
   */
  schedule(spec) {
    log4("scheduling", spec);
    const existingSpec = this.handlerSpecs.get(spec.id);
    if (!existingSpec || overrides(spec.priority, existingSpec.priority)) {
      this.handlerSpecs.set(spec.id, spec);
    }
    if (spec.priority === "concurrent" && (this.handlers.has(spec.id) || this.startingHandlerIDs.has(spec.id))) {
      this.touchTimeout(spec.id);
    }
    const handler = this.handlers.get(spec.id);
    if (handler) {
      log4(`handler for ${spec.id} already running`);
      return handler;
    }
    if (this.startingHandlerIDs.has(spec.id)) return null;
    if (spec.priority === "required" || this.handlerCount < this.poolSize) {
      this.clearTimeout(spec.id);
      this.createHandler(spec);
    } else {
      const queue = spec.priority === "background" ? this.backgroundQueue : this.concurrentQueue;
      queue.push(spec.id);
      log4("queued %s", spec.id);
      this.emitQueueSize();
    }
    return null;
  }
  /**
   * Downgrades a handler's priority. If the handler is already at or below the new priority,
   * this is a no-op. If the handler is running and the new priority implies a timeout,
   * the timeout will begin.
   * @param id Note ID for handler.
   * @param priority New priority for handler.
   */
  downgrade(id, priority) {
    const runningHandler = this.handlers.get(id);
    if (runningHandler == null ? void 0 : runningHandler.ytextAcquired) {
      log4("cannot downgrade handler %s, ytext is locked", id);
      return;
    }
    log4("downgrading %s to %s", id, priority);
    const existingSpec = this.handlerSpecs.get(id);
    if (!existingSpec) return;
    if (overrides(priority, existingSpec.priority)) return;
    this.handlerSpecs.set(id, { ...existingSpec, priority });
    if (priority === "concurrent" && runningHandler) {
      this.touchTimeout(id);
    }
    this.emitOpenHandlers();
  }
  /**
   * Returns a handler for a note ID if it exists.
   * @param id Note ID for handler.
   * @returns NoteHandler, if once is running.
   */
  get(id) {
    var _a8;
    return (_a8 = this.handlers.get(id)) != null ? _a8 : null;
  }
  /**
   * Deletes the a handler if running and dequeues it if not.
   * Deleting a handler will also cancel any possible idle timeouts for that handler.
   * @param id Note ID for handler.
   */
  delete(id) {
    log4("deleting %s", id);
    this.deleteHandler(id);
    const existed = this.backgroundQueue.delete(id) || this.concurrentQueue.delete(id);
    if (existed) {
      this.emitQueueSize();
    }
  }
  get poolSize() {
    return this._poolSize;
  }
  set poolSize(size) {
    this._poolSize = size;
    this.poolSize$.next(size);
  }
  get handlerCount() {
    return this.handlers.size + this.startingHandlerIDs.size;
  }
  // Get the next note ID from the queue; prefers concurrent over background.
  pop() {
    if (this.concurrentQueue.size > 0) {
      return this.concurrentQueue.pop();
    } else if (this.backgroundQueue.size > 0) {
      return this.backgroundQueue.pop();
    }
    return null;
  }
  // Get the next note ID from the queue and, if present, create a handler for it.
  next() {
    if (this.handlerCount >= this.poolSize) return;
    const nextId = this.pop();
    if (!nextId) return;
    this.emitQueueSize();
    const spec = this.handlerSpecs.get(nextId);
    if (!spec) return;
    this.createHandler(spec);
  }
  createHandler({ id, path, collectionId }) {
    log4("starting handler %s", id);
    this.startingHandlerIDs.add(id);
    const handler = new NoteHandler(
      this.plugin,
      id,
      collectionId,
      () => {
        log4("finished loading handler %s, publishing availability", id);
        this.handlers.set(id, handler);
        this.emitOpenHandlers();
        this.startingHandlerIDs.delete(id);
        this.handlerChanges.next({
          id,
          path: path != null ? path : null,
          deleted: false
        });
      },
      {
        afterSync: /* @__PURE__ */ __name(async () => {
          this.onLifecycleChange(id);
        }, "afterSync"),
        onUpdate: /* @__PURE__ */ __name(async () => {
          this.onLifecycleChange(id);
        }, "onUpdate")
      }
    );
  }
  // Delete a handler.
  // NOTE: Will start a new handler if there is demand.
  deleteHandler(id) {
    const handler = this.handlers.get(id);
    if (!handler) return;
    const path = handler.path;
    log4("stopping handler", this.handlerSpecs.get(id));
    handler.close();
    this.handlers.delete(handler.id);
    this.handlerSpecs.delete(id);
    this.clearTimeout(id);
    this.handlerChanges.next({ id, path, deleted: true });
    this.emitOpenHandlers();
    this.next();
  }
  onLifecycleChange(id) {
    const spec = this.handlerSpecs.get(id);
    if (!spec || spec.priority === "required") return;
    if (spec.priority === "background") {
      this.deleteHandler(id);
    } else {
      this.touchTimeout(id);
    }
  }
  touchTimeout(id) {
    if (!this.handlerSpecs.has(id)) return;
    if (this.timeouts.has(id)) {
      window.clearTimeout(this.timeouts.get(id));
    }
    this.timeouts.set(
      id,
      window.setTimeout(() => {
        const spec = this.handlerSpecs.get(id);
        if (!spec || spec.priority !== "concurrent") return;
        log4("timeout for", spec);
        this.deleteHandler(id);
      }, DEFAULT_CONCURRENT_TIMEOUT)
    );
  }
  clearTimeout(id) {
    if (!this.timeouts.has(id)) return;
    window.clearTimeout(this.timeouts.get(id));
    this.timeouts.delete(id);
  }
  emitQueueSize() {
    this.queueSize$.next({
      concurrent: this.concurrentQueue.size,
      background: this.backgroundQueue.size
    });
  }
  emitOpenHandlers() {
    const openHandlers = {
      required: 0,
      concurrent: 0,
      background: 0
    };
    for (const id of this.handlers.keys()) {
      const spec = this.handlerSpecs.get(id);
      if (spec == null ? void 0 : spec.priority) {
        openHandlers[spec.priority]++;
      }
    }
    this.openHandlers$.next(openHandlers);
  }
};
__name(_HandlerPool, "HandlerPool");
var HandlerPool = _HandlerPool;

// src/services/notes/NoteService.ts
var TABLE4 = "id,path,collection_id";
var PENDING_TABLE = "id,path,collection_id";
var DEFAULT_POOL_SIZE = 10;
var _NotesService = class _NotesService extends Service {
  constructor(plugin) {
    super(plugin);
    this.destroy = new Subject();
    this.pool = new HandlerPool(plugin, DEFAULT_POOL_SIZE);
  }
  async onunload() {
    this.pool.clear();
    this.destroy.next();
    this.destroy.complete();
  }
  get handlerChanges() {
    return this.pool.handlerChanges;
  }
  set poolSize(size) {
    this.pool.poolSize = size;
  }
  get poolStats() {
    return this.pool.stats;
  }
  /**
   * Creates or updates one or more notes based on a list of how to create them.
   *
   * For each CreateNoteAttrs, we:
   * 1. Check if a note with that ID already exists.
   * 2. Schedule a handler for the note.
   * 3a. If the note existed, update its path and name in the db.
   * 3b. If the note did not exist, insert it into the db.
   * 4. If we're only creating a single note, return it for convenience.
   * @param newNotes A list of notes to create (or update).
   * @returns A created note if `newNotes` contains only one entry.
   */
  async create(newNotes) {
    var _a8;
    for (const newNote of newNotes) {
      const { path, collectionId, id, priority } = newNote;
      const existingNote = (_a8 = await this.plugin.db.notes.get(id)) != null ? _a8 : null;
      this.pool.schedule({
        id,
        collectionId,
        path,
        priority
      });
      if (existingNote) {
        await this.db.notes.update(id, {
          title: getTitle(path),
          path
        });
      } else {
        await this.db.notes.put({
          id,
          title: getTitle(path),
          path,
          collection_id: collectionId
        });
      }
      if (newNotes.length === 1) {
        const note = await this.db.notes.get(id);
        return note;
      }
    }
  }
  require(id, collectionId, path) {
    return this.pool.schedule({
      id,
      collectionId,
      path,
      priority: "required"
    });
  }
  catchup(id, path, collectionId) {
    return this.pool.schedule({
      id,
      collectionId,
      path,
      priority: "background"
    });
  }
  async get(id) {
    const note = await this.db.notes.get(id);
    return note != null ? note : null;
  }
  /**
   * borrowYText returns the Y.Text associated with the note ID
   * for read-only purposes.
   * It does not attempt to acquire ownership of the Y.Text,
   * and the returned Y.Text should not be retained by the caller.
   * @returns Y.Text associated with the identified note's doc.
   */
  borrowYText(id) {
    var _a8;
    const handler = this.pool.get(id);
    return (_a8 = handler == null ? void 0 : handler.borrowYText()) != null ? _a8 : null;
  }
  /**
   * ytextAcquired returns true if the Y.Text associated with the note ID
   * has been acquired for read-write purposes.
   * @returns true if the Y.Text has been acquired.
   */
  ytextAcquired(id) {
    var _a8;
    const handler = this.pool.get(id);
    return (_a8 = handler == null ? void 0 : handler.ytextAcquired) != null ? _a8 : false;
  }
  async delete(id) {
    this.pool.delete(id);
    await this.db.notes.delete(id);
  }
  async downgrade(id, priority) {
    this.pool.downgrade(id, priority);
  }
  updatePresence(id, meta) {
    const handler = this.pool.get(id);
    handler == null ? void 0 : handler.updatePresence(meta);
  }
  listPresences(id) {
    var _a8;
    const handler = this.pool.get(id);
    return (_a8 = handler == null ? void 0 : handler.listPresences()) != null ? _a8 : [];
  }
};
__name(_NotesService, "NotesService");
var NotesService = _NotesService;

// src/services/settings/SettingsService.ts
init_process_shim();

// src/services/settings/SettingsTab.ts
init_process_shim();

// src/services/views/View.tsx
init_process_shim();

// src/services/views/context/DefaultProviders.tsx
init_process_shim();

// src/services/views/context/AppContext.tsx
init_process_shim();
var import_react = __toESM(require_react());
var AppContext = (0, import_react.createContext)(void 0);

// src/services/views/context/PluginContext.tsx
init_process_shim();
var import_react2 = __toESM(require_react());
var PluginContext = (0, import_react2.createContext)(void 0);
var usePlugin = /* @__PURE__ */ __name(() => {
  return (0, import_react2.useContext)(PluginContext);
}, "usePlugin");

// src/services/views/context/DefaultProviders.tsx
var import_react3 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var DefaultProviders = /* @__PURE__ */ __name(({ app, plugin, children }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react3.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AppContext.Provider, { value: app, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PluginContext.Provider, { value: plugin, children }) }) }), "DefaultProviders");

// src/services/views/View.tsx
var import_obsidian9 = require("obsidian");
var import_react4 = __toESM(require_react());
var import_client = __toESM(require_client());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var _View = class _View extends import_obsidian9.ItemView {
  constructor(plugin, leaf) {
    super(leaf);
    this.plugin = plugin;
    this.root = null;
  }
  getViewType() {
    return this.constructor.ViewType();
  }
  createRoot(children) {
    this.root = (0, import_client.createRoot)(this.contentEl);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(DefaultProviders, { app: this.app, plugin: this.plugin, children })
    );
  }
  async onClose() {
    var _a8;
    (_a8 = this.root) == null ? void 0 : _a8.unmount();
  }
};
__name(_View, "View");
var View = _View;
function useObservable(obs, initial, deps = []) {
  const [value, setValue] = (0, import_react4.useState)(initial);
  (0, import_react4.useEffect)(() => {
    const subscription = obs.subscribe({
      next: /* @__PURE__ */ __name((v) => {
        setValue(v);
      }, "next")
    });
    return () => {
      subscription.unsubscribe();
    };
  }, deps);
  return value;
}
__name(useObservable, "useObservable");

// src/services/settings/SettingsTab.ts
var import_debug8 = __toESM(require_browser2());
var import_obsidian10 = require("obsidian");
var log5 = (0, import_debug8.default)("screen.garden:settings:tab");
var _SettingsTab = class _SettingsTab extends import_obsidian10.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.loginDetails = null;
    log5("initializing");
    this.subscription = combineLatest([
      this.plugin.account.observable
    ]).subscribe(() => {
      this.display();
    });
    this.plugin.register(this.subscription.unsubscribe);
  }
  display() {
    var _a8;
    const config2 = this.plugin.settings.config;
    const account = this.plugin.account.get();
    const teams = this.plugin.teams.get();
    const team = teams ? (_a8 = [...teams].sort((a, b) => b.seat_count - a.seat_count).first()) != null ? _a8 : null : null;
    log5("rendering");
    log5("config: %o, account: %o", config2, account);
    const { containerEl: container } = this;
    container.empty();
    new import_obsidian10.Setting(container).setName(intl.settingsTab.homeSettingName()).setDesc(intl.settingsTab.homeSettingDesc()).addButton(
      (button) => button.setButtonText(intl.settingsTab.showHomeTab()).onClick(() => {
        this.plugin.views.revealView("screengarden:views:home" /* Home */);
      })
    );
    if ((config2 == null ? void 0 : config2.token) == null) {
      this.addLoggedOutState(container);
    } else {
      this.addLoggedInState(container, { account, team });
    }
  }
  addLoggedOutState(container) {
    new import_obsidian10.Setting(container).setName(intl.settingsTab.accountSettingName()).setDesc(intl.settingsTab.accountSettingsDesc());
    new import_obsidian10.Setting(container).addButton(
      (button) => button.setButtonText(intl.settingsTab.loginButton()).onClick(() => {
        this.plugin.account.startAuth(
          "login",
          this.showLoginDetails.bind(this)
        );
      })
    ).addButton(
      (button) => button.setButtonText(intl.settingsTab.createAccountButton()).setCta().onClick(() => {
        this.plugin.account.startAuth(
          "register",
          this.showLoginDetails.bind(this)
        );
      })
    );
    this.loginDetails = container.createEl("p");
    this.loginDetails.classList.add("text-center");
    this.loginDetails.hidden = true;
  }
  showLoginDetails(url) {
    if (!this.loginDetails) return;
    this.loginDetails.hidden = false;
    this.loginDetails.innerHTML = intl.settingsTab.loginDetailsRaw({ url });
  }
  addLoggedInState(container, { account, team }) {
    new import_obsidian10.Setting(container).setName(intl.settingsTab.accountSettingName()).setDesc(intl.settingsTab.loggedIn({ email: account == null ? void 0 : account.email }));
    new import_obsidian10.Setting(container).addButton(
      (button) => button.setButtonText(intl.settingsTab.logOutButton()).onClick(async () => {
        await this.plugin.settings.updateConfig({ token: null });
        await this.plugin.db.reset();
        this.display();
      })
    ).addButton(
      (button) => button.setButtonText(intl.settingsTab.manageAccountButton()).setCta().onClick(() => {
        window.open(
          `${BASE_HTTP_URL}/t/${team == null ? void 0 : team.short_id}/settings/account`,
          "_external"
        );
      })
    );
    new import_obsidian10.Setting(container).setName(intl.settingsTab.ui.header()).setHeading();
    new import_obsidian10.Setting(container).setName(intl.settingsTab.ui.folderBorders.name()).setDesc(intl.settingsTab.ui.folderBorders.desc()).addToggle((cb) => {
      var _a8, _b;
      cb.setValue((_b = (_a8 = this.plugin.settings.config) == null ? void 0 : _a8.showFolderLines) != null ? _b : false);
      cb.onChange((value) => {
        this.plugin.settings.updateConfig({ showFolderLines: value });
      });
    });
    new import_obsidian10.Setting(container).setName(intl.settingsTab.ui.folderIcons.name()).setDesc(intl.settingsTab.ui.folderIcons.desc()).addToggle((cb) => {
      var _a8, _b;
      cb.setValue((_b = (_a8 = this.plugin.settings.config) == null ? void 0 : _a8.showFolderIcons) != null ? _b : false);
      cb.onChange((value) => {
        this.plugin.settings.updateConfig({ showFolderIcons: value });
      });
    });
    new import_obsidian10.Setting(container).setName(intl.settingsTab.ui.statusIcon.name()).setDesc(intl.settingsTab.ui.statusIcon.desc()).addToggle((cb) => {
      var _a8, _b;
      cb.setValue((_b = (_a8 = this.plugin.settings.config) == null ? void 0 : _a8.showStatusIcon) != null ? _b : false);
      cb.onChange((value) => {
        this.plugin.settings.updateConfig({ showStatusIcon: value });
      });
    });
  }
};
__name(_SettingsTab, "SettingsTab");
var SettingsTab = _SettingsTab;

// src/services/settings/SettingsService.ts
var import_debug9 = __toESM(require_browser2());
var import_obsidian11 = require("obsidian");
var SETTINGS_ID = "settings";
var TABLE5 = "id,token";
var DEFAULT_SETTINGS = {
  id: SETTINGS_ID,
  token: null,
  showFolderLines: true,
  showFolderIcons: true,
  showStatusIcon: true
};
var log6 = (0, import_debug9.default)("screen.garden:settings");
var _SettingsService = class _SettingsService extends Service {
  constructor(plugin) {
    super(plugin);
    this.config = null;
    this.observable = liveQuery(
      () => this.db.settings.get(SETTINGS_ID)
    );
    this.tokenObservable = from(this.observable).pipe(
      map((settings) => {
        var _a8;
        return (_a8 = settings == null ? void 0 : settings.token) != null ? _a8 : null;
      }),
      distinctUntilChanged()
    );
    this.subscribe((config2) => {
      if (config2 == null) return;
      log6("config updated: %o", config2);
      this.config = config2;
    });
  }
  async onload() {
    if (!await this.db.settings.get(SETTINGS_ID)) {
      log6("settings missing, saving defaults");
      await this.db.settings.put(DEFAULT_SETTINGS);
    }
    this.plugin.addCommand({
      id: "toggle-debug-logging",
      name: intl.settingsTab.toggleDebugCommand(),
      callback: /* @__PURE__ */ __name(() => {
        const v = localStorage.getItem("debug");
        if (v) {
          localStorage.removeItem("debug");
          new import_obsidian11.Notice(intl.settingsTab.debugToggledNotice({ state: "off" }));
        } else {
          localStorage.setItem("debug", "screen.garden:*");
          new import_obsidian11.Notice(intl.settingsTab.debugToggledNotice({ state: "on" }));
        }
      }, "callback")
    });
  }
  async onLayoutReady() {
    this.plugin.addSettingTab(new SettingsTab(this.plugin.app, this.plugin));
  }
  subscribe(cb) {
    const subscription = this.observable.subscribe({
      next(settings) {
        if (settings) cb(settings);
      }
    });
    this.register(() => subscription.unsubscribe());
  }
  async updateConfig(update) {
    if (this.config == null)
      throw new Error("Cannot update config before it is loaded");
    const config2 = {
      ...this.config,
      ...update,
      id: SETTINGS_ID
    };
    await this.plugin.db.settings.put(config2);
    return config2;
  }
};
__name(_SettingsService, "SettingsService");
var SettingsService = _SettingsService;

// src/services/teams/TeamsService.ts
init_process_shim();
var import_debug10 = __toESM(require_browser2());
var TABLE6 = "id,plan";
var log7 = (0, import_debug10.default)("screen.garden:teams");
var _TeamsService = class _TeamsService extends Service {
  constructor(plugin) {
    super(plugin);
    this._teams = null;
    this.subscription = this.plugin.api.observable.subscribe({
      next: /* @__PURE__ */ __name(async (api) => {
        if (api == null) return;
        this.getTeams(api);
      }, "next")
    });
  }
  async onunload() {
    this.subscription.unsubscribe();
  }
  get() {
    return this._teams;
  }
  async loadTeams() {
    const api = this.plugin.api.client;
    if (!api) return;
    this.getTeams(api);
  }
  async getTeams(api) {
    const {
      data: { data: teams }
    } = await api.get("/teams");
    this._teams = teams;
    log7("teams %o", teams);
    await this.db.teams.bulkPut(teams);
  }
};
__name(_TeamsService, "TeamsService");
var TeamsService = _TeamsService;

// src/db/Database.ts
var import_debug11 = __toESM(require_browser2());
var log8 = (0, import_debug11.default)("screen.garden:db");
var _Database = class _Database extends import_wrapper_default {
  constructor(appId) {
    super(`screen.garden:${appId}`);
    log8("initializing database");
    this.version(1).stores({
      settings: TABLE5,
      account: TABLE,
      collections: TABLE2,
      collectionSettings: SETTINGS_TABLE,
      teams: TABLE6,
      docs: TABLE3,
      notes: TABLE4,
      pendingNotes: PENDING_TABLE
    });
    this.settings = this.table("settings");
    this.account = this.table("account");
    this.collections = this.table("collections");
    this.collectionSettings = this.table("collectionSettings");
    this.teams = this.table("teams");
    this.docs = this.table("docs");
    this.notes = this.table("notes");
    this.pendingNotes = this.table("pendingNotes");
  }
  async reset() {
    await Promise.all([
      this.settings.clear(),
      this.account.clear(),
      this.collections.clear(),
      this.collectionSettings.clear(),
      this.teams.clear(),
      this.docs.clear(),
      this.notes.clear(),
      this.pendingNotes.clear()
    ]);
  }
};
__name(_Database, "Database");
var Database = _Database;

// src/services/index.ts
init_process_shim();

// src/services/protocols/index.ts
init_process_shim();

// src/services/protocols/ProtocolHandlerService.ts
init_process_shim();
var import_debug12 = __toESM(require_browser2());
var _ProtocolHandlerService = class _ProtocolHandlerService extends Service {
  async onload() {
    const log16 = (0, import_debug12.default)("screen.garden:protocols");
    log16("registering protocol handlers");
    this.plugin.registerObsidianProtocolHandler(
      "screengarden-login",
      this.handleLogin.bind(this)
    );
  }
  async handleLogin(params2) {
    const log16 = (0, import_debug12.default)("screen.garden:protocols:login");
    log16("starting");
    if (!params2["token"]) {
      log16("missing token in login protocol handler");
      return;
    }
    log16("setting token");
    await this.plugin.settings.updateConfig({ token: params2["token"] });
    log16("done");
  }
};
__name(_ProtocolHandlerService, "ProtocolHandlerService");
var ProtocolHandlerService = _ProtocolHandlerService;

// src/services/settings/index.ts
init_process_shim();

// src/services/networkStatus/index.ts
init_process_shim();

// src/services/networkStatus/NetworkStatusService.ts
init_process_shim();
var import_debug13 = __toESM(require_browser2());
var log9 = (0, import_debug13.default)("screen.garden:network");
var _NetworkStatusService = class _NetworkStatusService extends Service {
  constructor(plugin) {
    super(plugin);
    this.online = true;
    this.observable = new Subject();
    log9("registering event listeners");
    this.plugin.registerDomEvent(window, "online", () => {
      log9("online");
      this.online = true;
      this.observable.next("online");
    });
    this.plugin.registerDomEvent(window, "offline", () => {
      log9("offline");
      this.online = false;
      this.observable.next("offline");
    });
  }
  async onload() {
    this.online = navigator.onLine;
    this.observable.next(this.online ? "online" : "offline");
  }
  async onunload() {
    this.observable.complete();
  }
};
__name(_NetworkStatusService, "NetworkStatusService");
var NetworkStatusService = _NetworkStatusService;

// src/services/account/index.ts
init_process_shim();

// src/services/api/index.ts
init_process_shim();

// src/services/api/ApiService.ts
init_process_shim();

// node_modules/axios/index.js
init_process_shim();

// node_modules/axios/lib/axios.js
init_process_shim();

// node_modules/axios/lib/utils.js
init_process_shim();

// node_modules/axios/lib/helpers/bind.js
init_process_shim();
function bind2(fn, thisArg) {
  return /* @__PURE__ */ __name(function wrap() {
    return fn.apply(thisArg, arguments);
  }, "wrap");
}
__name(bind2, "bind");

// node_modules/axios/lib/utils.js
var { toString: toString2 } = Object.prototype;
var { getPrototypeOf: getPrototypeOf2 } = Object;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = /* @__PURE__ */ __name((type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
}, "kindOfTest");
var typeOfTest = /* @__PURE__ */ __name((type) => (thing) => typeof thing === type, "typeOfTest");
var { isArray: isArray5 } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer2(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction3(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
__name(isBuffer2, "isBuffer");
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
__name(isArrayBufferView, "isArrayBufferView");
var isString = typeOfTest("string");
var isFunction3 = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject2 = /* @__PURE__ */ __name((thing) => thing !== null && typeof thing === "object", "isObject");
var isBoolean = /* @__PURE__ */ __name((thing) => thing === true || thing === false, "isBoolean");
var isPlainObject = /* @__PURE__ */ __name((val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf2(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}, "isPlainObject");
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = /* @__PURE__ */ __name((val) => isObject2(val) && isFunction3(val.pipe), "isStream");
var isFormData = /* @__PURE__ */ __name((thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction3(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction3(thing.toString) && thing.toString() === "[object FormData]"));
}, "isFormData");
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = /* @__PURE__ */ __name((str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), "trim");
function forEach2(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray5(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys3 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys3.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys3[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
__name(forEach2, "forEach");
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys3 = Object.keys(obj);
  let i = keys3.length;
  let _key;
  while (i-- > 0) {
    _key = keys3[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
__name(findKey, "findKey");
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = /* @__PURE__ */ __name((context2) => !isUndefined(context2) && context2 !== _global, "isContextDefined");
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = /* @__PURE__ */ __name((val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray5(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }, "assignValue");
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach2(arguments[i], assignValue);
  }
  return result;
}
__name(merge, "merge");
var extend = /* @__PURE__ */ __name((a, b, thisArg, { allOwnKeys } = {}) => {
  forEach2(b, (val, key) => {
    if (thisArg && isFunction3(val)) {
      a[key] = bind2(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
}, "extend");
var stripBOM = /* @__PURE__ */ __name((content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}, "stripBOM");
var inherits = /* @__PURE__ */ __name((constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}, "inherits");
var toFlatObject = /* @__PURE__ */ __name((sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf2(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}, "toFlatObject");
var endsWith = /* @__PURE__ */ __name((str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}, "endsWith");
var toArray = /* @__PURE__ */ __name((thing) => {
  if (!thing) return null;
  if (isArray5(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}, "toArray");
var isTypedArray2 = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf2(Uint8Array));
var forEachEntry = /* @__PURE__ */ __name((obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator2 = generator.call(obj);
  let result;
  while ((result = iterator2.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}, "forEachEntry");
var matchAll = /* @__PURE__ */ __name((regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
}, "matchAll");
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = /* @__PURE__ */ __name((str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    /* @__PURE__ */ __name(function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }, "replacer")
  );
}, "toCamelCase");
var hasOwnProperty10 = (({ hasOwnProperty: hasOwnProperty11 }) => (obj, prop) => hasOwnProperty11.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = /* @__PURE__ */ __name((obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach2(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
}, "reduceDescriptors");
var freezeMethods = /* @__PURE__ */ __name((obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction3(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction3(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
}, "freezeMethods");
var toObjectSet = /* @__PURE__ */ __name((arrayOrString, delimiter) => {
  const obj = {};
  const define2 = /* @__PURE__ */ __name((arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  }, "define");
  isArray5(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
}, "toObjectSet");
var noop3 = /* @__PURE__ */ __name(() => {
}, "noop");
var toFiniteNumber = /* @__PURE__ */ __name((value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}, "toFiniteNumber");
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = /* @__PURE__ */ __name((size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length3 } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length3 | 0];
  }
  return str;
}, "generateString");
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction3(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
__name(isSpecCompliantForm, "isSpecCompliantForm");
var toJSONObject = /* @__PURE__ */ __name((obj) => {
  const stack = new Array(10);
  const visit = /* @__PURE__ */ __name((source, i) => {
    if (isObject2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray5(source) ? [] : {};
        forEach2(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  }, "visit");
  return visit(obj, 0);
}, "toJSONObject");
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = /* @__PURE__ */ __name((thing) => thing && (isObject2(thing) || isFunction3(thing)) && isFunction3(thing.then) && isFunction3(thing.catch), "isThenable");
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction3(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof import_browser.default !== "undefined" && import_browser.default.nextTick || _setImmediate;
var utils_default = {
  isArray: isArray5,
  isArrayBuffer,
  isBuffer: isBuffer2,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject2,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction3,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray2,
  isFileList,
  forEach: forEach2,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty10,
  hasOwnProp: hasOwnProperty10,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop3,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

// node_modules/axios/lib/core/Axios.js
init_process_shim();

// node_modules/axios/lib/helpers/buildURL.js
init_process_shim();

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
init_process_shim();

// node_modules/axios/lib/helpers/toFormData.js
init_process_shim();

// node_modules/axios/lib/core/AxiosError.js
init_process_shim();
function AxiosError(message, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
__name(AxiosError, "AxiosError");
utils_default.inherits(AxiosError, Error, {
  toJSON: /* @__PURE__ */ __name(function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }, "toJSON")
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, /* @__PURE__ */ __name(function filter2(obj) {
    return obj !== Error.prototype;
  }, "filter"), (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
init_process_shim();
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
__name(isVisitable, "isVisitable");
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
__name(removeBrackets, "removeBrackets");
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(/* @__PURE__ */ __name(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }, "each")).join(dots ? "." : "");
}
__name(renderKey, "renderKey");
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
__name(isFlatArray, "isFlatArray");
var predicates = utils_default.toFlatObject(utils_default, {}, null, /* @__PURE__ */ __name(function filter(prop) {
  return /^is[A-Z]/.test(prop);
}, "filter"));
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, /* @__PURE__ */ __name(function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  }, "defined"));
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  __name(convertValue, "convertValue");
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(/* @__PURE__ */ __name(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        }, "each"));
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  __name(defaultVisitor, "defaultVisitor");
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, /* @__PURE__ */ __name(function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    }, "each"));
    stack.pop();
  }
  __name(build, "build");
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
__name(toFormData, "toFormData");
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, /* @__PURE__ */ __name(function replacer(match) {
    return charMap[match];
  }, "replacer"));
}
__name(encode, "encode");
function AxiosURLSearchParams(params2, options) {
  this._pairs = [];
  params2 && toFormData_default(params2, this, options);
}
__name(AxiosURLSearchParams, "AxiosURLSearchParams");
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = /* @__PURE__ */ __name(function append2(name, value) {
  this._pairs.push([name, value]);
}, "append");
prototype2.toString = /* @__PURE__ */ __name(function toString3(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(/* @__PURE__ */ __name(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "each"), "").join("&");
}, "toString");
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
__name(encode2, "encode");
function buildURL(url, params2, options) {
  if (!params2) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params2, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params2) ? params2.toString() : new AxiosURLSearchParams_default(params2, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
__name(buildURL, "buildURL");

// node_modules/axios/lib/core/InterceptorManager.js
init_process_shim();
var _InterceptorManager = class _InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, /* @__PURE__ */ __name(function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    }, "forEachHandler"));
  }
};
__name(_InterceptorManager, "InterceptorManager");
var InterceptorManager = _InterceptorManager;
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/core/dispatchRequest.js
init_process_shim();

// node_modules/axios/lib/core/transformData.js
init_process_shim();

// node_modules/axios/lib/defaults/index.js
init_process_shim();

// node_modules/axios/lib/defaults/transitional.js
init_process_shim();
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
init_process_shim();

// node_modules/axios/lib/platform/index.js
init_process_shim();

// node_modules/axios/lib/platform/browser/index.js
init_process_shim();

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
init_process_shim();
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
init_process_shim();
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
init_process_shim();
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
init_process_shim();
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: /* @__PURE__ */ __name(function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }, "visitor")
  }, options));
}
__name(toURLEncodedForm, "toURLEncodedForm");

// node_modules/axios/lib/helpers/formDataToJSON.js
init_process_shim();
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
__name(parsePropPath, "parsePropPath");
function arrayToObject(arr) {
  const obj = {};
  const keys3 = Object.keys(arr);
  let i;
  const len = keys3.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys3[i];
    obj[key] = arr[key];
  }
  return obj;
}
__name(arrayToObject, "arrayToObject");
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  __name(buildPath, "buildPath");
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
__name(formDataToJSON, "formDataToJSON");
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
__name(stringifySafely, "stringifySafely");
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [/* @__PURE__ */ __name(function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }, "transformRequest")],
  transformResponse: [/* @__PURE__ */ __name(function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }, "transformResponse")],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: /* @__PURE__ */ __name(function validateStatus(status) {
    return status >= 200 && status < 300;
  }, "validateStatus"),
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/core/AxiosHeaders.js
init_process_shim();

// node_modules/axios/lib/helpers/parseHeaders.js
init_process_shim();
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = /* @__PURE__ */ __name((rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(/* @__PURE__ */ __name(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  }, "parser"));
  return parsed;
}, "default");

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
__name(normalizeHeader, "normalizeHeader");
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
__name(normalizeValue, "normalizeValue");
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
__name(parseTokens, "parseTokens");
var isValidHeaderName = /* @__PURE__ */ __name((str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim()), "isValidHeaderName");
function matchHeaderValue(context2, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
__name(matchHeaderValue, "matchHeaderValue");
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
__name(formatHeader, "formatHeader");
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: /* @__PURE__ */ __name(function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      }, "value"),
      configurable: true
    });
  });
}
__name(buildAccessors, "buildAccessors");
var _AxiosHeaders = class _AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    __name(setHeader, "setHeader");
    const setHeaders = /* @__PURE__ */ __name((headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite)), "setHeaders");
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    __name(deleteHeader, "deleteHeader");
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys3 = Object.keys(this);
    let i = keys3.length;
    let deleted = false;
    while (i--) {
      const key = keys3[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    __name(defineAccessor, "defineAccessor");
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
__name(_AxiosHeaders, "AxiosHeaders");
var AxiosHeaders = _AxiosHeaders;
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: /* @__PURE__ */ __name(() => value, "get"),
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context2 = response || config2;
  const headers = AxiosHeaders_default.from(context2.headers);
  let data = context2.data;
  utils_default.forEach(fns, /* @__PURE__ */ __name(function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  }, "transform"));
  headers.normalize();
  return data;
}
__name(transformData, "transformData");

// node_modules/axios/lib/cancel/isCancel.js
init_process_shim();
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
__name(isCancel, "isCancel");

// node_modules/axios/lib/cancel/CanceledError.js
init_process_shim();
function CanceledError(message, config2, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
__name(CanceledError, "CanceledError");
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/adapters/adapters.js
init_process_shim();

// node_modules/axios/lib/adapters/xhr.js
init_process_shim();

// node_modules/axios/lib/core/settle.js
init_process_shim();
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
__name(settle, "settle");

// node_modules/axios/lib/helpers/parseProtocol.js
init_process_shim();
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
__name(parseProtocol, "parseProtocol");

// node_modules/axios/lib/helpers/progressEventReducer.js
init_process_shim();

// node_modules/axios/lib/helpers/speedometer.js
init_process_shim();
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return /* @__PURE__ */ __name(function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  }, "push");
}
__name(speedometer, "speedometer");
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
init_process_shim();
function throttle2(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer2;
  const invoke = /* @__PURE__ */ __name((args2, now2 = Date.now()) => {
    timestamp = now2;
    lastArgs = null;
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
    fn.apply(null, args2);
  }, "invoke");
  const throttled = /* @__PURE__ */ __name((...args2) => {
    const now2 = Date.now();
    const passed = now2 - timestamp;
    if (passed >= threshold) {
      invoke(args2, now2);
    } else {
      lastArgs = args2;
      if (!timer2) {
        timer2 = setTimeout(() => {
          timer2 = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  }, "throttled");
  const flush = /* @__PURE__ */ __name(() => lastArgs && invoke(lastArgs), "flush");
  return [throttled, flush];
}
__name(throttle2, "throttle");
var throttle_default2 = throttle2;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = /* @__PURE__ */ __name((listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default2((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
}, "progressEventReducer");
var progressEventDecorator = /* @__PURE__ */ __name((total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}, "progressEventDecorator");
var asyncDecorator = /* @__PURE__ */ __name((fn) => (...args2) => utils_default.asap(() => fn(...args2)), "asyncDecorator");

// node_modules/axios/lib/helpers/resolveConfig.js
init_process_shim();

// node_modules/axios/lib/helpers/isURLSameOrigin.js
init_process_shim();
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
init_process_shim();
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/core/buildFullPath.js
init_process_shim();

// node_modules/axios/lib/helpers/isAbsoluteURL.js
init_process_shim();
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
__name(isAbsoluteURL, "isAbsoluteURL");

// node_modules/axios/lib/helpers/combineURLs.js
init_process_shim();
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
__name(combineURLs, "combineURLs");

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
__name(buildFullPath, "buildFullPath");

// node_modules/axios/lib/core/mergeConfig.js
init_process_shim();
var headersToObject = /* @__PURE__ */ __name((thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing, "headersToObject");
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  __name(getMergedValue, "getMergedValue");
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  __name(mergeDeepProperties, "mergeDeepProperties");
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  __name(valueFromConfig2, "valueFromConfig2");
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  __name(defaultToConfig2, "defaultToConfig2");
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  __name(mergeDirectKeys, "mergeDirectKeys");
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: /* @__PURE__ */ __name((a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true), "headers")
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), /* @__PURE__ */ __name(function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  }, "computeConfigValue"));
  return config3;
}
__name(mergeConfig, "mergeConfig");

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = /* @__PURE__ */ __name((config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
}, "default");

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(/* @__PURE__ */ __name(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    __name(done, "done");
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(/* @__PURE__ */ __name(function _resolve(value) {
        resolve(value);
        done();
      }, "_resolve"), /* @__PURE__ */ __name(function _reject(err) {
        reject(err);
        done();
      }, "_reject"), response);
      request = null;
    }
    __name(onloadend, "onloadend");
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = /* @__PURE__ */ __name(function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      }, "handleLoad");
    }
    request.onabort = /* @__PURE__ */ __name(function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request));
      request = null;
    }, "handleAbort");
    request.onerror = /* @__PURE__ */ __name(function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request));
      request = null;
    }, "handleError");
    request.ontimeout = /* @__PURE__ */ __name(function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    }, "handleTimeout");
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), /* @__PURE__ */ __name(function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      }, "setRequestHeader"));
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = /* @__PURE__ */ __name((cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request) : cancel);
        request.abort();
        request = null;
      }, "onCanceled");
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  }, "dispatchXhrRequest"));
};

// node_modules/axios/lib/adapters/fetch.js
init_process_shim();

// node_modules/axios/lib/helpers/composeSignals.js
init_process_shim();
var composeSignals = /* @__PURE__ */ __name((signals, timeout) => {
  const { length: length3 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length3) {
    let controller = new AbortController();
    let aborted;
    const onabort = /* @__PURE__ */ __name(function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    }, "onabort");
    let timer2 = timeout && setTimeout(() => {
      timer2 = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = /* @__PURE__ */ __name(() => {
      if (signals) {
        timer2 && clearTimeout(timer2);
        timer2 = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    }, "unsubscribe");
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
}, "composeSignals");
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
init_process_shim();
var streamChunk = /* @__PURE__ */ __name(function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
}, "streamChunk");
var readBytes = /* @__PURE__ */ __name(async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
}, "readBytes");
var readStream = /* @__PURE__ */ __name(async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
}, "readStream");
var trackStream = /* @__PURE__ */ __name((stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = /* @__PURE__ */ __name((e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }, "_onFinish");
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
}, "trackStream");

// node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = /* @__PURE__ */ __name((fn, ...args2) => {
  try {
    return !!fn(...args2);
  } catch (e) {
    return false;
  }
}, "test");
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config2) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
var getBodyLength = /* @__PURE__ */ __name(async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
}, "getBodyLength");
var resolveBodyLength = /* @__PURE__ */ __name(async (headers, body) => {
  const length3 = utils_default.toFiniteNumber(headers.getContentLength());
  return length3 == null ? getBodyLength(body) : length3;
}, "resolveBodyLength");
var fetch_default = isFetchSupported && (async (config2) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config2, request);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = /* @__PURE__ */ __name((reason) => `- ${reason}`, "renderReason");
var isResolvedHandle = /* @__PURE__ */ __name((adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false, "isResolvedHandle");
var adapters_default = {
  getAdapter: /* @__PURE__ */ __name((adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length3 } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length3; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length3 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  }, "getAdapter"),
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
__name(throwIfCancellationRequested, "throwIfCancellationRequested");
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
  return adapter(config2).then(/* @__PURE__ */ __name(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, "onAdapterResolution"), /* @__PURE__ */ __name(function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  }, "onAdapterRejection"));
}
__name(dispatchRequest, "dispatchRequest");

// node_modules/axios/lib/helpers/validator.js
init_process_shim();

// node_modules/axios/lib/env/data.js
init_process_shim();
var VERSION = "1.7.9";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = /* @__PURE__ */ __name(function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  }, "validator");
});
var deprecatedWarnings = {};
validators.transitional = /* @__PURE__ */ __name(function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  __name(formatMessage, "formatMessage");
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
}, "transitional");
validators.spelling = /* @__PURE__ */ __name(function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
}, "spelling");
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys3 = Object.keys(options);
  let i = keys3.length;
  while (i-- > 0) {
    const opt = keys3[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
__name(assertOptions, "assertOptions");
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var _Axios = class _Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    validator_default.assertOptions(config2, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(/* @__PURE__ */ __name(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    }, "unshiftRequestInterceptors"));
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(/* @__PURE__ */ __name(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    }, "pushResponseInterceptors"));
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
__name(_Axios, "Axios");
var Axios = _Axios;
utils_default.forEach(["delete", "get", "head", "options"], /* @__PURE__ */ __name(function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
}, "forEachMethodNoData"));
utils_default.forEach(["post", "put", "patch"], /* @__PURE__ */ __name(function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return /* @__PURE__ */ __name(function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    }, "httpMethod");
  }
  __name(generateHTTPMethod, "generateHTTPMethod");
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
}, "forEachMethodWithData"));
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
init_process_shim();
var _CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(/* @__PURE__ */ __name(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    }, "promiseExecutor"));
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = /* @__PURE__ */ __name(function reject() {
        token.unsubscribe(_resolve);
      }, "reject");
      return promise;
    };
    executor(/* @__PURE__ */ __name(function cancel(message, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config2, request);
      resolvePromise(token.reason);
    }, "cancel"));
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = /* @__PURE__ */ __name((err) => {
      controller.abort(err);
    }, "abort");
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(/* @__PURE__ */ __name(function executor(c) {
      cancel = c;
    }, "executor"));
    return {
      token,
      cancel
    };
  }
};
__name(_CancelToken, "CancelToken");
var CancelToken = _CancelToken;
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
init_process_shim();
function spread(callback) {
  return /* @__PURE__ */ __name(function wrap(arr) {
    return callback.apply(null, arr);
  }, "wrap");
}
__name(spread, "spread");

// node_modules/axios/lib/helpers/isAxiosError.js
init_process_shim();
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}
__name(isAxiosError, "isAxiosError");

// node_modules/axios/lib/helpers/HttpStatusCode.js
init_process_shim();
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context2 = new Axios_default(defaultConfig);
  const instance = bind2(Axios_default.prototype.request, context2);
  utils_default.extend(instance, Axios_default.prototype, context2, { allOwnKeys: true });
  utils_default.extend(instance, context2, null, { allOwnKeys: true });
  instance.create = /* @__PURE__ */ __name(function create7(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  }, "create");
  return instance;
}
__name(createInstance, "createInstance");
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = /* @__PURE__ */ __name(function all2(promises) {
  return Promise.all(promises);
}, "all");
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all3,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// src/services/api/ApiService.ts
var import_debug14 = __toESM(require_browser2());
var log10 = (0, import_debug14.default)("screen.garden:api");
var _ApiService = class _ApiService extends Service {
  constructor(plugin) {
    super(plugin);
    this.client = null;
    log10("initializing");
    this.observable = new Subject();
    this.tokenSubscription = this.plugin.settings.tokenObservable.subscribe({
      next: /* @__PURE__ */ __name((token) => {
        if (token) {
          log10("new token, updating client");
          this.client = this.create(token);
        } else {
          log10("no token, nulling out client");
          this.client = null;
        }
        this.observable.next(this.client);
      }, "next")
    });
  }
  async onunload() {
    this.tokenSubscription.unsubscribe();
  }
  create(token) {
    return axios_default.create({
      baseURL: `${BASE_HTTP_URL}/api`,
      headers: {
        "X-ScreenGarden-Client": this.plugin.manifest.id,
        "X-ScreenGarden-Client-Version": this.plugin.manifest.version,
        Authorization: token ? `Bearer ${token}` : void 0
      }
    });
  }
};
__name(_ApiService, "ApiService");
var ApiService = _ApiService;

// src/services/collections/index.ts
init_process_shim();

// src/services/teams/index.ts
init_process_shim();

// src/services/docs/index.ts
init_process_shim();

// src/services/notes/index.ts
init_process_shim();

// src/services/socket/index.ts
init_process_shim();

// src/services/socket/SocketService.ts
init_process_shim();
var import_debug15 = __toESM(require_browser2());
var log11 = (0, import_debug15.default)("screen.garden:socket");
var _SocketService = class _SocketService extends Service {
  constructor(plugin) {
    super(plugin);
    this.connected = new Subject();
    this.observable = new Subject();
    this.tokenSubscription = this.plugin.settings.tokenObservable.subscribe({
      next: /* @__PURE__ */ __name((token) => {
        if (token) {
          this.connect(token);
        } else {
          this.disconnect();
        }
      }, "next")
    });
    this.plugin.addCommand({
      id: "connect",
      name: intl.socket.connectCommand(),
      checkCallback: /* @__PURE__ */ __name((checking) => {
        var _a8, _b;
        if (checking && ((_a8 = this.plugin.settings.config) == null ? void 0 : _a8.token)) {
          return this.socket === null;
        }
        log11("Going online");
        if ((_b = this.plugin.settings.config) == null ? void 0 : _b.token) {
          this.connect(this.plugin.settings.config.token);
        }
      }, "checkCallback")
    });
    this.plugin.addCommand({
      id: "disconnect",
      name: intl.socket.disconnectCommand(),
      checkCallback: /* @__PURE__ */ __name((checking) => {
        if (checking) {
          return this.socket !== null;
        }
        log11("Going offline");
        this.disconnect();
      }, "checkCallback")
    });
  }
  connect(token) {
    this.disconnect();
    this.origin = v4_default();
    const socket = new Socket(`${BASE_WS_URL}/socket`, {
      params: {
        token,
        client: this.plugin.manifest.id,
        client_version: this.plugin.manifest.version,
        origin: this.origin
      }
    });
    socket.onOpen(() => {
      log11("opened");
      this.connected.next(true);
    });
    socket.onClose(() => {
      log11("closed");
      this.connected.next(false);
    });
    socket.onError((e) => log11("error: %o", e));
    socket.connect();
    this.socket = socket;
    this.next();
  }
  disconnect() {
    if (this.socket == null) return;
    this.origin = null;
    this.socket.disconnect();
    this.socket = null;
    this.next();
  }
  next() {
    this.observable.next(this.socket);
  }
  async onunload() {
    this.tokenSubscription.unsubscribe();
    this.disconnect();
  }
};
__name(_SocketService, "SocketService");
var SocketService = _SocketService;

// src/services/views/index.ts
init_process_shim();

// src/services/views/ViewsService.ts
init_process_shim();

// src/services/views/file-explorer/FileExplorerDecorator.ts
init_process_shim();

// src/services/views/file-explorer/FileExplorerDecoration.tsx
init_process_shim();

// src/services/views/context/index.ts
init_process_shim();

// node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs
init_process_shim();
var import_react5 = __toESM(require_react(), 1);
function useObservable2(observableFactory, arg2, arg3) {
  var deps;
  var defaultResult;
  if (typeof observableFactory === "function") {
    deps = arg2 || [];
    defaultResult = arg3;
  } else {
    deps = [];
    defaultResult = arg2;
  }
  var monitor = import_react5.default.useRef({
    hasResult: false,
    result: defaultResult,
    error: null
  });
  var _a8 = import_react5.default.useReducer(function(x) {
    return x + 1;
  }, 0);
  _a8[0];
  var triggerUpdate = _a8[1];
  var observable2 = import_react5.default.useMemo(function() {
    var observable3 = typeof observableFactory === "function" ? observableFactory() : observableFactory;
    if (!observable3 || typeof observable3.subscribe !== "function") {
      if (observableFactory === observable3) {
        throw new TypeError("Given argument to useObservable() was neither a valid observable nor a function.");
      } else {
        throw new TypeError("Observable factory given to useObservable() did not return a valid observable.");
      }
    }
    if (!monitor.current.hasResult && typeof window !== "undefined") {
      if (typeof observable3.hasValue !== "function" || observable3.hasValue()) {
        if (typeof observable3.getValue === "function") {
          monitor.current.result = observable3.getValue();
          monitor.current.hasResult = true;
        } else {
          var subscription = observable3.subscribe(function(val) {
            monitor.current.result = val;
            monitor.current.hasResult = true;
          });
          if (typeof subscription === "function") {
            subscription();
          } else {
            subscription.unsubscribe();
          }
        }
      }
    }
    return observable3;
  }, deps);
  import_react5.default.useDebugValue(monitor.current.result);
  import_react5.default.useEffect(function() {
    var subscription = observable2.subscribe(function(val) {
      var current = monitor.current;
      if (current.error !== null || current.result !== val) {
        current.error = null;
        current.result = val;
        current.hasResult = true;
        triggerUpdate();
      }
    }, function(err) {
      var current = monitor.current;
      if (current.error !== err) {
        current.error = err;
        triggerUpdate();
      }
    });
    return typeof subscription === "function" ? subscription : subscription.unsubscribe.bind(subscription);
  }, deps);
  if (monitor.current.error)
    throw monitor.current.error;
  return monitor.current.result;
}
__name(useObservable2, "useObservable");
function useLiveQuery(querier, deps, defaultResult) {
  return useObservable2(function() {
    return liveQuery(querier);
  }, deps || [], defaultResult);
}
__name(useLiveQuery, "useLiveQuery");

// src/services/views/file-explorer/FileExplorerDecoration.tsx
var import_react6 = __toESM(require_react());
var import_client2 = __toESM(require_client());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var _FileExplorerDecoration = class _FileExplorerDecoration {
  constructor(plugin, container, collectionID) {
    this.container = container;
    this.collectionID = collectionID;
    this.root = null;
    this.el = document.createElement("div");
    this.el.classList.add("sg-mounted-collection-decoration");
    container.appendChild(this.el);
    const innerContainer = document.createElement("div");
    this.el.appendChild(innerContainer);
    this.root = (0, import_client2.createRoot)(innerContainer);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(DefaultProviders, { app: plugin.app, plugin, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Contents, { collectionID }) })
    );
  }
  unload() {
    var _a8;
    (_a8 = this.root) == null ? void 0 : _a8.unmount();
    this.el.remove();
  }
};
__name(_FileExplorerDecoration, "FileExplorerDecoration");
var FileExplorerDecoration = _FileExplorerDecoration;
var Contents = /* @__PURE__ */ __name(({ collectionID }) => {
  var _a8, _b;
  const plugin = usePlugin();
  const collection = useLiveQuery(
    () => plugin.db.collections.get(collectionID),
    [plugin]
  );
  const teams = (_a8 = useLiveQuery(() => plugin.teams.get(), [plugin])) != null ? _a8 : [];
  const pendingCount = (_b = useLiveQuery(
    () => plugin.db.pendingNotes.where("collection_id").equals(collectionID).count(),
    [plugin, collectionID]
  )) != null ? _b : 0;
  const memberCount = useObservable(
    plugin.collections.collectionSizes.pipe(
      map((sizes) => {
        var _a9;
        return (_a9 = sizes[collectionID]) != null ? _a9 : 0;
      })
    ),
    0,
    [plugin, collectionID]
  );
  const pct = memberCount === 0 ? 100 : Math.floor(100 * memberCount / (pendingCount + memberCount));
  const label = (0, import_react6.useMemo)(() => {
    if (!collection) return;
    const team = teams.find((t) => t.id === collection.team_id);
    if (team && teams.length > 1) {
      return intl.fileExplorer.withTeam({
        team: team.name,
        collection: collection.name,
        pending: `${pendingCount}`
      });
    }
    return intl.fileExplorer.withoutTeam({
      collection: collection.name,
      pending: `${pendingCount}`
    });
  }, [collection, teams, collectionID, pendingCount]);
  (0, import_react6.useEffect)(() => {
    if (!collection) return;
    const tooltipEls = document.querySelectorAll(".tooltip");
    tooltipEls.forEach((el) => {
      if (label && el instanceof HTMLElement && el.innerText.contains(`${collection.name}
`)) {
        el.innerText = label;
      }
    });
  }, [collection, label]);
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "sg-collection-decoration-contents", "aria-label": label, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("svg", { width: "12", height: "12", viewBox: "0 0 120 120", children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "circle",
      {
        cx: "60",
        cy: "60",
        r: "30",
        fill: "none",
        stroke: "var(--text-muted)",
        strokeWidth: "60",
        transform: "rotate(-90 60 60)"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "circle",
      {
        strokeDasharray: "100",
        strokeDashoffset: 100 - pct,
        cx: "60",
        cy: "60",
        r: "30",
        fill: "none",
        stroke: "#20B03F",
        strokeWidth: "60",
        pathLength: "100",
        transform: "rotate(-90 60 60)"
      }
    )
  ] }) });
}, "Contents");

// src/services/views/file-explorer/FileExplorerDecorator.ts
var _FileExplorerDecorator = class _FileExplorerDecorator {
  constructor(plugin) {
    this.plugin = plugin;
    this.decorations = /* @__PURE__ */ new Map();
    this.plugin.app.workspace.onLayoutReady(() => {
      this.update(
        this.plugin.collections.fastCollectionSettings,
        this.plugin.settings.config
      );
    });
    this.plugin.registerEvent(
      plugin.app.workspace.on("layout-change", () => {
        this.update(
          this.plugin.collections.fastCollectionSettings,
          this.plugin.settings.config
        );
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("rename", (file, oldPath) => {
        const decoration = this.decorations.get(oldPath);
        if (decoration) {
          this.decorations.delete(oldPath);
          this.decorations.set(file.path, decoration);
        }
      })
    );
    this.plugin.settings.subscribe((settings) => {
      this.update(this.plugin.collections.fastCollectionSettings, settings);
    });
    this.subscription = this.plugin.collections.collectionsSettingsObservable.subscribe({
      next: /* @__PURE__ */ __name((settings) => {
        this.update(settings, this.plugin.settings.config);
      }, "next")
    });
  }
  onunload() {
    this.subscription.unsubscribe();
  }
  update(collections, settings) {
    uniqBy_default(
      this.plugin.app.workspace.getLeavesOfType("file-explorer"),
      "view"
    ).forEach((leaf) => this.decorate(leaf, collections, settings));
  }
  decorate(leaf, collections, settings) {
    var _a8, _b;
    const showLines = (_a8 = settings == null ? void 0 : settings.showFolderLines) != null ? _a8 : true;
    const showIcons = (_b = settings == null ? void 0 : settings.showFolderIcons) != null ? _b : true;
    const fileItems = leaf.view && typeof leaf.view === "object" ? leaf.view.fileItems : null;
    const items = fileItems !== null && typeof fileItems === "object" ? fileItems : {};
    collections.filter(({ mount_path }) => mount_path in items).forEach(({ mount_path, collection_id }) => {
      const item = items[mount_path];
      if (!item) return;
      const el = item.el;
      const selfEl = item.selfEl;
      const decoration = this.decorations.get(mount_path);
      el.classList.add("sg-mounted-collection");
      el.dataset.sgCollectionId = collection_id;
      if (showLines) {
        el.classList.add("sg-collection-highlighted");
      } else {
        el.classList.remove("sg-collection-highlighted");
      }
      if (decoration && decoration.container === selfEl) {
        if (!showIcons) {
          this.remove(mount_path);
        }
        return;
      }
      const decorationEl = selfEl.querySelector(
        ".sg-mounted-collection-decoration"
      );
      if (decorationEl) {
        if (!showIcons) {
          decorationEl.remove();
          const d2 = this.decorations.get(mount_path);
          d2 == null ? void 0 : d2.unload();
          this.decorations.delete(mount_path);
        }
        return;
      }
      if (!showIcons) return;
      const newDecoration = new FileExplorerDecoration(
        this.plugin,
        selfEl,
        collection_id
      );
      this.decorations.set(mount_path, newDecoration);
    });
    const handledPaths = new Set(collections.map((c) => c.mount_path));
    this.decorations.forEach((decoration, mount_path) => {
      if (handledPaths.has(mount_path)) return;
      this.remove(mount_path);
      const el = leaf.view.containerEl.querySelector(
        `.sg-mounted-collection[data-sg-collection-id="${decoration.collectionID}"]`
      );
      if (el && el instanceof HTMLElement) {
        el.classList.remove("sg-mounted-collection");
        el.classList.remove("sg-collection-highlighted");
        delete el.dataset.sgCollectionId;
      }
    });
  }
  remove(path) {
    const decoration = this.decorations.get(path);
    if (!decoration) return;
    decoration.unload();
    this.decorations.delete(path);
  }
};
__name(_FileExplorerDecorator, "FileExplorerDecorator");
var FileExplorerDecorator = _FileExplorerDecorator;

// src/services/views/home/index.ts
init_process_shim();

// src/services/views/home/HomeView.tsx
init_process_shim();

// src/services/views/mount-collection/index.ts
init_process_shim();

// src/services/views/mount-collection/MountCollectionModal.tsx
init_process_shim();

// src/services/views/FolderSuggest.ts
init_process_shim();
var import_obsidian12 = require("obsidian");
var _FolderSuggest = class _FolderSuggest extends import_obsidian12.FuzzySuggestModal {
  constructor(app, onChoose, filter2 = () => true, placeholder = "") {
    super(app);
    this.onChoose = onChoose;
    this.filter = filter2;
    this.setPlaceholder(placeholder);
    this.setInstructions([
      {
        command: "\u2191\u2193",
        purpose: intl.folderSuggest.upDownInstruction()
      },
      {
        command: "\u21B5",
        purpose: intl.folderSuggest.enterInstruction()
      },
      {
        command: "esc",
        purpose: intl.folderSuggest.escInstruction()
      }
    ]);
  }
  getItems() {
    return this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian12.TFolder && this.filter(f)).map((f) => f.path);
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    const folder = this.app.vault.getFolderByPath(item);
    this.onChoose(folder);
  }
};
__name(_FolderSuggest, "FolderSuggest");
var FolderSuggest = _FolderSuggest;

// src/services/views/Icon.tsx
init_process_shim();
var import_classnames = __toESM(require_classnames());
var import_obsidian13 = require("obsidian");
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var Icon = /* @__PURE__ */ __name(({
  name,
  size = "var(--icon-xs)",
  className,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    "span",
    {
      ref: (el) => el && (0, import_obsidian13.setIcon)(el, name),
      className: (0, import_classnames.default)(
        "sg-icon inline-flex items-center justify-center",
        className
      ),
      style: {
        width: size,
        height: size
      },
      ...rest
    },
    name
  );
}, "Icon");

// src/services/views/LoadingIndicator.tsx
init_process_shim();
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var LoadingIndicator = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-white", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Icon, { name: "loader-2", className: "animate-spin", size: "var(--icon-s)" }) }), "LoadingIndicator");

// src/services/views/Modal.tsx
init_process_shim();
var import_obsidian14 = require("obsidian");
var import_client3 = __toESM(require_client());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var _Modal = class _Modal extends import_obsidian14.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.root = null;
  }
  createRoot(children) {
    this.root = (0, import_client3.createRoot)(this.contentEl);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(DefaultProviders, { app: this.app, plugin: this.plugin, children })
    );
  }
  async onClose() {
    var _a8, _b;
    (_a8 = this.root) == null ? void 0 : _a8.unmount();
    (_b = this.contentEl) == null ? void 0 : _b.empty();
  }
};
__name(_Modal, "Modal");
var Modal = _Modal;

// src/services/views/mount-collection/MountCollectionModal.tsx
var import_classnames2 = __toESM(require_classnames());
var import_debug16 = __toESM(require_browser2());
var import_obsidian15 = require("obsidian");
var import_react7 = __toESM(require_react());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var log12 = (0, import_debug16.default)("screen.garden:views:mount-modal");
async function showMountCollectionModal(plugin, where = null) {
  const existingCollections = await plugin.db.collections.toArray();
  new MountCollectionModal(plugin, existingCollections, where).open();
}
__name(showMountCollectionModal, "showMountCollectionModal");
var _MountCollectionModal = class _MountCollectionModal extends Modal {
  constructor(plugin, defaultCollections, where) {
    super(plugin);
    this.defaultCollections = defaultCollections;
    this.where = where;
  }
  onOpen() {
    this.setTitle(intl.mountModal.title());
    this.createRoot(
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        ModalContents,
        {
          defaultCollections: this.defaultCollections,
          where: this.where,
          close: () => this.close()
        }
      )
    );
  }
};
__name(_MountCollectionModal, "MountCollectionModal");
var MountCollectionModal = _MountCollectionModal;
function isNew(c) {
  if (!c) return false;
  return c.new;
}
__name(isNew, "isNew");
var ModalContents = /* @__PURE__ */ __name(({
  defaultCollections,
  where,
  close
}) => {
  var _a8, _b;
  const plugin = usePlugin();
  const teams = plugin.teams.get();
  const whereHasKids = where !== null && ((_b = (_a8 = plugin.app.vault.getFolderByPath(where)) == null ? void 0 : _a8.children.length) != null ? _b : 0) > 0;
  const collections = useLiveQuery(
    () => plugin.db.collections.toArray(),
    [],
    defaultCollections
  );
  (0, import_react7.useEffect)(() => {
    if (!plugin.api.client) return;
    plugin.teams.loadTeams();
    plugin.collections.getAndStoreCollections(plugin.api.client);
  }, [plugin.api.client]);
  const [team, setTeam] = (0, import_react7.useState)(
    (teams == null ? void 0 : teams.length) === 1 ? teams[0] : null
  );
  const [target, setTarget] = (0, import_react7.useState)(null);
  const [loading, setLoading] = (0, import_react7.useState)(false);
  const doMount = (0, import_react7.useCallback)(
    async (folder) => {
      if (!team || !target || !target.name) return;
      setLoading(true);
      log12("doing mount", team, target, folder);
      let collection;
      if (isNew(target)) {
        log12("new collection, creating");
        collection = await plugin.collections.create(target.name, team);
        if (!collection) {
          new import_obsidian15.Notice(intl.mountModal.createErrorNotice());
          setLoading(false);
          return;
        }
      } else {
        collection = target;
      }
      await plugin.collections.mount(collection.id, folder.path);
      new import_obsidian15.Notice(intl.mountModal.successNotice());
      close();
    },
    [close, plugin, team, target, loading]
  );
  if (teams === null) return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { children: intl.mountModal.loadTeamsError() });
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      StateSummary,
      {
        team,
        target,
        canEditTarget: collections.length > 0,
        onEditTeam: () => setTeam(null),
        onEditTarget: () => setTarget(null)
      }
    ),
    team === null ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(TeamStep, { teams, chooseTeam: setTeam }) : target === null ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      TargetStep,
      {
        allowExisting: !whereHasKids,
        collections,
        team,
        chooseTarget: setTarget
      }
    ) : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      WhereStep,
      {
        initialValue: where,
        target,
        onCreate: doMount,
        loading
      }
    )
  ] });
}, "ModalContents");
var StateSummary = /* @__PURE__ */ __name(({
  team,
  target,
  canEditTarget,
  onEditTeam,
  onEditTarget
}) => {
  const InlineTarget = /* @__PURE__ */ __name(({
    target: target2,
    editable,
    onClick
  }) => {
    if (editable)
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("a", { className: "font-bold", onClick, children: target2 == null ? void 0 : target2.name });
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { className: "font-bold", children: target2 == null ? void 0 : target2.name });
  }, "InlineTarget");
  if (!team) return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { children: intl.mountModal.s.team() });
  if (!target)
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("p", { children: [
      intl.mountModal.s.target1(),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("a", { onClick: onEditTeam, children: team.name }),
      intl.mountModal.s.target2()
    ] });
  if (isNew(target))
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("p", { children: [
      intl.mountModal.s.new1(),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        InlineTarget,
        {
          target,
          editable: canEditTarget,
          onClick: onEditTarget
        }
      ),
      intl.mountModal.s.new2(),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("a", { onClick: onEditTeam, children: team.name }),
      intl.mountModal.s.new3()
    ] });
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("p", { children: [
    intl.mountModal.s.existing1(),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      InlineTarget,
      {
        target,
        editable: canEditTarget,
        onClick: onEditTarget
      }
    ),
    intl.mountModal.s.existing2(),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("a", { onClick: onEditTeam, children: team.name }),
    intl.mountModal.s.existing3()
  ] });
}, "StateSummary");
var TeamStep = /* @__PURE__ */ __name(({
  teams,
  chooseTeam
}) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("ul", { children: teams.map((t) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("li", { className: "text-muted", children: [
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("a", { onClick: () => chooseTeam(t), children: t.name }),
  " (",
  t.short_id,
  ")"
] }, t.id)) }), "TeamStep");
var TargetStep = /* @__PURE__ */ __name(({
  allowExisting,
  collections,
  team,
  chooseTarget
}) => {
  var _a8, _b;
  const plugin = usePlugin();
  const availableCollections = useLiveQuery(
    async () => {
      const settings = await plugin.db.collectionSettings.toArray();
      const mountedIDs = settings.map((s) => s.collection_id);
      const c = collections.filter((c2) => !mountedIDs.contains(c2.id) && c2.team_id === team.id).sort((a, b) => a.name.localeCompare(b.name));
      return c;
    },
    [collections],
    collections
  );
  const [showCollections, setShowCollections] = (0, import_react7.useState)(false);
  const [target, setTarget] = (0, import_react7.useState)(null);
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "grid grid-cols-2 gap-x-2 mb-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        BoxOption,
        {
          title: intl.mountModal.t.newTitle(),
          icon: "plus",
          description: intl.mountModal.t.newDesc(),
          selected: isNew(target),
          onClick: () => {
            setTarget({ new: true, name: null });
            setShowCollections(false);
          }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        BoxOption,
        {
          title: intl.mountModal.t.existingTitle(),
          icon: "cable",
          description: intl.mountModal.t.existingDesc(),
          selected: showCollections,
          enabled: allowExisting && collections.length > 0,
          onClick: () => {
            setTarget(null);
            setShowCollections(true);
          }
        }
      )
    ] }),
    !allowExisting && !isNew(target) && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { className: "text-muted italic", children: intl.mountModal.s.noExistingWarning() }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-row justify-between items-center gap-x-2", children: [
      showCollections ? /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
        "select",
        {
          onChange: (e) => {
            var _a9;
            return setTarget(
              (_a9 = availableCollections.find((c) => c.id === e.target.value)) != null ? _a9 : null
            );
          },
          defaultValue: "default",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("option", { disabled: true, value: "default", children: intl.mountModal.t.chooseDefault() }),
            availableCollections.map((c) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("option", { value: c.id, children: c.name }, c.id))
          ]
        }
      ) : isNew(target) ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        "input",
        {
          autoFocus: true,
          className: "w-full",
          type: "text",
          value: isNew(target) ? (_a8 = target.name) != null ? _a8 : "" : "",
          onChange: (e) => setTarget({ new: true, name: e.target.value }),
          placeholder: "Collection Name"
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", {}),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        "button",
        {
          className: "mod-cta",
          disabled: !target || isNew(target) && ((_b = target.name) != null ? _b : "").length === 0,
          onClick: () => chooseTarget(target),
          children: intl.mountModal.nextButton()
        }
      )
    ] })
  ] });
}, "TargetStep");
var WhereStep = /* @__PURE__ */ __name(({
  initialValue,
  target,
  onCreate,
  loading
}) => {
  const plugin = usePlugin();
  const f = initialValue ? plugin.app.vault.getFolderByPath(initialValue) : null;
  const [which, setWhich] = (0, import_react7.useState)(
    (f == null ? void 0 : f.isRoot()) ? "vault" : f ? "folder" : null
  );
  const [where, setWhere] = (0, import_react7.useState)(
    (f == null ? void 0 : f.isRoot()) ? "vault" : f
  );
  const vaultDisabled = true;
  const onClickFolder = (0, import_react7.useCallback)(() => {
    const filter2 = /* @__PURE__ */ __name((folder) => {
      return !plugin.collections.inMountedCollection(folder) && (isNew(target) || folder.children.length === 0);
    }, "filter");
    const onChooseFolder = /* @__PURE__ */ __name((folder) => {
      if (folder) {
        if (folder.isRoot()) {
          setWhich("vault");
          setWhere("vault");
        } else {
          setWhich("folder");
          setWhere(folder);
        }
      }
    }, "onChooseFolder");
    const f2 = new FolderSuggest(
      plugin.app,
      onChooseFolder,
      filter2,
      isNew(target) ? intl.mountModal.w.folderSuggestNewPlaceholder() : intl.mountModal.w.folderSuggestExistingPlaceholder()
    );
    f2.open();
  }, [plugin]);
  const providersForWhere = /* @__PURE__ */ __name((w) => {
    if (!w) return null;
    if (w === "vault") {
      return plugin.externalProviders.enabledProviders();
    }
    return plugin.externalProviders.enabledProvidersForPath(w.path);
  }, "providersForWhere");
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "grid grid-cols-2 gap-x-2 mb-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        BoxOption,
        {
          title: intl.mountModal.w.vaultTitle(),
          icon: "vault",
          description: intl.mountModal.w.vaultComingSoon(),
          selected: which === "vault",
          onClick: () => {
            setWhich("vault");
            setWhere("vault");
          },
          enabled: !vaultDisabled
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        BoxOption,
        {
          title: intl.mountModal.w.folderTitle(),
          icon: "folder",
          description: intl.mountModal.w.folderDesc(),
          selected: which === "folder",
          onClick: onClickFolder
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-row justify-between items-center gap-x-2", children: [
      where instanceof import_obsidian15.TFolder ? /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("p", { children: [
        intl.mountModal.w.folderPrefix(),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { className: "text-accent-2", children: where.path })
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", {}),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        "button",
        {
          className: "mod-cta",
          disabled: !where,
          onClick: () => {
            const folder = where instanceof import_obsidian15.TFolder ? where : plugin.app.vault.getAbstractFileByPath("/");
            onCreate(folder);
          },
          children: loading ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(LoadingIndicator, {}) : isNew(target) ? intl.mountModal.createButton() : intl.mountModal.connectButton()
        }
      )
    ] }),
    providersForWhere(where) && /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-row items-center", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "w-6", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Icon, { name: "info", className: "text-warning mr-2 mt-1" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { className: "text-sm text-muted", children: intl.mountModal.w.externalProviderInfo({
        providers: providersForWhere(where)
      }) })
    ] })
  ] });
}, "WhereStep");
var BoxOption = /* @__PURE__ */ __name(({
  title,
  icon,
  description,
  selected,
  enabled = true,
  onClick
}) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
  "div",
  {
    onClick: enabled ? onClick : void 0,
    className: (0, import_classnames2.default)(
      "flex flex-col items-center rounded-md border-solid border border-accent hover:border-accent-1 p-1",
      { "bg-accent text-on-accent": selected },
      { "border-muted hover:border-muted text-muted": !enabled }
    ),
    children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h3", { children: title }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Icon, { name: icon, size: "var(--icon-xl)" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { className: "text-center", children: description })
    ]
  }
), "BoxOption");

// src/services/views/home/overview/Overview.tsx
init_process_shim();
var import_react8 = __toESM(require_react());

// src/util/hues.ts
init_process_shim();
var TOTAL_HUES = 256;
var toHue = /* @__PURE__ */ __name((id) => {
  return Number(
    BigInt(`0x${id.replace(/[^0-9a-f]/gi, "")}`) % BigInt(TOTAL_HUES)
  );
}, "toHue");

// src/services/views/home/overview/Overview.tsx
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var Overview = /* @__PURE__ */ __name(() => {
  const plugin = usePlugin();
  const collectionsWithPaths = useLiveQuery(async () => {
    const settings = await plugin.db.collectionSettings.toArray();
    const withPathsOrNull = await Promise.all(
      settings.map(async (s) => {
        const c = await plugin.db.collections.get(s.collection_id);
        if (!c) return null;
        return { id: c.id, name: c.name, path: s.mount_path };
      })
    );
    return withPathsOrNull.filter((v) => v !== null);
  }, [plugin]);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "flex flex-row flex-wrap items-center gap-1 mr-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h4", { className: "small-caps m-1 pb-1", children: intl.home.collectionsHeader() }) }),
    collectionsWithPaths && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-2 mb-4", children: collectionsWithPaths.map(
      // TypeScript makes me do this. It's probably fixed in a newer version.
      // Will update ts later and remove this comment.
      (c) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
        CollectionCard,
        {
          id: c.id,
          name: c.name,
          path: c.path
        },
        c.id
      )
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      "button",
      {
        className: "mod-cta",
        onClick: () => showMountCollectionModal(plugin),
        children: intl.home.addCollection()
      }
    )
  ] });
}, "Overview");
function usePresence(docId, getMetas) {
  const [metas, setMetas] = (0, import_react8.useState)(null);
  const plugin = usePlugin();
  (0, import_react8.useEffect)(() => {
    const callback = /* @__PURE__ */ __name((id) => {
      if (id !== docId) return;
      setMetas(getMetas());
    }, "callback");
    const listener = plugin.docs.on(`presence:${docId}`, callback);
    return () => plugin.docs.offref(listener);
  }, [docId]);
  return metas;
}
__name(usePresence, "usePresence");
var CollectionCard = /* @__PURE__ */ __name(({
  id,
  name,
  path
}) => {
  const plugin = usePlugin();
  const onClick = /* @__PURE__ */ __name(async () => {
    var _a8;
    const leaf = plugin.app.workspace.getLeavesOfType("file-explorer").first();
    if (!leaf) return;
    await plugin.app.workspace.revealLeaf(leaf);
    const file = plugin.app.vault.getFolderByPath(path);
    (_a8 = plugin.app.internalPlugins.getEnabledPluginById("file-explorer")) == null ? void 0 : _a8.revealInFolder(file);
  }, "onClick");
  const presences = usePresence(
    id,
    () => plugin.collections.presenceForCollection(id)
  );
  const sortedPresences = (0, import_react8.useMemo)(() => {
    const byNote = presences == null ? void 0 : presences.filter((p) => {
      var _a8;
      return p.user_id !== ((_a8 = plugin.account.get()) == null ? void 0 : _a8.id);
    }).reduce((acc, p) => {
      var _a8, _b;
      for (const note of (_a8 = p.notes) != null ? _a8 : []) {
        const noteUsers = (_b = acc[note.id]) != null ? _b : [];
        noteUsers.push({
          user_id: p.user_id,
          user_name: p.user_name,
          active: note.active
        });
        acc[note.id] = noteUsers;
      }
      return acc;
    }, {});
    return sortBy_default(
      Object.entries(byNote != null ? byNote : {}).map(([id2, users]) => ({
        id: id2,
        users: [...users].sort((a, b) => {
          if (a.active) return -1;
          if (b.active) return 1;
          return a.user_id < b.user_id ? -1 : 1;
        })
      })),
      ["id"]
    );
  }, [plugin, presences]);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "group flex flex-col border border-solid border-base-40 hover:border-accent rounded p-2", children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
      "div",
      {
        className: "flex flex-row items-center justify-between ",
        onClick,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h5", { className: "p-0 m-0 mb-1", children: name }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-muted text-sm m-0 p-0", children: `/${path}` })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            Icon,
            {
              name: "folder-closed",
              size: "var(--icon-l)",
              className: "block group-hover:hidden"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            Icon,
            {
              name: "folder-open",
              size: "var(--icon-l)",
              className: "hidden group-hover:block group-hover:text-accent"
            }
          )
        ]
      }
    ),
    sortedPresences && sortedPresences.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col gap-1", children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "h-px w-full bg-base-40 my-1" }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h6", { className: "font-extrabold text-xs text-muted uppercase my-0", children: intl.home.collectionCard.activeCollaborators() }),
      sortedPresences.map((p) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ActiveNote, { id: p.id, users: p.users }, p.id))
    ] })
  ] });
}, "CollectionCard");
var ActiveNote = /* @__PURE__ */ __name(({ id, users }) => {
  const plugin = usePlugin();
  const note = useLiveQuery(() => plugin.db.notes.get(id), [id]);
  const openNote = (0, import_react8.useCallback)(() => {
    if (!note) return;
    plugin.app.workspace.openLinkText(note.path, "/", true);
  }, [plugin, note]);
  return (note == null ? void 0 : note.path) ? /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
    "div",
    {
      className: "flex flex-row gap-2 items-center hover:bg-base-10 rounded-sm",
      onClick: openNote,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(FaceStack, { users }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "font-bold", children: getTitle(note.path) })
      ]
    }
  ) : /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", {});
}, "ActiveNote");
var FaceStack = /* @__PURE__ */ __name(({ users }) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "flex flex-row mr-3", children: users.slice(0, 10).map((user, i) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Face, { z: 10 - i, user }, i)) }), "FaceStack");
var Face = /* @__PURE__ */ __name(({ z, user }) => {
  var _a8;
  const hue = toHue(user.user_id);
  const bg = user.active ? `hsl(${hue}, 50%, 50%)` : `hsl(${hue}, 10%, 30%)`;
  const name = (_a8 = user.user_name) != null ? _a8 : intl.home.collectionCard.anonymous();
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "div",
    {
      className: "rounded-full h-6 w-6 overflow-clip mr-[-0.75rem] border border-solid border-base-80 text-base-80 flex items-center justify-center",
      style: { zIndex: z, backgroundColor: bg },
      "aria-label": user.active ? intl.home.collectionCard.editing({ name }) : intl.home.collectionCard.viewing({ name }),
      children: user.user_name ? initialize(user.user_name) : /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Icon, { name: "user", className: "w-3 h-3" })
    }
  );
}, "Face");
function initialize(name) {
  return name.split(" ").map((n) => n[0].toUpperCase()).join("");
}
__name(initialize, "initialize");

// src/services/views/home/HomeView.tsx
var import_react9 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var _HomeView = class _HomeView extends View {
  static LeafIn(workspace) {
    return workspace.getLeaf(true);
  }
  getDisplayText() {
    return "screen.garden";
  }
  getIcon() {
    return "leaf";
  }
  async onOpen() {
    this.createRoot(/* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Home, {}));
  }
};
__name(_HomeView, "HomeView");
_HomeView.ViewType = /* @__PURE__ */ __name(() => "screengarden:views:home" /* Home */, "ViewType");
var HomeView = _HomeView;
var Home = /* @__PURE__ */ __name(() => {
  const plugin = usePlugin();
  const account = useObservable(plugin.account.observable, void 0, [plugin]);
  const collectionSettings = useObservable(
    plugin.collections.collectionsSettingsObservable,
    [],
    [plugin]
  );
  const onboarded = collectionSettings.length > 0;
  const view = (0, import_react9.useMemo)(() => {
    if (!account) return "login";
    if (!onboarded) return "onboarding";
    return "overview";
  }, [account, onboarded]);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "mx-auto max-w-[var(--file-line-width)]", children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("h1", { children: [
      "screen",
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-brand", children: "." }),
      "garden"
    ] }),
    view === "login" && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(LogIn, {}),
    view === "onboarding" && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Onboarding, {}),
    view === "overview" && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Overview, {})
  ] });
}, "Home");
var LogIn = /* @__PURE__ */ __name(() => {
  const plugin = usePlugin();
  const [url, setURL] = (0, import_react9.useState)(null);
  const login = (0, import_react9.useCallback)(() => {
    plugin.account.startAuth("login", (url2) => {
      setURL(url2);
    });
  }, [plugin]);
  const register = (0, import_react9.useCallback)(() => {
    plugin.account.startAuth("register", (url2) => {
      setURL(url2);
    });
  }, [plugin]);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: intl.settingsTab.accountSettingsDesc() }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex flex-row gap-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { className: "mod-cta", onClick: register, children: intl.settingsTab.createAccountButton() }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: login, children: intl.settingsTab.loginButton() })
    ] }),
    url && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
      intl.settingsTab.loginDetails1(),
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("a", { href: url, target: "_blank", children: intl.settingsTab.loginDetails2() })
    ] })
  ] });
}, "LogIn");
var Onboarding = /* @__PURE__ */ __name(() => {
  var _a8;
  const plugin = usePlugin();
  const collections = useObservable(
    plugin.collections.availableCollectionsObservable,
    [],
    [plugin]
  );
  const teams = (_a8 = plugin.teams.get()) != null ? _a8 : [];
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
      intl.home.welcome(),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "live-cursors-example", children: intl.home.welcomeCursors() })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
      intl.home.startPrefix(),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "font-bold", children: intl.home.collection() }),
      intl.home.startSuffix()
    ] }),
    collections.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "border-l-8 border-solid border-accent rounded p-1 mb-4", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
      intl.home.collectionsAvailable1({ teams, collections }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "font-bold", children: intl.home.addCollection() }),
      intl.home.collectionsAvailable2()
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      "button",
      {
        className: "mod-cta",
        onClick: () => showMountCollectionModal(plugin),
        children: intl.home.addCollection()
      }
    )
  ] });
}, "Onboarding");

// src/services/views/note/ActionDecoration.tsx
init_process_shim();

// src/services/editor/utils.ts
init_process_shim();
function absolutePositionFromCursor(ytext, cursor) {
  const ydoc = ytext.doc;
  const anchor = createAbsolutePositionFromRelativePosition(
    cursor.anchor,
    ydoc
  );
  const head = createAbsolutePositionFromRelativePosition(cursor.head, ydoc);
  if (!anchor || !head || anchor.type !== ytext || head.type !== ytext)
    return null;
  const start = min(anchor.index, head.index);
  const end = max(anchor.index, head.index);
  return { start, end, anchor, head };
}
__name(absolutePositionFromCursor, "absolutePositionFromCursor");

// src/services/views/note/NoteViewDecoration.ts
init_process_shim();
var _NoteViewDecoration = class _NoteViewDecoration {
  constructor(plugin, view, path) {
    this.plugin = plugin;
    this.path = path;
  }
};
__name(_NoteViewDecoration, "NoteViewDecoration");
var NoteViewDecoration = _NoteViewDecoration;

// src/services/views/note/ActionDecoration.tsx
var import_classnames3 = __toESM(require_classnames());
var import_obsidian16 = require("obsidian");
var import_client4 = __toESM(require_client());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _ActionDecoration = class _ActionDecoration extends NoteViewDecoration {
  constructor(plugin, view, path) {
    var _a8, _b;
    super(plugin, view, path);
    this.root = null;
    this.note = null;
    this.collection = null;
    this.team = null;
    const container = view.containerEl.querySelector(".view-actions");
    this.el = document.createElement("button");
    container.prepend(this.el);
    this.el.classList.add("clickable-icon", "view-action", "sg-view-action");
    this.el.ariaLabel = "";
    this.el.dataset.tooltipPosition = "bottom";
    this.el.onclick = () => this.showMenu();
    this.root = (0, import_client4.createRoot)(this.el);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(DefaultProviders, { app: plugin.app, plugin, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(CircleIndicator, {}) })
    );
    this.noteAtPathObservable = liveQuery(
      () => this.plugin.db.notes.where({ path }).first()
    );
    this.noteAtPathSubscription = this.noteAtPathObservable.subscribe({
      next: /* @__PURE__ */ __name(() => {
        this.loadFileData(this.path);
      }, "next")
    });
    this.loadFileData(this.path);
    this.connectedSubscription = this.plugin.socket.connected.subscribe({
      next: this.setAriaLabel.bind(this)
    });
    this.setAriaLabel((_b = (_a8 = this.plugin.socket.socket) == null ? void 0 : _a8.isConnected()) != null ? _b : false);
  }
  unload() {
    var _a8;
    this.noteAtPathSubscription.unsubscribe();
    this.connectedSubscription.unsubscribe();
    (_a8 = this.root) == null ? void 0 : _a8.unmount();
    this.el.remove();
  }
  async loadFileData(path) {
    const data = await this.plugin.collections.dataForFile(path);
    if (!data) {
      this.el.ariaLabel = "";
      return;
    }
    this.team = data.team;
    this.collection = data.collection;
    this.note = data.note;
  }
  setAriaLabel(connected) {
    if (connected) {
      this.el.ariaLabel = intl.viewAction.connected();
    } else {
      this.el.ariaLabel = intl.viewAction.disconnected();
    }
  }
  showMenu() {
    var _a8;
    const file = this.plugin.app.vault.getAbstractFileByPath(this.path);
    if (!file || !this.note || !this.collection || !this.team) return;
    const note = this.note;
    const collection = this.collection;
    const team = this.team;
    const me = (_a8 = this.plugin.account.get()) == null ? void 0 : _a8.id;
    const collaborators = this.plugin.notes.listPresences(note.id).filter((presence) => presence.userID !== me);
    const menu = new import_obsidian16.Menu();
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("screen.garden");
      item.setIsLabel(true);
    });
    menu.addSeparator();
    menu.addItem((item) => {
      var _a9;
      item.setTitle(
        intl.viewAction.menu.collection({ collection: (_a9 = this.collection) == null ? void 0 : _a9.name })
      );
      item.setIsLabel(true);
    });
    menu.addItem((item) => {
      var _a9;
      item.setTitle(intl.viewAction.menu.team({ team: (_a9 = this.team) == null ? void 0 : _a9.name }));
      item.setIsLabel(true);
    });
    menu.addSeparator();
    if (collaborators.length > 0) {
      menu.addItem((item) => {
        item.setTitle(
          intl.viewAction.menu.collaboratorCount({
            count: collaborators.length
          })
        );
        const submenu = item.setSubmenu();
        submenu.addItem((item2) => {
          item2.setTitle(intl.viewAction.menu.collaboratorLabel());
          item2.setIsLabel(true);
        });
        collaborators.forEach((collaborator) => {
          submenu.addItem((item2) => {
            item2.setTitle(collaborator.name);
            item2.onClick(() => {
              const { cursor } = collaborator;
              if (!cursor || !cursor.anchor || !cursor.head) return;
              const ytext = this.plugin.notes.borrowYText(note.id);
              if (!ytext) return;
              const absPos = absolutePositionFromCursor(ytext, cursor);
              if (!absPos) return;
              const { start } = absPos;
              this.moveCursorTo(start);
            });
          });
        });
      });
      menu.addSeparator();
    }
    menu.addItem((item) => {
      item.setTitle(intl.viewAction.menu.web());
      item.setIcon("globe");
      item.onClick(() => {
        window.open(noteURL(team, collection, note), "_blank");
      });
    });
    menu.addItem((item) => {
      item.setTitle(intl.viewAction.menu.copyURL());
      item.setIcon("clipboard-copy");
      item.onClick(() => copyNoteURLToClipboard(team, collection, note));
    });
    const { x, y, width, height } = this.el.getBoundingClientRect();
    menu.showAtPosition({ x: x + Math.floor(width / 2), y: y + height + 4 });
  }
  moveCursorTo(ch) {
    this.plugin.app.workspace.getLeavesOfType("markdown").find((l) => {
      var _a8;
      if (l.view instanceof import_obsidian16.MarkdownView && ((_a8 = l.view.file) == null ? void 0 : _a8.path) === this.path) {
        l.view.editor.setCursor(ch);
      }
    });
  }
};
__name(_ActionDecoration, "ActionDecoration");
var ActionDecoration = _ActionDecoration;
var CircleIndicator = /* @__PURE__ */ __name(() => {
  var _a8, _b;
  const plugin = usePlugin();
  const isConnected = useObservable(
    plugin.socket.connected,
    (_b = (_a8 = plugin.socket.socket) == null ? void 0 : _a8.isConnected()) != null ? _b : false,
    [plugin]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "flex flex-row items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    "div",
    {
      className: (0, import_classnames3.default)("rounded-full w-3 h-3", {
        "bg-brand": isConnected,
        "bg-slate-500": !isConnected
      })
    }
  ) });
}, "CircleIndicator");

// src/services/views/note/NoteViewDecorator.ts
init_process_shim();
var _NoteViewDecorator = class _NoteViewDecorator {
  // private log: ReturnType<typeof debug>;
  constructor(plugin, makeDecoration, name, containerSelector, elSelector, viewType = "markdown") {
    this.plugin = plugin;
    this.makeDecoration = makeDecoration;
    this.containerSelector = containerSelector;
    this.elSelector = elSelector;
    this.viewType = viewType;
    this.decorations = /* @__PURE__ */ new WeakMap();
  }
  onload() {
    this.plugin.registerEvent(
      this.plugin.app.workspace.on(
        "active-leaf-change",
        this.onActiveLeafChange,
        this
      )
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("layout-change", this.onLayoutChange, this)
    );
    this.subscription = this.plugin.collections.collectionsSettingsObservable.subscribe({
      next: /* @__PURE__ */ __name(() => {
        setTimeout(() => this.onChange("all"), 0);
      }, "next")
    });
  }
  onunload() {
    this.subscription.unsubscribe();
  }
  onActiveLeafChange(leaf) {
    if (!leaf) return;
    this.onChange(leaf);
  }
  onLayoutChange() {
    this.onChange("all");
  }
  onChange(leafOrAll) {
    if (leafOrAll === "all") {
      this.plugin.app.workspace.getLeavesOfType(this.viewType).forEach((leaf) => {
        this.upsertInto(leaf.view);
      });
    } else {
      this.upsertInto(leafOrAll.view);
    }
  }
  upsertInto(view) {
    var _a8;
    const container = view.containerEl.querySelector(this.containerSelector);
    const existing = (_a8 = container == null ? void 0 : container.querySelector(this.elSelector)) != null ? _a8 : null;
    const state = view.getState();
    if (!("file" in state)) {
      if (existing) {
        this.remove(view, existing);
      }
      return;
    }
    const file = state.file;
    const inCollection = this.plugin.collections.inMountedCollection(file);
    const decoration = this.decorations.get(view);
    if (!inCollection) {
      this.remove(view, existing);
      return;
    }
    if (decoration && decoration.path === file) {
      return;
    }
    this.remove(view, existing);
    existing == null ? void 0 : existing.remove();
    if (!container || !(container instanceof HTMLElement)) {
      return;
    }
    const newDecoration = this.makeDecoration(this.plugin, view, file);
    this.decorations.set(view, newDecoration);
  }
  remove(view, el) {
    const decoration = this.decorations.get(view);
    if (!decoration) return;
    decoration.unload();
    this.decorations.delete(view);
    el == null ? void 0 : el.remove();
  }
};
__name(_NoteViewDecorator, "NoteViewDecorator");
var NoteViewDecorator = _NoteViewDecorator;

// src/services/views/status/StatusBarItem.tsx
init_process_shim();
var import_react10 = __toESM(require_react());
var import_client5 = __toESM(require_client());
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var _StatusBarItem = class _StatusBarItem {
  constructor(plugin) {
    this.root = null;
    this.statusEl = plugin.addStatusBarItem();
    this.statusEl.ariaLabel = "";
    this.statusEl.dataset.tooltipPosition = "top";
    this.statusEl.classList.add("mod-clickable");
    this.statusEl.onclick = (e) => {
      e.preventDefault();
      plugin.views.revealView("screengarden:views:home" /* Home */);
    };
    this.root = (0, import_client5.createRoot)(this.statusEl);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(DefaultProviders, { app: plugin.app, plugin, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Contents2, { setTooltip: (tt) => this.statusEl.ariaLabel = tt }) })
    );
  }
  remove() {
    var _a8;
    (_a8 = this.root) == null ? void 0 : _a8.unmount();
    this.statusEl.remove();
  }
};
__name(_StatusBarItem, "StatusBarItem");
var StatusBarItem = _StatusBarItem;
var Contents2 = /* @__PURE__ */ __name(({
  setTooltip
}) => {
  var _a8, _b;
  const plugin = usePlugin();
  const isConnected = useObservable(
    plugin.socket.connected,
    (_b = (_a8 = plugin.socket.socket) == null ? void 0 : _a8.isConnected()) != null ? _b : false,
    [plugin]
  );
  const hasPoolContention = useObservable(
    plugin.notes.poolStats.pipe(map((pool) => pool.open.required >= pool.size)),
    false,
    [plugin]
  );
  (0, import_react10.useEffect)(() => {
    if (isConnected) {
      if (hasPoolContention) {
        setTooltip(intl.statusBarItem.connectedWithContention());
      } else {
        setTooltip(intl.statusBarItem.connected());
      }
    } else {
      setTooltip(intl.statusBarItem.disconnected());
    }
  }, [isConnected, hasPoolContention]);
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "flex flex-row items-center", children: isConnected ? /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Icon, { className: "text-brand mr-1", name: "leaf" }) : /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Icon, { className: "text-slate-500", name: "cloud-off" }) });
}, "Contents");

// src/services/views/unmount-collection/index.ts
init_process_shim();

// src/services/views/unmount-collection/UnmountCollectionModal.tsx
init_process_shim();
var import_obsidian17 = require("obsidian");
var import_react11 = __toESM(require_react());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
async function showUnmountCollectionModal(plugin, path) {
  const c = plugin.collections.collectionContaining(path);
  if (!c) return;
  new UnmountCollectionModal(plugin, path, c.collection_id).open();
}
__name(showUnmountCollectionModal, "showUnmountCollectionModal");
var _UnmountCollectionModal = class _UnmountCollectionModal extends Modal {
  constructor(plugin, path, collectionId) {
    super(plugin);
    this.path = path;
    this.collectionId = collectionId;
  }
  onOpen() {
    this.setTitle(intl.unmountModal.title({ path: this.path }));
    this.createRoot(
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
        ModalContents2,
        {
          path: this.path,
          collectionId: this.collectionId,
          close: () => this.close()
        }
      )
    );
  }
};
__name(_UnmountCollectionModal, "UnmountCollectionModal");
var UnmountCollectionModal = _UnmountCollectionModal;
var ModalContents2 = /* @__PURE__ */ __name(({
  path,
  collectionId,
  close
}) => {
  const plugin = usePlugin();
  const unmount = (0, import_react11.useCallback)(async () => {
    await plugin.collections.unmount(collectionId);
    new import_obsidian17.Notice(intl.unmountModal.successNotice({ path }));
    close();
  }, [close, plugin, path, collectionId]);
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { children: intl.unmountModal.explanation() }),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { children: intl.unmountModal.explanation2() }),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "flex flex-row justify-between items-center gap-x-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("button", { onClick: close, children: intl.unmountModal.cancel() }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("button", { className: "mod-cta", onClick: unmount, children: intl.unmountModal.remove() })
    ] })
  ] });
}, "ModalContents");

// src/services/views/ViewsService.ts
var import_debug17 = __toESM(require_browser2());
var import_obsidian18 = require("obsidian");
var log13 = (0, import_debug17.default)("screen.garden:views");
var VIEWS = [HomeView];
var _ViewsService = class _ViewsService extends Service {
  constructor(plugin) {
    super(plugin);
    document.documentElement.style.setProperty("--sg-brand", "#20B03F");
    document.documentElement.style.setProperty("--sg-brand-dark", "#19812F");
    this.statusBarItem = new StatusBarItem(plugin);
    this.viewActions = new NoteViewDecorator(
      plugin,
      (plugin2, view, path) => new ActionDecoration(plugin2, view, path),
      "view-actions",
      ".view-actions",
      ".sg-view-action"
    );
    this.fileExplorer = new FileExplorerDecorator(plugin);
    this.plugin.addRibbonIcon("leaf", "screen.garden", () => {
      this.revealView("screengarden:views:home" /* Home */);
    });
    this.plugin.addCommand({
      id: "show-home-view",
      name: intl.home.commandName(),
      callback: /* @__PURE__ */ __name(() => {
        log13("revealing home view");
        this.revealView("screengarden:views:home" /* Home */);
      }, "callback")
    });
    this.plugin.addCommand({
      id: "copy-current-note-url",
      name: intl.note.copyCurrentURLCommand.title(),
      editorCheckCallback: /* @__PURE__ */ __name((checking) => {
        const file = this.plugin.app.workspace.getActiveFile();
        if (!file) {
          return false;
        }
        if (checking) {
          return this.plugin.collections.inMountedCollection(file);
        }
        this.plugin.collections.dataForFile(file).then((data) => {
          if (!data) {
            new import_obsidian18.Notice(intl.note.copyCurrentURLCommand.error());
            return;
          }
          const { team, collection, note } = data;
          copyNoteURLToClipboard(team, collection, note);
        });
      }, "editorCheckCallback")
    });
    this.registerEvent(
      this.plugin.app.workspace.on(
        "file-menu",
        (menu, folder) => {
          if (!(folder instanceof import_obsidian18.TFolder)) return;
          if (this.plugin.collections.inMountedCollection(folder)) {
            menu.addItem((item) => {
              item.setTitle(intl.unmountModal.contextMenuItem()).setIcon("leaf").onClick(async () => {
                showUnmountCollectionModal(this.plugin, folder.path);
              });
            });
          } else {
            menu.addItem((item) => {
              item.setTitle(intl.mountModal.contextMenuItem()).setIcon("leaf").onClick(async () => {
                showMountCollectionModal(this.plugin, folder.path);
              });
            });
          }
        }
      )
    );
    this.settingsSubscription = from(this.plugin.settings.observable).pipe(
      map((s) => {
        var _a8;
        return (_a8 = s == null ? void 0 : s.showStatusIcon) != null ? _a8 : false;
      }),
      distinctUntilChanged()
    ).subscribe((show) => {
      var _a8;
      if (show) {
        if (!this.statusBarItem) {
          this.statusBarItem = new StatusBarItem(plugin);
        }
      } else {
        (_a8 = this.statusBarItem) == null ? void 0 : _a8.remove();
        this.statusBarItem = null;
      }
    });
  }
  async onload() {
    VIEWS.forEach(
      (v) => this.plugin.registerView(v.ViewType(), (leaf) => new v(this.plugin, leaf))
    );
    this.viewActions.onload();
  }
  async onunload() {
    var _a8;
    (_a8 = this.statusBarItem) == null ? void 0 : _a8.remove();
    this.viewActions.onunload();
    this.fileExplorer.onunload();
  }
  leafFor(type) {
    const { workspace } = this.plugin.app;
    const t = VIEWS.find((v) => v.ViewType() === type);
    if (!t) return null;
    const leaf = t.LeafIn(workspace);
    leaf.setViewState({ type, active: true });
    return leaf;
  }
  revealView(type) {
    const { workspace } = this.plugin.app;
    const leaf = workspace.getLeavesOfType(type).first() || this.leafFor(type);
    if (leaf) workspace.revealLeaf(leaf);
  }
};
__name(_ViewsService, "ViewsService");
var ViewsService = _ViewsService;

// src/services/editor/index.ts
init_process_shim();

// src/services/editor/EditorService.ts
init_process_shim();

// src/services/editor/screenGardenCollab/index.ts
init_process_shim();

// src/services/editor/screenGardenCollab/screenGardenRemoteSelections.ts
init_process_shim();

// src/services/editor/screenGardenCollab/screenGardenSync.ts
init_process_shim();
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_debug18 = __toESM(require_browser2());
var import_obsidian19 = require("obsidian");
var log14 = (0, import_debug18.default)("screen.garden:editor");
var RESET_TIMEOUT = 3e4;
var _ScreenGardenSyncConfig = class _ScreenGardenSyncConfig {
  constructor(plugin) {
    this.plugin = plugin;
  }
};
__name(_ScreenGardenSyncConfig, "ScreenGardenSyncConfig");
var ScreenGardenSyncConfig = _ScreenGardenSyncConfig;
var screenGardenSyncFacet = import_state.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var screenGardenSyncAnnotation = import_state.Annotation.define();
var _ScreenGardenSyncPluginValue = class _ScreenGardenSyncPluginValue {
  constructor(view) {
    this.view = view;
    this.file = null;
    this.noteID = null;
    this.ytext = null;
    this.release = null;
    this.handlerSubscription = null;
    this.resetId = null;
    this.conf = view.state.facet(screenGardenSyncFacet);
    this._observer = this._observer.bind(this);
    this.conf.plugin.app.workspace.onLayoutReady(this.connect.bind(this));
  }
  destroy() {
    var _a8;
    this.disconnect();
    (_a8 = this.handlerSubscription) == null ? void 0 : _a8.unsubscribe();
  }
  async connect() {
    this.disconnect();
    this.file = this.getFile();
    if (!this.file) return;
    const handler = await this.conf.plugin.collections.requireNoteHandlerForFile(this.file);
    if (handler) {
      log14("handler found, connecting");
      this.connectHandler(handler, this.file.name);
    }
    this.handlerSubscription = this.conf.plugin.notes.handlerChanges.subscribe({
      next: /* @__PURE__ */ __name(async ({ id, path: _path, deleted }) => {
        var _a8;
        const file = this.getFile();
        const path = _path || ((_a8 = await this.conf.plugin.notes.get(id)) == null ? void 0 : _a8.path);
        if (!file || (file == null ? void 0 : file.path) !== path) return;
        if (deleted) {
          log14("handler deleted");
          this.disconnect();
          return;
        }
        log14("requiring handler for %s", file.path);
        if (this.noteID && id !== this.noteID) {
          this.disconnect();
          this.file = file;
        }
        const handler2 = await this.conf.plugin.collections.requireNoteHandlerForFile(file);
        if (!handler2) return;
        this.connectHandler(handler2, file.name);
      }, "next")
    });
  }
  /**
   * Connect the note handler's ytext to the editor view.
   * Connecting the same handler again is a no-op.
   * @param handler The note handler to connect to the view. Holds a ytext.
   * @param name The name assigned to this note, for debug logging.
   */
  async connectHandler(handler, name) {
    if (this.noteID === handler.id) return;
    const handle = await handler.getYTextHandle();
    if (!handle) return;
    this.release = handle.release;
    this.ytext = handle.ytext;
    this.noteID = handler.id;
    this.replaceWithYText();
    this.ytext.observe(this._observer);
    log14("connected path:%s to note:%s", name, this.noteID);
  }
  replaceWithYText() {
    if (!this.ytext) return;
    const insert = this.ytext.toString();
    const current = this.view.state.doc.toString();
    if (insert === current) return;
    const scroller = document.querySelector("div.cm-scroller");
    const top = scroller == null ? void 0 : scroller.scrollTop;
    const maintainSelection = this.view.state.selection.ranges.every(
      (s) => s.anchor < insert.length && s.head < insert.length
    );
    this.view.dispatch({
      changes: [
        {
          from: 0,
          to: current.length,
          insert
        }
      ],
      selection: maintainSelection ? this.view.state.selection : void 0,
      annotations: [screenGardenSyncAnnotation.of(this.conf)]
    });
    if (top) {
      requestAnimationFrame(() => {
        scroller.scrollTop = top;
      });
    }
  }
  disconnect() {
    if (this.file && this.conf.plugin.collections.inMountedCollection(this.file)) {
      log14("disconnecting %s", this.file.path);
    }
    if (this.release) {
      this.release();
      this.release = null;
    }
    if (this.resetId) window.clearTimeout(this.resetId);
    this.resetId = null;
    if (this.ytext) {
      this.ytext.unobserve(this._observer);
      this.ytext = null;
    }
    this.file = null;
  }
  getFile() {
    return this.view.state.field(import_obsidian19.editorInfoField).file;
  }
  update(update) {
    if (!this.ytext) return;
    if (!update.docChanged) return;
    if (update.transactions.length > 0 && update.transactions[0].annotation(screenGardenSyncAnnotation) === this.conf)
      return;
    const ytext = this.ytext;
    if (!ytext || !ytext.doc) return;
    ytext.doc.transact(() => {
      let adj = 0;
      update.changes.iterChanges((fromA, toA, fromB, toB, insert) => {
        const insertText2 = insert.sliceString(0, insert.length, "\n");
        if (fromA !== toA) {
          ytext.delete(fromA + adj, toA - fromA);
        }
        if (insertText2.length > 0) {
          ytext.insert(fromA + adj, insertText2);
        }
        adj += insertText2.length - (toA - fromA);
      });
    }, this.conf);
    this.mark();
  }
  _observer(event, txn) {
    if (txn.origin === this.conf) return;
    const delta = event.delta;
    const changes = [];
    let pos = 0;
    for (const d2 of delta) {
      if (d2.insert != null && typeof d2.insert === "string") {
        changes.push({ from: pos, to: pos, insert: d2.insert });
      } else if (d2.delete != null) {
        changes.push({ from: pos, to: pos + d2.delete, insert: "" });
      } else if (d2.retain != null) {
        pos += d2.retain;
      }
    }
    const txnSpec = {
      annotations: [screenGardenSyncAnnotation.of(this.conf)],
      changes
    };
    this.view.dispatch(txnSpec);
    this.mark();
  }
  mark() {
    if (this.resetId) window.clearTimeout(this.resetId);
    this.resetId = window.setTimeout(
      () => this.replaceWithYText(),
      RESET_TIMEOUT
    );
  }
};
__name(_ScreenGardenSyncPluginValue, "ScreenGardenSyncPluginValue");
var ScreenGardenSyncPluginValue = _ScreenGardenSyncPluginValue;
var screenGardenSync = import_view.ViewPlugin.fromClass(
  ScreenGardenSyncPluginValue
);

// src/services/editor/screenGardenCollab/screenGardenRemoteSelections.ts
var import_state2 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_view3 = require("@codemirror/view");
var import_debug19 = __toESM(require_browser2());
var import_obsidian20 = require("obsidian");
var unconnectedLog = (0, import_debug19.default)("screen.garden:selections");
var screenGardenRemoteSelectionsTheme = import_view2.EditorView.baseTheme({
  ".cm-sgSelection": {},
  ".cm-sgLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-sgSelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-sgSelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-sgSelectionCaret:hover > .cm-sgSelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-sgSelectionInfo": {
    position: "absolute",
    top: "-1.2rem",
    left: "-1px",
    fontSize: "0.9rem",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    padding: "0.1rem 0.2rem",
    borderRadius: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-sgSelectionCaret:hover > .cm-sgSelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
});
var sgRemoteSelectionsAnnotation = import_state2.Annotation.define();
var _ScreenGardenRemoteCaretWidget = class _ScreenGardenRemoteCaretWidget extends import_view2.WidgetType {
  constructor(color, name) {
    super();
    this.color = color;
    this.name = name;
  }
  toDOM() {
    return element(
      "span",
      [
        create5("class", "cm-sgSelectionCaret"),
        create5(
          "style",
          `background-color: ${this.color}; border-color: ${this.color}`
        )
      ],
      [
        text("\u2060"),
        element("div", [create5("class", "cm-sgSelectionCaretDot")]),
        text("\u2060"),
        element(
          "div",
          [create5("class", "cm-sgSelectionInfo")],
          [text(this.name)]
        ),
        text("\u2060")
      ]
    );
  }
  eq(widget) {
    return widget.color === this.color;
  }
  compare(widget) {
    return widget.color === this.color;
  }
  updateDOM() {
    return false;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return true;
  }
};
__name(_ScreenGardenRemoteCaretWidget, "ScreenGardenRemoteCaretWidget");
var ScreenGardenRemoteCaretWidget = _ScreenGardenRemoteCaretWidget;
var _ScreenGardenRemoteSelectionsPluginValue = class _ScreenGardenRemoteSelectionsPluginValue {
  constructor(view) {
    this.view = view;
    this.decorations = import_state2.RangeSet.of([]);
    this.log = unconnectedLog;
    this.noteId = null;
    this.listener = null;
    this.noteSubscription = null;
    this._path = null;
    this._anchor = null;
    this._head = null;
    this.conf = view.state.facet(screenGardenSyncFacet);
    this.handlePresenceSync = this.handlePresenceSync.bind(this);
    this.accountSubscription = this.conf.plugin.account.observable.subscribe({
      next: /* @__PURE__ */ __name((account) => {
        this.account = account != null ? account : null;
      }, "next")
    });
    this.listenIfNew();
  }
  destroy() {
    this.accountSubscription.unsubscribe();
    this.unlisten();
  }
  async listenIfNew() {
    const file = this.view.state.field(import_obsidian20.editorInfoField).file;
    if (!file || file.path === this._path) return;
    const note = await this.conf.plugin.db.notes.where({ path: file.path }).first();
    if (!note) return;
    if (this.listener && note.id === this.noteId) return;
    this.unlisten();
    this.noteId = note.id;
    this._path = file.path;
    this.listener = this.conf.plugin.docs.on(
      `presence:${this.noteId}`,
      this.handlePresenceSync
    );
    this.conf.plugin.registerEvent(this.listener);
    this.log = (0, import_debug19.default)(`screen.garden:selections:${this.noteId}`);
    this.log(`listening to doc:${this.noteId} path:${this._path}`);
    const noteId = note.id;
    this.noteSubscription = liveQuery(
      () => this.conf.plugin.db.notes.get(noteId)
    ).subscribe({
      next: /* @__PURE__ */ __name((newNote) => {
        var _a8;
        const fileField = this.view.state.field(import_obsidian20.editorInfoField, false);
        if (!newNote || newNote.path !== ((_a8 = fileField == null ? void 0 : fileField.file) == null ? void 0 : _a8.path)) {
          this.unlisten();
          this._head = null;
          this._anchor = null;
          this.decorations = import_view3.Decoration.set([], true);
          this.view.dispatch({
            annotations: [sgRemoteSelectionsAnnotation.of([])]
          });
        }
      }, "next")
    });
    this.handlePresenceSync(this.noteId);
  }
  unlisten() {
    var _a8;
    if (this.listener) this.conf.plugin.docs.offref(this.listener);
    this.listener = null;
    this.noteId = null;
    this._path = null;
    this.log = unconnectedLog;
    (_a8 = this.noteSubscription) == null ? void 0 : _a8.unsubscribe();
    this.noteSubscription = null;
  }
  update(update) {
    var _a8, _b, _c, _d;
    this.listenIfNew();
    if (!this.noteId) return;
    const ytext = this.conf.plugin.notes.borrowYText(this.noteId);
    if (!ytext) return;
    const ydoc = ytext.doc;
    const clientID = ydoc.clientID;
    const hasFocus = update.view.hasFocus && update.view.dom.ownerDocument.hasFocus();
    const sel = hasFocus ? update.state.selection.main : null;
    if (sel) {
      const anchor = createRelativePositionFromTypeIndex(ytext, sel.anchor);
      const head = createRelativePositionFromTypeIndex(ytext, sel.head);
      if (!compareRelativePositions(this._anchor, anchor) || !compareRelativePositions(this._head, head)) {
        this._anchor = anchor;
        this._head = head;
        this.conf.plugin.notes.updatePresence(this.noteId, {
          hasFocus,
          clientID,
          hue: toHue((_b = (_a8 = this.account) == null ? void 0 : _a8.id) != null ? _b : "0"),
          name: (_d = (_c = this.account) == null ? void 0 : _c.name) != null ? _d : "Collaborator",
          cursor: { head, anchor }
        });
      }
    }
    const decorations = [];
    const listed = this.conf.plugin.notes.listPresences(this.noteId);
    listed.forEach((meta) => {
      if (meta.clientID === clientID) return;
      const { cursor } = meta;
      if (!cursor || !cursor.anchor || !cursor.head) return;
      const absPos = absolutePositionFromCursor(ytext, cursor);
      if (!absPos) return;
      const { start, end, anchor, head } = absPos;
      const color = `hsl(${meta.hue}, 50%, 50%)`;
      const colorLight = `hsl(${meta.hue}, 50%, 50%, 40%)`;
      const name = meta.name;
      try {
        const startLine = update.view.state.doc.lineAt(start);
        const endLine = update.view.state.doc.lineAt(end);
        const selection = import_view3.Decoration.mark({
          attributes: { style: `background-color: ${colorLight}` },
          class: "cm-sgSelection"
        });
        if (startLine.number === endLine.number) {
          decorations.push({
            from: start,
            to: end,
            value: selection
          });
        } else {
          decorations.push({
            from: start,
            to: startLine.from + startLine.length,
            value: selection
          });
          decorations.push({
            from: endLine.from,
            to: end,
            value: selection
          });
          for (let i = startLine.number + 1; i < endLine.number; i++) {
            const linePos = update.view.state.doc.line(i).from;
            decorations.push({
              from: linePos,
              to: linePos,
              value: import_view3.Decoration.line({
                attributes: {
                  style: `background-color: ${colorLight}`,
                  class: "cm-sgLineSelection"
                }
              })
            });
          }
        }
      } catch (error) {
        this.log("Error creating presence decoration", error);
      }
      decorations.push({
        from: head.index,
        to: head.index,
        value: import_view3.Decoration.widget({
          side: head.index - anchor.index > 0 ? -1 : 1,
          block: false,
          widget: new ScreenGardenRemoteCaretWidget(color, name)
        })
      });
    });
    this.decorations = import_view3.Decoration.set(decorations, true);
  }
  handlePresenceSync(id) {
    if (id !== this.noteId) return;
    this.view.dispatch({
      annotations: [sgRemoteSelectionsAnnotation.of([])]
    });
  }
};
__name(_ScreenGardenRemoteSelectionsPluginValue, "ScreenGardenRemoteSelectionsPluginValue");
var ScreenGardenRemoteSelectionsPluginValue = _ScreenGardenRemoteSelectionsPluginValue;
var screenGardenRemoteSelections = import_view2.ViewPlugin.fromClass(
  ScreenGardenRemoteSelectionsPluginValue,
  { decorations: /* @__PURE__ */ __name((v) => v.decorations, "decorations") }
);

// src/services/editor/screenGardenCollab/index.ts
var screenGardenCollab = /* @__PURE__ */ __name((plugin) => {
  const screenGardenSyncConfig = new ScreenGardenSyncConfig(plugin);
  const plugins = [
    screenGardenSyncFacet.of(screenGardenSyncConfig),
    screenGardenSync,
    screenGardenRemoteSelectionsTheme,
    screenGardenRemoteSelections
  ];
  return plugins;
}, "screenGardenCollab");

// src/services/editor/EditorService.ts
var _EditorService = class _EditorService extends Service {
  constructor() {
    super(...arguments);
    this.registerEditorExtension = /* @__PURE__ */ __name(() => {
      const extension = screenGardenCollab(this.plugin);
      this.plugin.registerEditorExtension(extension);
    }, "registerEditorExtension");
  }
  async onload() {
    this.plugin.app.workspace.onLayoutReady(this.registerEditorExtension);
  }
};
__name(_EditorService, "EditorService");
var EditorService = _EditorService;

// src/services/externalProviders/index.ts
init_process_shim();

// src/services/externalProviders/ExternalProvidersService.ts
init_process_shim();

// src/services/externalProviders/ExternalSyncProvider.ts
init_process_shim();
var _ObsidianSync = class _ObsidianSync {
  constructor(plugin) {
    this.name = "Obsidian Sync";
    try {
      this.sync = plugin.app.internalPlugins.plugins.sync;
    } catch (e) {
      this.sync = null;
    }
  }
  get enabled() {
    if (!this.sync) return false;
    return this.sync._loaded || false;
  }
  ignoringPath(path) {
    if (!this.enabled) return false;
    try {
      return this.sync.instance.ignoreFolders.contains(path);
    } catch (e) {
      return false;
    }
  }
  ignorePath(path) {
    if (!this.enabled) return;
    try {
      this.sync.instance.ignoreFolders.push(path);
    } catch (e) {
    }
  }
};
__name(_ObsidianSync, "ObsidianSync");
var ObsidianSync = _ObsidianSync;

// src/services/externalProviders/ExternalProvidersService.ts
var _ExternalProvidersService = class _ExternalProvidersService extends Service {
  constructor(plugin) {
    super(plugin);
    this.providers = [new ObsidianSync(plugin)];
  }
  enabledProviders() {
    return this.formatProviders(this.providers.filter((p) => p.enabled));
  }
  enabledProvidersForPath(path) {
    return this.formatProviders(
      this.providers.filter((p) => p.enabled && !p.ignoringPath(path))
    );
  }
  ignorePath(path) {
    this.providers.forEach((p) => {
      if (!p.enabled || p.ignoringPath(path)) return;
      p.ignorePath(path);
    });
  }
  formatProviders(providers) {
    const p = providers.map((p2) => p2.name);
    switch (p.length) {
      case 0:
        return null;
      case 1:
        return p[0];
      case 2:
        return intl.plurals.two({ val1: p[0], val2: p[1] });
      default:
        return intl.plurals.serial({
          joined: p.slice(0, -1).join(", "),
          last: p[p.length - 1]
        });
    }
  }
};
__name(_ExternalProvidersService, "ExternalProvidersService");
var ExternalProvidersService = _ExternalProvidersService;

// src/ScreenGardenPlugin.ts
var import_debug20 = __toESM(require_browser2());
var import_obsidian21 = require("obsidian");
if (false) {
  global["__ $YJS$ __"] = false;
}
var log15 = (0, import_debug20.default)("screen.garden:plugin");
var _ScreenGardenPlugin = class _ScreenGardenPlugin extends import_obsidian21.Plugin {
  constructor() {
    super(...arguments);
    this.services = [];
  }
  async onload() {
    log15("starting plugin");
    this.appId = this.app.appId;
    this.db = new Database(this.appId);
    this.networkStatus = this.registerService(NetworkStatusService);
    this.settings = this.registerService(SettingsService);
    this.api = this.registerService(ApiService);
    this.protocols = this.registerService(ProtocolHandlerService);
    this.account = this.registerService(AccountService);
    this.docs = this.registerService(DocsService);
    this.notes = this.registerService(NotesService);
    this.collections = this.registerService(CollectionsService);
    this.teams = this.registerService(TeamsService);
    this.socket = this.registerService(SocketService);
    this.views = this.registerService(ViewsService);
    this.editor = this.registerService(EditorService);
    this.externalProviders = this.registerService(ExternalProvidersService);
    for (const service of this.services) {
      log15("loading %s", service.constructor.name);
      await service.onload();
    }
    this.app.workspace.onLayoutReady(async () => {
      for (const service of this.services) {
        await service.onLayoutReady();
      }
    });
    if (false) {
      window.sg = this;
    }
  }
  async onunload() {
    for (const service of this.services.reverse()) {
      log15("stopping %s", service.constructor.name);
      await service.onunload();
    }
  }
  registerService(ServiceImpl) {
    log15("registering %s", ServiceImpl.name);
    const service = new ServiceImpl(this);
    this.services.push(service);
    return service;
  }
};
__name(_ScreenGardenPlugin, "ScreenGardenPlugin");
var ScreenGardenPlugin = _ScreenGardenPlugin;

// src/main.ts
var main_default = ScreenGardenPlugin;
/*! Bundled license information:

dexie/dist/dexie.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/

/* nosourcemap */