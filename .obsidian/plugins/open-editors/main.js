/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OpenEditorsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings/SettingsInterface.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};

// src/constants.ts
var VIEW_TYPE_OPEN_EDITORS = "open-editors";
var ICON_OPEN_EDITORS = "layers";
var VIEW_DISPLAY_OPEN_EDITORS = "Open editors";
var ICON_CLOSE = "x-square";
var ICON_CLOSE_GROUP = "copy-x";
var ICON_CLOSE_WINDOW = "copy-x";

// src/OpenEditorsView.ts
var import_obsidian2 = require("obsidian");

// src/TreeItem.ts
var import_obsidian = require("obsidian");
var TreeItem = class {
  /**
   * Constructor to initialize a TreeItem instance.
   * @param conteinerEl - The parent container to render the tree item in.
   * @param title - The label of the tree item.
   * @param id - A unique identifier for this tree item.
   * @param handler - Optional event handlers
   * @param actions - Optional actions (clickable icons with callbacks)
   */
  constructor(conteinerEl, title, id, type, handler, actions) {
    this.children = [];
    this.id = id;
    this.type = type;
    this.treeItemEl = conteinerEl.createEl("div", { cls: "tree-item" });
    this.selfEl = this.treeItemEl.createEl("div", { cls: "open-editors-tree-item-self tree-item-self is-clickable" });
    this.childrenEl = this.treeItemEl.createEl("div", { cls: "tree-item-children" });
    this.selfEl.onClickEvent((ev) => {
      if (this.selfEl.hasClass("mod-collapsible")) {
        if (this.iconEl.hasClass("is-collapsed")) {
          this.selfEl.removeClass("is-collapsed");
          this.iconEl.removeClass("is-collapsed");
          this.childrenEl.setCssProps({ "display": "block" });
        } else {
          this.selfEl.addClass("is-collapsed");
          this.iconEl.addClass("is-collapsed");
          this.childrenEl.setCssProps({ "display": "none" });
        }
      }
      if (handler == null ? void 0 : handler.onClickCallback) {
        handler.onClickCallback(ev);
      }
    });
    if (handler == null ? void 0 : handler.onDragCallback) {
      this.selfEl.on("drag", "selector", (ev, delegateTarget) => {
        if (handler == null ? void 0 : handler.onDragCallback) {
          handler.onDragCallback(ev, delegateTarget);
        }
      });
    }
    this.selfEl.createEl("div", { cls: "open-editors-tree-item-inner tree-item-inner" }).createEl("div", { cls: "tree-item-inner-text" }).createEl("span", { cls: "tree-item-inner-text", text: title });
    const flairOuter = this.selfEl.createEl("div", { cls: "open-editors-tree-item-flair-outer tree-item-flair-outer" });
    if (actions) {
      actions.forEach((action) => {
        const button = flairOuter.createEl("div", { cls: "tree-item-flair mod-clickable tree-iten-action-icon" });
        (0, import_obsidian.setIcon)(button.createEl("span", { cls: "" }), action.iconId);
        if (action.ariaLabel) {
          button.ariaLabel = action.ariaLabel;
        }
        button.onClickEvent((ev) => {
          ev.stopPropagation();
          action.onClickCallback(ev);
        });
      });
    }
  }
  /**
   * Recursively apply a callback function to the current tree item and its children.
   * @param callback - The function to call for each tree item.
   */
  rekursiveCall(callback) {
    this.children.forEach((child) => {
      child.rekursiveCall(callback);
    });
    callback(this);
  }
  /**
   * Recursively apply a callback funstion to the current tree item and its children if the type matches the given type.
   * @param callback - The function to call for each tree item.
   * @param type - The type TreeItem needs to have
   */
  rekursiveCallForType(actions) {
    this.children.forEach((child) => {
      child.rekursiveCallForType(actions);
    });
    actions.forEach((action) => {
      if (this.type === action.type) {
        action.callback(this);
      }
    });
  }
  /**
   * Add a child TreeItem to this tree item.
   * @param treeCreateCallback - A function that creates and returns a new TreeItem.
   * @returns The newly added TreeItem.
   * @example
   * parent.addChild((containerEl) => new TreeItem(containerEl, "Title", "ID"))
   */
  addChild(treeCreateCallback) {
    if (!this.selfEl.hasClass("mod-collapsible")) {
      this.selfEl.addClass("mod-collapsible");
      this.iconEl = this.selfEl.createEl("div", { cls: "open-editors-tree-item-icon tree-item-icon collapse-icon" });
      (0, import_obsidian.setIcon)(this.iconEl, "right-triangle");
    }
    const child = treeCreateCallback(this.childrenEl);
    this.children.push(child);
    return child;
  }
  /**
   * Remove a child TreeItem by its ID.
   * @param id - The unique identifier of the child to remove.
   */
  removeChild(id) {
    var _a;
    const child = this.children.find((value) => value.id == id);
    if (child) {
      this.children.remove(child);
      child.removeAllChildren();
      child.removeDom();
    }
    if (this.children.length <= 0 && this.selfEl.hasClass("mod-collapsible")) {
      this.selfEl.removeClass("mod-collapsible");
      (_a = this.iconEl) == null ? void 0 : _a.remove();
    }
  }
  /**
   * Remove all child TreeItems from this tree item.
   */
  removeAllChildren() {
    var _a;
    while (this.children.length > 0) {
      const child = this.children.pop();
      if (child) {
        child.removeAllChildren();
        child.removeDom();
      }
    }
    if (this.children.length <= 0 && this.selfEl.hasClass("mod-collapsible")) {
      this.selfEl.removeClass("mod-collapsible");
      (_a = this.iconEl) == null ? void 0 : _a.remove();
    }
  }
  /**
   * Completely delete this tree and all of its children.
   */
  deleteTree() {
    this.removeAllChildren();
    this.removeDom();
  }
  /**
   * Private helper to remove DOM elements associated with this tree item.
   */
  removeDom() {
    var _a, _b, _c, _d;
    (_a = this.treeItemEl) == null ? void 0 : _a.remove();
    (_b = this.selfEl) == null ? void 0 : _b.remove();
    (_c = this.childrenEl) == null ? void 0 : _c.remove();
    (_d = this.iconEl) == null ? void 0 : _d.remove();
  }
};

// src/OpenEditorsView.ts
var OpenEditorsView = class extends import_obsidian2.View {
  /**
   * Initializes the OpenEditorsView with a given workspace leaf.
   * @param leaf - The workspace leaf where this view will be rendered.
   */
  constructor(leaf) {
    super(leaf);
    this.windows = [];
    this.icon = ICON_OPEN_EDITORS;
  }
  getViewType() {
    return VIEW_TYPE_OPEN_EDITORS;
  }
  getDisplayText() {
    return VIEW_DISPLAY_OPEN_EDITORS;
  }
  async onOpen() {
    this.containerEl.empty();
    const container = this.containerEl.createEl("div", { cls: VIEW_TYPE_OPEN_EDITORS + "-container" });
    this.treeEl = container.createEl("div", { attr: { "style": "" } });
    this.registerEvent(this.app.workspace.on("layout-change", async () => {
      this.clearTree();
      this.createTree();
    }));
  }
  /**
   * Creates the tree structure representing the current workspace layout.
   */
  createTree() {
    const layout = this.app.workspace.getLayout();
    const main = layout["main"];
    if (main) {
      const tree = new TreeItem(this.treeEl, "Main window", main.id, main.type, void 0, [{
        iconId: ICON_CLOSE_WINDOW,
        ariaLabel: "Close all",
        onClickCallback: () => {
          tree.rekursiveCallForType([{
            callback: (tree2) => {
              var _a;
              (_a = this.app.workspace.getLeafById(tree2.id)) == null ? void 0 : _a.detach();
            },
            type: "leaf"
          }]);
        }
      }]);
      this.windows.push(tree);
      if (main.children.length > 1) {
        this.TreeWalker(main, tree);
      } else {
        main.children.forEach((element) => {
          this.TreeWalker(element, tree);
        });
      }
    }
    const floatingWindow = layout["floating"];
    if (floatingWindow) {
      floatingWindow.children.forEach((element) => {
        this.TreeWalker(element, void 0);
      });
    }
  }
  /**
   * A recursive function to traverse the workspace layout and build the tree structure.
   * @param layout - The current layout node being processed.
   * @param parent - The parent TreeItem to attach new child TreeItems to.
   */
  TreeWalker(layout, parent) {
    let count = 1;
    switch (layout.type) {
      case "window":
        parent = new TreeItem(this.treeEl, `Window ${count}`, layout.id, layout.type, void 0, [{
          iconId: ICON_CLOSE_WINDOW,
          ariaLabel: "Close all",
          onClickCallback: () => {
            parent == null ? void 0 : parent.rekursiveCallForType([{
              callback: (parent2) => {
                var _a;
                (_a = this.app.workspace.getLeafById(parent2.id)) == null ? void 0 : _a.detach();
              },
              type: "leaf"
            }]);
          }
        }]);
        this.windows.push(parent);
        if (layout.children.length > 1) {
          let groupCount = 1;
          layout.children.forEach((element) => {
            const group = parent == null ? void 0 : parent.addChild((containerEl) => new TreeItem(containerEl, `Group ${groupCount}`, element.id, element.type, void 0, [{
              iconId: ICON_CLOSE_GROUP,
              ariaLabel: "Close all",
              onClickCallback: () => {
                parent == null ? void 0 : parent.rekursiveCallForType([{
                  callback: (tree) => {
                    var _a;
                    (_a = this.app.workspace.getLeafById(tree.id)) == null ? void 0 : _a.detach();
                  },
                  type: "leaf"
                }]);
              }
            }]));
            this.TreeWalker(element, group);
            groupCount++;
          });
        } else {
          layout.children.forEach((element) => {
            this.TreeWalker(element, parent);
          });
          count++;
        }
        break;
      case "split":
        layout.children.forEach((element) => {
          const group = parent == null ? void 0 : parent.addChild((container) => new TreeItem(container, `Group ${count}`, element.id, element.type, void 0, [{
            iconId: ICON_CLOSE,
            ariaLabel: "Close group",
            onClickCallback: () => {
              group == null ? void 0 : group.rekursiveCallForType([{
                callback: (tree) => {
                  var _a;
                  (_a = this.app.workspace.getLeafById(tree.id)) == null ? void 0 : _a.detach();
                },
                type: "leaf"
              }]);
            }
          }, {
            iconId: ICON_CLOSE_GROUP,
            ariaLabel: "Close all editors",
            onClickCallback: () => {
              if (group) {
                let leafParent;
                group.rekursiveCallForType([{
                  callback: (tree) => {
                    const leaf = this.app.workspace.getLeafById(tree.id);
                    if (!leaf) {
                      console.debug("Leaf not found with the id ", tree.id);
                      return;
                    }
                    const parent2 = leaf == null ? void 0 : leaf.parent;
                    if (!parent2) {
                      console.debug("Parent of leaf not found!");
                      return;
                    }
                    leafParent = parent2;
                  },
                  type: "leaf"
                }]);
                if (!leafParent) {
                  console.warn("Parent of leaf not found!");
                  return;
                }
                const newId = this.app.workspace.createLeafInParent(leafParent, 0).id;
                if (!newId) {
                  console.warn("No id of new leaf!");
                  return;
                }
                group == null ? void 0 : group.rekursiveCallForType([{
                  callback: (tree) => {
                    var _a;
                    if (tree.id != newId) {
                      (_a = this.app.workspace.getLeafById(tree.id)) == null ? void 0 : _a.detach();
                    }
                  },
                  type: "leaf"
                }]);
              }
            }
          }]));
          this.TreeWalker(element, group);
          count++;
        });
        break;
      case "tabs":
        layout.children.forEach((element) => {
          this.TreeWalker(element, parent);
        });
        break;
      case "leaf":
        parent == null ? void 0 : parent.addChild((container) => new TreeItem(container, layout.state.title, layout.id, layout.type, {
          onClickCallback: () => {
            const leaf = this.app.workspace.getLeafById(layout.id);
            if (!leaf) {
              console.warn("Leaf not found with the id ", layout.id);
              return;
            }
            this.app.workspace.setActiveLeaf(leaf);
          }
        }, [{
          iconId: ICON_CLOSE,
          ariaLabel: "Close",
          onClickCallback: () => {
            var _a;
            (_a = this.app.workspace.getLeafById(layout.id)) == null ? void 0 : _a.detach();
          }
        }]));
        break;
      default:
        console.warn("Unknown layout component", layout);
        break;
    }
  }
  /**
   * Clears the current tree structure and resets the windows array.
   */
  clearTree() {
    this.windows.forEach((window) => window.deleteTree());
    this.windows = [];
    this.treeEl.empty();
  }
};

// src/main.ts
var OpenEditorsPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(VIEW_TYPE_OPEN_EDITORS, (leaf) => new OpenEditorsView(leaf));
    this.addRibbonIcon(ICON_OPEN_EDITORS, VIEW_DISPLAY_OPEN_EDITORS, () => {
      this.activateView(VIEW_TYPE_OPEN_EDITORS);
    });
    this.addCommand({
      id: "show-view",
      name: "Show",
      callback: () => {
        this.activateView(VIEW_TYPE_OPEN_EDITORS);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView(viewType) {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(viewType);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: viewType, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};

/* nosourcemap */