/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => FolderByTagsDistributor,
  formatNewPath: () => formatNewPath
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/PluginSettingsTab.ts
var import_obsidian2 = require("obsidian");

// src/FolderSuggest.ts
var import_obsidian = require("obsidian");
var FolderSuggest = class extends import_obsidian.AbstractInputSuggest {
  constructor(inputEl, content, onSelectCb, app) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.onSelectCb = onSelectCb;
    this.content = content;
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLocaleLowerCase();
    return [...this.content].filter(
      (content) => content.toLocaleLowerCase().contains(lowerCaseInputStr)
    );
  }
  renderSuggestion(content, el) {
    el.setText(content);
  }
  selectSuggestion(content, evt) {
    this.onSelectCb(content);
    this.inputEl.value = "";
    this.inputEl.blur();
    this.close();
  }
};

// src/PluginSettingsTab.ts
var PluginSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Enable left bar button").setDesc((0, import_obsidian2.sanitizeHTMLToDom)("Display the Sync button on the left <b>Heads up!</b> Reload Obsidian to apply the changes.")).addToggle(
      (component) => component.setValue(this.plugin.settings.addRibbon).onChange(async (value) => {
        this.plugin.settings.addRibbon = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Use frontmatter tags for folder resolver").setDesc("Use tags specifies in 'tags' property of markdown file for distribution between folders").addToggle(
      (component) => component.setValue(this.plugin.settings.useFrontMatterTags).onChange(async (value) => {
        this.plugin.settings.useFrontMatterTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Use content tags for folder resolver").setDesc("Use tags specified inside note content for distribution between folders").addToggle(
      (component) => component.setValue(this.plugin.settings.useContentTags).onChange(async (value) => {
        this.plugin.settings.useContentTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Force sequential tag to directory structure").setDesc("By default, plugin will distribute notes between folders until all tags used. By enabling this setting tag order will matter. For example, tags 'book, science' will not be placed to 'Science/Book' directory hierarchy. It means only 'Book/Science' structure will work.").addToggle(
      (component) => component.setValue(this.plugin.settings.forceSequentialTags).onChange(async (value) => {
        this.plugin.settings.forceSequentialTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Treat nested tags as separate tags").setDesc("By default, plugin treat tags of nested ('science/book') format as separate tags ('science' and 'book'). Disable this setting to apply tag name transformation to folder name as it is: 'science/book' => 'Science/book'").addToggle(
      (component) => component.setValue(this.plugin.settings.treatNestedTagsAsSeparateTagName).onChange(async (value) => {
        this.plugin.settings.treatNestedTagsAsSeparateTagName = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Folder name to place other notes").setDesc("You can specify folder name to put notes that has no more path. Plugin will look for this name in each folder. In case specified name exist, plugin put notes that does not match over there. Make field empty to disable this option.").addText(
      (component) => component.setValue(this.plugin.settings.folderNameToPlaceOtherNotes).onChange(async (value) => {
        this.plugin.settings.folderNameToPlaceOtherNotes = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Excluded folders").setDesc("Add a folder to exclude notes from being moved by plugin").addButton(
      (component) => {
        component.setButtonText("Add excluded folder");
        component.onClick(async () => {
          this.plugin.settings.excludedFolders.push("");
          await this.plugin.saveSettings();
          this.display();
        });
      }
    );
    this.plugin.settings.excludedFolders.forEach((folderPath, index) => {
      const s = new import_obsidian2.Setting(containerEl);
      s.setName(folderPath ? `Excluded folder "${folderPath}"` : "Please, specify the folder name to exclude in the following field.");
      s.addSearch((cb) => {
        new FolderSuggest(cb.inputEl, new Set(this.app.vault.getAllLoadedFiles().filter((file) => this.app.vault.getFolderByPath(file.path) !== null).map((file) => file.path)), async (value) => {
          this.plugin.settings.excludedFolders[index] = value;
          await this.plugin.saveSettings();
          this.display();
        }, this.app);
        cb.inputEl.addEventListener("blur", () => {
          this.display();
        });
        cb.setPlaceholder("Folder").setValue(folderPath).onChange(async (newFolder) => {
          this.plugin.settings.excludedFolders[index] = newFolder;
          await this.plugin.saveSettings();
        });
      }).addExtraButton((cb) => {
        cb.setIcon("cross").setTooltip("Delete").onClick(async () => {
          this.plugin.settings.excludedFolders.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    });
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  addRibbon: true,
  useContentTags: false,
  useFrontMatterTags: true,
  forceSequentialTags: false,
  excludedFolders: [],
  folderNameToPlaceOtherNotes: "OtherNotes",
  treatNestedTagsAsSeparateTagName: true
};
var stripTag = (tag) => {
  return tag.replace(/^#/, "");
};
var capitalizeFirstLetter = (string) => {
  return string.charAt(0).toUpperCase() + string.slice(1);
};
var formatNewPath = (folder, addPath) => {
  if (folder.path === "/") {
    return `${addPath}`;
  }
  return `${folder.path}/${addPath}`;
};
var FolderByTagsDistributor = class extends import_obsidian3.Plugin {
  getExactFolder(tag) {
    return stripTag(tag);
  }
  getUpperLetterFolder(tag) {
    return capitalizeFirstLetter(stripTag(tag));
  }
  getCapitalizedFolder(tag) {
    return stripTag(tag).toUpperCase();
  }
  getUnderScoreFolder(tag) {
    return stripTag(tag).split("_").map((word) => capitalizeFirstLetter(word)).join(" ");
  }
  getUnderScoreImplodedFolder(tag) {
    return stripTag(tag).split("_").map((word) => capitalizeFirstLetter(word)).join("");
  }
  resolveFolderName(currentFolder, tag) {
    for (const func of [this.getExactFolder, this.getUpperLetterFolder, this.getCapitalizedFolder, this.getUnderScoreFolder, this.getUnderScoreImplodedFolder]) {
      const strippedTag = stripTag(tag);
      const childFolderName = func(strippedTag);
      const folderPath = formatNewPath(currentFolder, childFolderName);
      const folder = this.app.vault.getFolderByPath(folderPath);
      if (folder) {
        return folder;
      }
    }
    return null;
  }
  fulfilAlgo(tags) {
    let currentFolder = this.app.vault.getRoot();
    const remainingTags = [...tags];
    let i = 0;
    while (i < remainingTags.length) {
      const currentTag = remainingTags[i];
      if (!currentTag) {
        console.error(`Accessed bad index ${i}`);
        break;
      }
      const folder = this.resolveFolderName(currentFolder, currentTag);
      if (folder) {
        currentFolder = folder;
        remainingTags.remove(currentTag);
        i = 0;
      } else {
        i++;
      }
    }
    return currentFolder;
  }
  sequentialAlgo(tags) {
    let currentFolder = this.app.vault.getRoot();
    for (const tag of tags) {
      const folder = this.resolveFolderName(currentFolder, tag);
      if (folder) {
        currentFolder = folder;
      }
    }
    return currentFolder;
  }
  getExistingFolderForTags(tags) {
    if (this.settings.forceSequentialTags) {
      this.sequentialAlgo(tags);
    }
    return this.fulfilAlgo(tags);
  }
  resolveTagsForFolderDistribution(file) {
    const { useContentTags, useFrontMatterTags } = this.settings;
    const cache = this.app.metadataCache.getFileCache(file);
    if (cache) {
      const tags = [];
      if (useContentTags) {
        const contentTags = cache.tags;
        if (contentTags) {
          tags.push(...contentTags.map((item) => item.tag));
        }
      }
      if (useFrontMatterTags) {
        const frontMatterTags = (0, import_obsidian3.parseFrontMatterTags)(cache.frontmatter);
        if (frontMatterTags) {
          tags.push(...frontMatterTags);
        }
      }
      return tags;
    }
    return null;
  }
  isFileBelongToExcludedFolder(file) {
    const { excludedFolders } = this.settings;
    for (const folderPath of excludedFolders) {
      if (folderPath && file.path.startsWith(folderPath)) {
        return true;
      }
    }
    return false;
  }
  async redistributeAllNotes() {
    var _a;
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (this.isFileBelongToExcludedFolder(file)) {
        continue;
      }
      let tags = this.resolveTagsForFolderDistribution(file);
      if (tags && tags.length > 0) {
        if (this.settings.treatNestedTagsAsSeparateTagName) {
          tags = tags.reduce((prev, value) => {
            prev.push(...value.split("/"));
            return prev;
          }, []);
        }
        let folderForTags = this.getExistingFolderForTags(tags);
        if (folderForTags) {
          const { folderNameToPlaceOtherNotes } = this.settings;
          if (folderNameToPlaceOtherNotes) {
            const otherNotesFolder = this.app.vault.getFolderByPath(formatNewPath(folderForTags, folderNameToPlaceOtherNotes));
            if (otherNotesFolder) {
              folderForTags = otherNotesFolder;
            }
          }
        }
        if (folderForTags) {
          if (((_a = file.parent) == null ? void 0 : _a.path) !== folderForTags.path) {
            new import_obsidian3.Notice(`Moving file "${file.name}" to "${folderForTags.path}" folder`);
            await this.app.vault.rename(file, formatNewPath(folderForTags, file.name));
          }
        }
      }
    }
  }
  loadLayout() {
    this.addCommand({
      id: "redistribute-all-notes-between-the-folders-by-tags",
      name: "Redistribute all notes to folder by tags",
      callback: () => {
        void this.redistributeAllNotes();
      }
    });
    this.addRibbonIcon("sync", "Redistribute all notes to folder by tags", () => {
      void this.redistributeAllNotes();
    });
    this.addSettingTab(new PluginSettingsTab(this.app, this));
  }
  async onload() {
    await this.loadSettings();
    this.loadLayout();
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

/* nosourcemap */